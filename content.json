{"meta":{"title":"一头驮砖的牛","subtitle":"记录一些驮砖的经验，一起学习，一起使劲儿！！！","description":"记录一些驮砖的经验，一起学习，一起使劲儿！！！","author":"一头驮砖的牛","url":"http://www.niu-chao.top"},"pages":[],"posts":[{"title":"利用Runtime解决NSArray越界等问题","slug":"利用Runtime解决NSArray越界等问题","date":"2016-10-08T08:23:48.000Z","updated":"2018-03-07T07:38:10.000Z","comments":true,"path":"2016/10/08/利用Runtime解决NSArray越界等问题/","link":"","permalink":"http://www.niu-chao.top/2016/10/08/利用Runtime解决NSArray越界等问题/","excerpt":"","text":"runtime 是 OC底层的一套C语言的API（引入 &lt;objc/runtime.h&gt; 或&lt;objc/message.h&gt;），编译器最终都会将OC代码转化为运行时代码，通过终端命令编译.m 文件： clang -rewrite-objc xxx.m 可以看到编译后的xxx.cpp（C++文件）。 比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象.cpp 文件 删除掉一些强制转换语句，可以看到调用方法本质就是发消息，[[NSObject alloc]init] 语句发了两次消息，第一次发了alloc 消息，第二次发送init 消息。利用这个功能我们可以探究底层，比如block的实现原理。 需要注意的是，使用 objc_msgSend() sel_registerName()方法需要导入头文件&lt;objc/message.h&gt; 利用Runtime解决NSArray和NSMutableArray数组越界的crash问题废话不多说，直接上代码，其实是很小的功能！！！首先给NSArray创建一个类别，Xcode -&gt; File -&gt; New -&gt; -&gt;File,然后在弹出的视图中选择 source目录下的 Objective-C file 选项，可以直接创建Empty FIle，Category，Protocol和Extension类型的文件，我们选择创建Category(类别文件)，class选择NSArray，名称填写为NSArray+Safe。 .h文件123456789101112#import &lt;Foundation/Foundation.h&gt;/** * 解决NSArray和NSMutableArray数组越界的crash问题，当debug模式下会crash报错方便调试，release模式下会返回nil */@interface NSArray (Safe)@end@interface NSMutableArray (Safe)@end .m文件在.m文件下import 运行文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#import \"NSArray+Safe.h\"#import &lt;objc/runtime.h&gt;@implementation NSArray (Safe)//这个方法无论如何都会执行，而且是最开始执行+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayI\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end@implementation NSMutableArray (SafetyArray)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayM\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end 解析以上代码逻辑主要是在最开始执行的load方法中，通过method_exchangeImplementations 函数去交换函数指针（OC中的方法实际上就是C的函数）IMP。 dispatch_once这里不是“单例”，是保证方法替换只执行一次. load 方法是可以当做类方法主动调用的,为的是避免这种情况.（在我的理解中load方法是被import了以后就会被调用）NSObject的load和initialize方法 方法替换”这种使用情况下,发现有两种写法. 其实也不是两种写法,准确的来说一种是比较严谨的,另一种则没有那么严谨. 发现这两种写法的差异后,我主要集中在下列: class_addMethodclass_replaceMethodmethod_exchangeImplementations 利用Runtime设置字体方法(方法替换的另一种写法—-严谨的写法).h文件12345@interface UIFont(Swizzle)+(void)load;@end .m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import \"UIfont+Swizzle.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation UIFont(Swizzle)+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [UIFont swizzleMethodOrginalMtd:@selector(systemFontOfSize:) newMtd:@selector(myFontOfSize:)]; [UIFont swizzleMethodOrginalMtd:@selector(boldSystemFontOfSize:) newMtd:@selector(myboldFontOfSize:)]; &#125;);&#125;+ (BOOL)swizzleMethodOrginalMtd:(SEL)origSelector newMtd:(SEL)altSelector&#123; Method origMethod = class_getClassMethod([self class], origSelector); if (nil == origMethod) &#123; return NO; &#125; Method altMethod = class_getClassMethod([self class], altSelector); if (nil == altMethod) &#123; return NO; &#125; BOOL didAddMethod = class_addMethod([self class], origSelector, method_getImplementation(altMethod), method_getTypeEncoding(altMethod)); if (didAddMethod) &#123; class_replaceMethod([self class], altSelector, method_getImplementation(origMethod), method_getTypeEncoding(origMethod)); &#125; else &#123; method_exchangeImplementations(origMethod, altMethod); &#125; return YES;&#125;+ (UIFont *)myFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName: @\"Avenir-Light\" size:fontSize];&#125;+ (UIFont *)myboldFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName:@\"Avenir-Medium\" size:fontSize];&#125; 说明:class_addMethod:如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现 1.如果返回成功:则说明被替换方法没有存在.也就是被替换的方法没有被实现,我们需要先把这个方法实现,然后再执行我们想要的效果,用我们自定义的方法去替换被替换的方法. 这里使用到的是class_replaceMethod 这个方法. class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了) 2.如果返回失败:则说明被替换方法已经存在.直接将两个方法的实现交换即可 另外: 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP我们可以利用 class_replaceMethod 来修改类我们可以利用 method_setImplementation 来直接设置某个方法的IMP 其实我们如果 研究过 AFN 代码的话,会发现, AFN 就是第二种写法.在AFURLSessionManager.m的第296行: 123456789static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; Runtime运行时添加属性，或者block属性知识点 key：要保证全局唯一，key与关联的对象是一一对应关系。必须全局唯一。通常用@selector(methodName)作为key。value：要关联的对象。policy：关联策略。有五种关联策略。OBJC_ASSOCIATION_ASSIGN 等价于 @property(assign)。OBJC_ASSOCIATION_RETAIN_NONATOMIC等价于 @property(strong, nonatomic)。OBJC_ASSOCIATION_COPY_NONATOMIC等价于@property(copy, nonatomic)。OBJC_ASSOCIATION_RETAIN等价于@property(strong,atomic)。OBJC_ASSOCIATION_COPY等价于@property(copy, atomic)。 .h123456789#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(id sender);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m1234567891011121314151617181920212223#import \"UIButton+Block.h\"#import &lt;objc/runtime.h&gt;@implementation UIButton (Block)- (void)handelWithBlock:(btnBlock)block &#123; if (block) &#123; objc_setAssociatedObject(self,@selector(btnAction:) , block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction:(id)sender&#123; btnBlock block = objc_getAssociatedObject(self,@selector(btnAction:)); if (block) &#123; block(sender); &#125;&#125;@end 注意：@selector(btnAction:) 部分是第二个参数 ;类型通常都是通常都是会采用静态变量static const char btnKey 来作为关键字 &amp;btnkey ,也可以使用”@selector(btnAction:) “。 第二个参数进一步优化，出现了_cmd 代替了 &amp;btnKey 或者 @selector(methodName). 因为： _cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例. 这里强调当前，_cmd的作用域只在当前方法里，直指当前方法名@selector。**","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://www.niu-chao.top/tags/Runtime/"}]},{"title":"Markdown","slug":"MarkDown","date":"2015-10-08T05:24:22.000Z","updated":"2018-03-07T06:58:46.000Z","comments":true,"path":"2015/10/08/MarkDown/","link":"","permalink":"http://www.niu-chao.top/2015/10/08/MarkDown/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0):'''A docstring'''if param1 &gt; param2: # interestingprint 'Greater'return (param2 - param1 + 1) or Noneclass SomeClass:pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.niu-chao.top/tags/Markdown/"}]},{"title":"niuchao","slug":"niuchao","date":"2014-10-08T03:53:46.000Z","updated":"2018-02-27T10:08:55.000Z","comments":true,"path":"2014/10/08/niuchao/","link":"","permalink":"http://www.niu-chao.top/2014/10/08/niuchao/","excerpt":"","text":"","categories":[],"tags":[]}]}