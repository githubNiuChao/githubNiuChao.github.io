{"meta":{"title":"一头驮砖的牛","subtitle":null,"description":"------ IOS | Python ------","author":null,"url":"http://www.niu-chao.top"},"pages":[{"title":"关于","date":"2017-03-13T09:55:52.000Z","updated":"2018-03-20T12:02:51.000Z","comments":true,"path":"about/index.html","permalink":"http://www.niu-chao.top/about/index.html","excerpt":"","text":"[ 始 终 在 奔 跑 ]"},{"title":"分类","date":"2017-03-02T04:33:16.000Z","updated":"2018-03-13T10:17:12.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.niu-chao.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-14T03:54:25.000Z","updated":"2018-03-13T10:17:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.niu-chao.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"YYAsyncLayer源码&OSAtomic原子操作","slug":"YYAsyncLayer源码&OSAtomic原子操作","date":"2017-04-25T08:43:18.000Z","updated":"2018-04-12T03:05:05.000Z","comments":true,"path":"2017/04/25/YYAsyncLayer源码&OSAtomic原子操作/","link":"","permalink":"http://www.niu-chao.top/2017/04/25/YYAsyncLayer源码&OSAtomic原子操作/","excerpt":"","text":"YYAsyncLayerYYAsyncLayer：继承自CALayer，绘制、创建绘制线程的部分都在这个类。YYTransaction：用于创建RunloopObserver监听MainRunloop的空闲时间，并将YYTranaction对象存放到集合中。YYSentinel：提供获取当前值的value（只读）属性，以及- (int32_t)increase自增加的方法返回一个新的value值，用于判断异步绘制任务是否被取消的工具。 通过下图我们来大概了解一下： 图是整体异步绘制的实现思路，后面一步步说明。现在假设需要绘制Label，其实是继承自UIView，重写+ (Class)layerClass ，在需要重新绘制的地方调用下面方法，比如setter，layoutSubviews。 123456789101112131415161718192021222324252627282930313233#import \"NCLabel.h\"#import \"YYAsyncLayer.h\"@interface NCLabel ()@property (nonatomic, copy) NSString *text;@end@implementation NCLabel//默认值是[CALayer class], 在为视图创建底层时使用。+ (Class)layerClass&#123; return YYAsyncLayer.class;&#125;- (void)setText:(NSString *)text &#123; _text = text.copy; [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];&#125;- (void)layoutSubviews&#123; [super layoutSubviews]; YYTransaction * transaction = [YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)]; [transaction commit];&#125;- (void)contentsNeedUpdated&#123; // do update [self.layer setNeedsDisplay];&#125;@end YYTransaction123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146.h#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** YYTransaction的逻辑也并不复杂：将target和相应selector存入一个set中（重写hash与isEqual用于set判断），并且在runloop中注册kCFRunLoopBeforeWaiting与kCFRunLoopExit事件，将优先级定义为0，即在Core Animation执行完毕后，执行相应的display方法，去模拟Core Animation的绘制机制，进行相应异步绘制的方法。 YYTransaction.h声明 */@interface YYTransaction : NSObject/** 创建和返回一个transaction通过一个定义的target和selector @param target 执行target，target会在runloop结束前被retain @param selector target的selector @return 1个新的transaction，或者有错误时返回nil */+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector;/** 加入transaction到runloop @discussion It will perform the selector on the target once before main runloop's current loop sleep. If the same transaction (same target and same selector) has already commit to runloop in this loop, this method do nothing. 讨论它将在主循环前执行目标选择器 当前循环睡眠。 如果同一个事务（相同的目标和相同的选择器）具有 已经在这个循环中提交了runloop，这个方法什么也不做。 */- (void)commit;@endNS_ASSUME_NONNULL_END.m#import \"YYTransaction.h\"@interface YYTransaction()@property (nonatomic, strong) id target;@property (nonatomic, assign) SEL selector;@endstatic NSMutableSet *transactionSet = nil;//RunloopObserver的回调方法，从transactionSet取出transaction对象执行SEL的方法，分发到每一次Runloop执行，避免一次Runloop执行时间太长。static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; if (transactionSet.count == 0) return; NSSet *currentSet = transactionSet; //获取完上一次需要执行的方法后，将所有方法清空 transactionSet = [NSMutableSet new]; //遍历set。执行里面的selector [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [transaction.target performSelector:transaction.selector];#pragma clang diagnostic pop &#125;];&#125;//同时在YYTransaction.m中注册一个RunloopObserver，监听MainRunloop在kCFRunLoopCommonModes（包含kCFRunLoopDefaultMode、UITrackingRunLoopMode）下的kCFRunLoopBeforeWaiting和kCFRunLoopExit的状态，也就是说在一次Runloop空闲时去执行更新显示的操作。//关于kCRunLoop的监听状态我在之后的博客中解释说明static void YYTransactionSetup() &#123; static dispatch_once_t onceToken;// GCD只执行一次 dispatch_once(&amp;onceToken, ^&#123; transactionSet = [NSMutableSet new]; CFRunLoopRef runloop = CFRunLoopGetMain();//CFRunLoopGetMain方法返回主线程的RunLoop引用。后面用这个引用来添加回调 CFRunLoopObserverRef observer;// 注册runloop监听，在等待与退出前进行// 使用系统内置的c方法创建一个RunLoop的观察者，在创建这个观察者的时候回同时指定回调方法。 observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting | kCFRunLoopExit, true, // repeat 0xFFFFFF, // after CATransaction(2000000) YYRunLoopObserverCallBack, NULL); //给RunLoop实例添加观察者，之后减少一个观察者的引用。 CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes); CFRelease(observer); &#125;);&#125;//创建一个RunLoop的观察者的时候，还指定了观察者观察的事件：kCFRunLoopBeforeWaiting | kCFRunLoopExit，在//RunLoop进入等待或者即将要退出的时候开始执行观察者。指定了观察者是否重复（true）。指定了观察者的优先级：0xFFFFFF，这个优先级比CATransaction优先级为2000000的优先级更低。这是为了确保系统的动画优先执行，之后再执行异步渲染。////YYRunLoopObserverCallBack就是观察者收到通知的时候要执行的回调方法。这个方法的声明是这样的：////static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);@implementation YYTransaction/** 创建和返回一个transaction通过一个定义的target和selector @param target 执行target，target会在runloop结束前被retain @param selector target的selector @return 1个新的transaction，或者有错误时返回nil *///YYTransaction有selector、target的属性，selector其实就是contentsNeedUpdated方法，此时并不会立即在后台线程去更新显示，而是将YYTransaction对象本身提交保存在transactionSet的集合中，上图中所示。+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector&#123; if (!target || !selector) return nil; YYTransaction *t = [YYTransaction new]; t.target = target; t.selector = selector; return t;&#125;- (void)commit &#123; if (!_target || !_selector) return; //初始化runloop监听 YYTransactionSetup(); //添加行为到set中 [transactionSet addObject:self];&#125;//hash值返回（重写hash与isEqual用于set判断）- (NSUInteger)hash &#123; long v1 = (long)((void *)_selector); long v2 = (long)_target; return v1 ^ v2;&#125;//isEqual返回（重写hash与isEqual用于set判断）- (BOOL)isEqual:(id)object &#123; if (self == object) return YES; if (![object isMemberOfClass:self.class]) return NO; YYTransaction *other = object; return other.selector == _selector &amp;&amp; other.target == _target;&#125;@end YYAsyncLayer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340.h#import &lt;UIKit/UIKit.h&gt;#import &lt;QuartzCore/QuartzCore.h&gt;#if __has_include(&lt;YYAsyncLayer/YYAsyncLayer.h&gt;)FOUNDATION_EXPORT double YYAsyncLayerVersionNumber;FOUNDATION_EXPORT const unsigned char YYAsyncLayerVersionString[];#import &lt;YYAsyncLayer/YYSentinel.h&gt;#import &lt;YYAsyncLayer/YYTransaction.h&gt;#else#import \"YYSentinel.h\"#import \"YYTransaction.h\"#endif@class YYAsyncLayerDisplayTask;NS_ASSUME_NONNULL_BEGIN/** YYAsyncLayer类是用于异步渲染内容的CALayer的子类。 @讨论 当图层需要更新其内容时，它会询问委托人 用于异步显示任务以在后台队列中呈现内容。 */@interface YYAsyncLayer : CALayer//是否异步绘制的BOOl类型属性，默认YES@property BOOL displaysAsynchronously;@end/** YYAsyncLayer的委托协议。 YYAsyncLayer的代表（通常是UIView） 必须在该协议中实施该方法。 */@protocol YYAsyncLayerDelegate &lt;NSObject&gt;@required//当图层的内容需要更新时，调用此方法返回新的显示任务。- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask;@end/** YYAsyncLayerDisplayTask类，有三个block属性用于绘制的回调操作，从命名可以看出分别是将要绘制，正在绘制，以及绘制完成的回调，可以从block传入的参数BOOL(^isCancelled)(void)判断当前绘制是否被取消。 */@interface YYAsyncLayerDisplayTask : NSObject/** 该块将在异步绘图开始之前调用。 它将在主线程中调用。 Block参数层：图层。 */@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);/** 调用该块来绘制图层的内容。 @discussion 可以在主线程或后台线程上调用该块， 所以应该是线程安全的。 Block参数上下文：由图层创建的新位图内容。 Block参数大小：内容大小（通常与图层的边界大小相同）。 Block参数isCancelled：如果此块返回“YES”，则方法应取消 尽快绘制过程并返回。 */@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));/** 该块将在异步绘图完成后调用。 它将在主线程中调用。 Block参数层：图层。 Block参数完成：如果绘制过程被取消，则为“否”，否则为“是”。 */@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);@endNS_ASSUME_NONNULL_END.m#import \"YYAsyncLayer.h\"#import \"YYSentinel.h\"#if __has_include(\"YYDispatchQueuePool.h\")#import \"YYDispatchQueuePool.h\"#else#import &lt;libkern/OSAtomic.h&gt;#endif//YYAsyncLayer异步绘制的过程就是一个观察者执行的过程。所谓的观察者就是你设置了一个机关，当它被触发的时候可以执行你预设的东西。比如你走到一扇门前，它感应到了你的红外辐射就会打开。////async layer也是一样，它会把“感应器”放在run loop里。当run loop要闲下来的时候“感应器”的回调开始执行，告诉async layer可以开始异步渲染了。////但是异步渲染要干什么呢？我们现在就来说说异步渲染的内容从哪里来？一个需要异步渲染的view会在定义的时候就把需要异步渲染的内容通过layer保存在view的代理发送给layer。////CALayer和UIView的关系//UIView是显示层，而显示在屏幕上的内容是由CALayer来管理的。CALayer的一个代理方法可以在UIView宿主里实现。///获取这个队列YYAsyncLayerGetDisplayQueue用于绘制（这部分YYKit中有独立的工具YYDispatchQueuePool）。创建队列中有一个参数是告诉队列执行任务的优先级（服务质量）quality of service，在iOS8+之后相比之前系统有所不同。//这里用了一个比较巧妙的方法处理，当使用GCD时提交大量并发任务到后台线程导致线程被锁住、休眠的情况，创建与程序当前激活CPU数量（activeProcessorCount）相同的串行队列，并限制MAX_QUEUE_COUNT，将队列存放在数组中。//不能无限的开辟线程//我们都知道，把阻塞主线程执行的代码放入另外的线程里保证APP可以及时的响应用户的操作。但是线程的切换也是需要额外的开销的。也就是说，线程不能无限度的开辟下去。////那么，dispatch_queue_t的实例也不能一直增加下去。有人会说可以用dispatch_get_global_queue()来获取系统的队列。没错，但是这个情况只适用于少量的任务分配。因为，系统本身也会往这个queue里添加任务的。////所以，我们需要用自己的queue，但是是有限个的。在YY里给这个数量指定的最大值是16。它会首先判断CPU的核数(int)[NSProcessInfo processInfo].activeProcessorCount。如果核数大于给定的最大值则使用最大值。////开辟线程的时候使用的是YYKit里自己的一套“线程池”工具来控制开辟的线程数量的。static dispatch_queue_t YYAsyncLayerGetDisplayQueue() &#123;#ifdef YYDispatchQueuePool_h return YYDispatchQueueGetForQOS(NSQualityOfServiceUserInitiated);#else#define MAX_QUEUE_COUNT 16 static int queueCount; static dispatch_queue_t queues[MAX_QUEUE_COUNT]; static dispatch_once_t onceToken; static int32_t counter = 0; dispatch_once(&amp;onceToken, ^&#123; //程序激活的处理器数目，如果核数大于给定的最大值则使用最大值。 queueCount = (int)[NSProcessInfo processInfo].activeProcessorCount; queueCount = queueCount &lt; 1 ? 1 : queueCount &gt; MAX_QUEUE_COUNT ? MAX_QUEUE_COUNT : queueCount; if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123; for (NSUInteger i = 0; i &lt; queueCount; i++) &#123; dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, 0);//创建设置优先级的实例dispatch_queue_attr_t 这部分内容也在本博客GCD讲解中有提到 queues[i] = dispatch_queue_create(\"com.ibireme.yykit.render\", attr); &#125; &#125; else &#123; for (NSUInteger i = 0; i &lt; queueCount; i++) &#123; queues[i] = dispatch_queue_create(\"com.ibireme.yykit.render\", DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(queues[i], dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));//设置dispatch_get_global_queue为目标队列 就是把dispatch_queue_create创建的queue的优先级设置为和dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)为同一优先级。这部分内容也在本博客GCD讲解中有提到 &#125; &#125; &#125;); //给counter +1 int32_t cur = OSAtomicIncrement32(&amp;counter); if (cur &lt; 0) cur = -cur; //每次从数组取出 return queues[(cur) % queueCount];#undef MAX_QUEUE_COUNT#endif&#125;//创建默认优先级的YYAsyncLayerGetReleaseQueue队列static dispatch_queue_t YYAsyncLayerGetReleaseQueue() &#123;#ifdef YYDispatchQueuePool_h return YYDispatchQueueGetForQOS(NSQualityOfServiceDefault);#else return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);#endif&#125;@implementation YYAsyncLayerDisplayTask@end@implementation YYAsyncLayer &#123; YYSentinel *_sentinel;&#125;#pragma mark - Override+ (id)defaultValueForKey:(NSString *)key &#123; if ([key isEqualToString:@\"displaysAsynchronously\"]) &#123; return @(YES); &#125; else &#123; return [super defaultValueForKey:key]; &#125;&#125;- (instancetype)init &#123; self = [super init]; static CGFloat scale; //global static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; scale = [UIScreen mainScreen].scale; &#125;); self.contentsScale = scale; _sentinel = [YYSentinel new]; _displaysAsynchronously = YES; return self;&#125;//视图被释放调用了dealloc方法，后台的绘制任务被取消- (void)dealloc &#123; [_sentinel increase];&#125;//视图调用setNeedsDisplay时说明视图的内容需要被更新，将当前的绘制任务取消，需要重新显示- (void)setNeedsDisplay &#123; [self _cancelAsyncDisplay];//先将后台的绘制任务取消，再去进行新的绘制 [super setNeedsDisplay];&#125;//重写CALayer的display 方法来调用绘制的方法- (void)_displayAsync:(BOOL)async。- (void)display &#123; super.contents = super.contents; [self _displayAsync:_displaysAsynchronously];&#125;#pragma mark - Private// 主要是一些逻辑判断以及绘制函数，在异步执行之前通过YYAsyncLayerGetDisplayQueue创建的队列，这里通过YYSentinel判断当前的value是否等于之前的值，如果不相等，说明绘制任务被取消了，绘制过程会多次判断是否取消，如果是则return，保证被取消的任务能及时退出，如果绘制完毕则设置图片到layer.contents。// 关于后台的绘制任务何时会被取消，下面两种情况需要取消，并调用了YYSentinel的increase方法，使value值增加（线程安全）：//// 1、在视图调用setNeedsDisplay时说明视图的内容需要被更新，将当前的绘制任务取消，需要重新显示。// 2、以及视图被释放调用了dealloc方法。- (void)_displayAsync:(BOOL)async &#123; __strong id&lt;YYAsyncLayerDelegate&gt; delegate = (id)self.delegate; YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];//代理中提供方法用于回调绘制的代码 if (!task.display) &#123; if (task.willDisplay) task.willDisplay(self); self.contents = nil; if (task.didDisplay) task.didDisplay(self, YES); return; &#125;// 绘制的代码，主要是一些逻辑判断以及绘制函数，在异步执行之前通过YYAsyncLayerGetDisplayQueue创建的队列，这里通过YYSentinel判断当前的value是否等于之前的值，如果不相等，说明绘制任务被取消了，绘制过程会多次判断是否取消，如果是则return，保证被取消的任务能及时退出，如果绘制完毕则设置图片到layer.contents if (async) &#123; if (task.willDisplay) task.willDisplay(self);//Layer图层本身传如到willDisplay的Block属性 YYSentinel *sentinel = _sentinel; int32_t value = sentinel.value;//通过YYSentinel判断当前的value是否等于之前的值，如果不相等，说明绘制任务被取消了 BOOL (^isCancelled)(void) = ^BOOL() &#123; return value != sentinel.value; &#125;; CGSize size = self.bounds.size; BOOL opaque = self.opaque; CGFloat scale = self.contentsScale; CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL; if (size.width &lt; 1 || size.height &lt; 1) &#123; CGImageRef image = (__bridge_retained CGImageRef)(self.contents); self.contents = nil; if (image) &#123; dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123; CFRelease(image); &#125;); &#125; if (task.didDisplay) task.didDisplay(self, YES); CGColorRelease(backgroundColor); return; &#125; dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123; if (isCancelled()) &#123; CGColorRelease(backgroundColor); return; &#125; UIGraphicsBeginImageContextWithOptions(size, opaque, scale); CGContextRef context = UIGraphicsGetCurrentContext(); if (opaque) &#123; //不透明 CGContextSaveGState(context); &#123; if (!backgroundColor || CGColorGetAlpha(backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; if (backgroundColor) &#123; CGContextSetFillColorWithColor(context, backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); CGColorRelease(backgroundColor); &#125; task.display(context, size, isCancelled); if (isCancelled()) &#123; UIGraphicsEndImageContext(); dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); if (isCancelled()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; if (task.didDisplay) task.didDisplay(self, NO); &#125;); return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123;//回归主线程 if (isCancelled()) &#123; if (task.didDisplay) task.didDisplay(self, NO); &#125; else &#123; self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125; &#125;); &#125;); &#125; else &#123; [_sentinel increase]; if (task.willDisplay) task.willDisplay(self); UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale); CGContextRef context = UIGraphicsGetCurrentContext(); if (self.opaque) &#123; CGSize size = self.bounds.size; size.width *= self.contentsScale; size.height *= self.contentsScale; CGContextSaveGState(context); &#123; if (!self.backgroundColor || CGColorGetAlpha(self.backgroundColor) &lt; 1) &#123; CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; if (self.backgroundColor) &#123; CGContextSetFillColorWithColor(context, self.backgroundColor); CGContextAddRect(context, CGRectMake(0, 0, size.width, size.height)); CGContextFillPath(context); &#125; &#125; CGContextRestoreGState(context); &#125; task.display(context, self.bounds.size, ^&#123;return NO;&#125;); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); self.contents = (__bridge id)(image.CGImage); if (task.didDisplay) task.didDisplay(self, YES); &#125;&#125;//取消异步绘制的任务- (void)_cancelAsyncDisplay &#123; [_sentinel increase];&#125;@end YYSentinel12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152.h#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** YYSentinel是一个线程安全递增计数器。 它可能在一些多线程情况下使用。 线程安全的计数器 */@interface YYSentinel : NSObject/** 当前计数 *//// Returns the current value of the counter.@property (readonly) int32_t value;/** 原子性增加值 @return 新值 *//// Increase the value atomically./// @return The new value.- (int32_t)increase;@endNS_ASSUME_NONNULL_END.m#import \"YYSentinel.h\"#import &lt;libkern/OSAtomic.h&gt;@implementation YYSentinel &#123; int32_t _value;&#125;- (int32_t)value &#123; return _value;&#125;- (int32_t)increase &#123;// 自增加的方法返回一个新的value值，用于判断异步绘制任务是否被取消的工具。 return OSAtomicIncrement32(&amp;_value);&#125;@end ##总结 我们把整个异步渲染的过程来串联起来。 对一个包含了YYAsyncLayer的view，比如YYLable,重写layoutSubviews方法添加对layer的setNeedsDisplay方法的调用。 这样一个调用链就形成了：用户操作-&gt;RunLoop(Waiting | Exiting)-&gt;调用observer的回调-&gt;[view layoutSubviews]-&gt;[view.layer setNeedsDisplay]-&gt;[layer display]-&gt;[layer _displayAsync]异步绘制开始（准确的说是_displayAsync方法的参数为true的时候开始异步绘制）。 但是这并没有用到RunLoop。所以代码会修改为每次调用layoutSubviews的时候给RunLoop提交一个异步绘制的任务.","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"CFRunLoop应用","slug":"CFRunLoop应用","date":"2017-04-21T04:34:56.000Z","updated":"2018-03-15T12:51:26.000Z","comments":true,"path":"2017/04/21/CFRunLoop应用/","link":"","permalink":"http://www.niu-chao.top/2017/04/21/CFRunLoop应用/","excerpt":"","text":"CFRunLoop分析卡顿的原因 –所有cell加载都在主线程的一次Runloop循环里面!!!UI的渲染也属于Runloop的事情!!!卡顿就是因为一次Runloop循环,渲染的图片太多了,而且都是高清大图!!! 解决思路 —&gt;让Runloop循环每次只加载一张图片步骤:—通过观察(oberserver)Runloop的循环;—Runloop循环一次,只加载一张图片;—-&gt; Cell数据源加载图片的代码放在数组列表中去.—-&gt; Runloop循环一次,就从数组里面拿到一张图片加载 查看系统CFRunloop代码,我们可以知道,对应之前的说的Runloop包含三个部分, Timer, Source ,Observe; 里面包含—–APP启动的第一条线程这三个结构体指针 typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef; typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef; typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef; —-运行循环观察者活动Run Loop Observer Activitiestypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), //进入Runloop循环通知 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //Runloop在处理Timer之前通知 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //Runloop在处理Sources之前通知 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //Runloop在处理完Sources/Timer之后即将要进入Waiting状态通知 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //Runloop在结束Waiting状态即将要处理Sources/Timer时通知,与BeforeTimers/BeforeSources异曲同工,但是它可以观察即将要处理Sources/Timer,BeforeTimers/BeforeSources只能观察各种对应的….!!! kCFRunLoopExit = (1UL &lt;&lt; 7), //Runloop退出通知 kCFRunLoopAllActivities = 0x0FFFFFFFU //Runloop以上所有的活动都会通知!!!}; —–OC里面回调有Block,代理,KVO!!! 但是在C语言里面只有函数指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169.h#import &lt;UIKit/UIKit.h&gt;@interface NCViewController : UIViewController+ (void)task_1:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_2:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_3:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_4:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_5:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;@end.m#import \"NCViewController.h\"#import \"NCCFRunLoopWorkDistribution.h\"static NSString *IDENTIFIER = @\"IDENTIFIER\";static CGFloat CELL_HEIGHT = 135.f;@interface NCViewController () &lt;UITableViewDataSource, UITableViewDelegate&gt;@property (nonatomic, strong) UITableView *ncTableView;@end@implementation NCViewController- (void)loadView &#123; self.view = [UIView new]; self.ncTableView = [UITableView new]; self.ncTableView.delegate = self; self.ncTableView.dataSource = self; [self.view addSubview:self.ncTableView];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.ncTableView.frame = self.view.bounds;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self.ncTableView registerClass:[UITableViewCell class] forCellReuseIdentifier:IDENTIFIER];&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 520;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:IDENTIFIER]; cell.selectionStyle = UITableViewCellSelectionStyleNone; cell.currentIndexPath = indexPath; [NCViewController task_5:cell indexPath:indexPath]; [NCViewController task_1:cell indexPath:indexPath]; //添加Runloop的任务列表里面 [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_2:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_3:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_4:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; return cell;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return CELL_HEIGHT;&#125;+ (void)task_5:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; for (NSInteger i = 1; i &lt;= 5; i++) &#123; [[cell.contentView viewWithTag:i] removeFromSuperview]; &#125;&#125;+ (void)task_1:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(5, 5, 300, 25)]; label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor redColor]; label.text = [NSString stringWithFormat:@\"%zd - 图纸索引是重中之重\", indexPath.row]; label.font = [UIFont boldSystemFontOfSize:13]; label.tag = 1; [cell.contentView addSubview:label];&#125;+ (void)task_2:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(105, 20, 85, 85)]; imageView.tag = 2; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;+ (void)task_3:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(200, 20, 85, 85)]; imageView.tag = 3; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;+ (void)task_4:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(5, 99, 300, 35)]; label.lineBreakMode = NSLineBreakByWordWrapping; label.numberOfLines = 0; label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor colorWithRed:0 green:100.f/255.f blue:0 alpha:1]; label.text = [NSString stringWithFormat:@\"%zd - 绘制大图像的优先级较低。 应分配到不同的运行循环中.\", indexPath.row]; label.font = [UIFont boldSystemFontOfSize:13]; label.tag = 4; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(5, 20, 85, 85)]; imageView.tag = 5; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:label]; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; &#125;@end CFRunLoop处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178.h#import &lt;UIKit/UIKit.h&gt;typedef BOOL(^NCCFRunLoopWorkDistributionUnit)(void);@interface NCCFRunLoopWorkDistribution : NSObject@property (nonatomic, assign) NSUInteger maximumQueueLength;+ (instancetype)sharedRunLoopWorkDistribution;- (void)addTask:(NCCFRunLoopWorkDistributionUnit)unit withKey:(id)key;- (void)removeAllTasks;@end@interface UITableViewCell (NCCFRunLoopWorkDistribution)@property (nonatomic, strong) NSIndexPath *currentIndexPath;@end.m#import \"NCCFRunLoopWorkDistribution.h\"#import &lt;objc/runtime.h&gt;#define NCCFRunLoopWorkDistribution_DEBUG 1@interface NCCFRunLoopWorkDistribution ()//(4.....) 定义任务数组@property (nonatomic, strong) NSMutableArray *tasks;@property (nonatomic, strong) NSMutableArray *tasksKeys;@property (nonatomic, strong) NSTimer *timer;@end@implementation NCCFRunLoopWorkDistribution- (void)removeAllTasks &#123; [self.tasks removeAllObjects]; [self.tasksKeys removeAllObjects];&#125;//(5....)保存block任务到数组- (void)addTask:(NCCFRunLoopWorkDistributionUnit)unit withKey:(id)key&#123; [self.tasks addObject:unit]; [self.tasksKeys addObject:key]; //如果要执行的Task任务超出屏幕范围个数就把第一个删了... if (self.tasks.count &gt; self.maximumQueueLength) &#123; [self.tasks removeObjectAtIndex:0]; [self.tasksKeys removeObjectAtIndex:0]; &#125;&#125;- (void)_timerFiredMethod:(NSTimer *)timer &#123; //We do nothing here&#125;- (instancetype)init&#123; if ((self = [super init])) &#123; _maximumQueueLength = 30; _tasks = [NSMutableArray array]; _tasksKeys = [NSMutableArray array]; _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(_timerFiredMethod:) userInfo:nil repeats:YES]; &#125; return self;&#125;+ (instancetype)sharedRunLoopWorkDistribution &#123; static NCCFRunLoopWorkDistribution *singleton; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; singleton = [[NCCFRunLoopWorkDistribution alloc] init]; //注意这里传的是一个self的OC对象 [self _registerRunLoopWorkDistributionAsMainRunloopObserver:singleton]; &#125;); return singleton;&#125;+ (void)_registerRunLoopWorkDistributionAsMainRunloopObserver:(NCCFRunLoopWorkDistribution *)runLoopWorkDistribution &#123; static CFRunLoopObserverRef defaultModeObserver; // (2.....) 创建观察者CFRunLoopObserver,封装了一个函数方法 _registerObserver(kCFRunLoopBeforeWaiting, defaultModeObserver, NSIntegerMax - 999, kCFRunLoopCommonModes, (__bridge void *)runLoopWorkDistribution, &amp;_defaultModeRunLoopWorkDistributionCallback);&#125;//创建观察者CFRunLoopObserver函数方法static void _registerObserver(CFOptionFlags activities, CFRunLoopObserverRef observer, CFIndex order, CFStringRef mode, void *info, CFRunLoopObserverCallBack callback) &#123;// (1....)拿到当前的Runloop CFRunLoopRef runLoop = CFRunLoopGetCurrent(); //定义第六个参数,上下文结构体,里面的info同callback函数中的void *info参数有联系,会传一个self CFRunLoopObserverContext context = &#123; 0, info, //这个info实际上就是self , info == (__bridge void *)self; (需要__bridge桥接,因为这里是将OC转为C语言) &amp;CFRetain, &amp;CFRelease, NULL &#125;; //创建观察者 CFRunLoopObserver 关键系统方法 //二参数看扩展②,我们选择的是kCFRunLoopBeforeWaiting //三参数是否循环观察 //五参数创建函数的回调,直接写callback函数指针,所以我们定义了一个函数:_defaultModeRunLoopWorkDistributionCallback //六参数创建上下文,取定义好的一个结构体指针 observer = CFRunLoopObserverCreate(NULL, activities, YES, order, callback, &amp;context);// (3.....)添加观察者,这里用的mode是kCFRunLoopDefaultMode---只能拖拽完毕后加载, kCFRunLoopCommonModes----可以边拖动边加载 CFRunLoopAddObserver(runLoop, observer, mode); //释放:因为这里是C语言环境,不属于ARC,所有带有几个单词的函数需要注意'释放' -- new,cope,create 会在堆区域开辟内存空间!!! CFRelease(observer);&#125;// (4....)//定义一个函数方法,用于创建创建观察者 CFRunLoopObserverstatic void _defaultModeRunLoopWorkDistributionCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; _runLoopWorkDistributionCallback(observer, activity, info);&#125;//在源码中我们看到CallBack是这个样式的,理由有三个参数,第一个和第二个我们都有解释,那三个是什么??//------void *info 是一个万能指针,直接打印啥都没有,需要同CFRunLoopObserverCreate中的上下文结构体指针(&amp;context)有联系,在里面传selfstatic void _runLoopWorkDistributionCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; //(5....)提取self的tesks任务列表 //*********这里为什么取不到self******** //因为只有OC的方法本质是消息机制,就是发送消息megSend(),里面才有两个隐藏的函数: 1、id self(方法调用者) 2、SEL _cmd,C语言函数里面是没有的. //通过上下文指针&amp;context传值self,然后桥接__bridge成OC的self NCCFRunLoopWorkDistribution *runLoopWorkDistribution = (__bridge NCCFRunLoopWorkDistribution *)info; //取到self就能拿到它的任务列表tasks,tasks里面是NCCFRunLoopWorkDistributionUnitBlock. //如果tasks里面没有block任务,那就直接返回 if (runLoopWorkDistribution.tasks.count == 0) &#123; return; &#125; BOOL result = NO; while (result == NO &amp;&amp; runLoopWorkDistribution.tasks.count) &#123; //取到NCCFRunLoopWorkDistributionUnitBlock任务 NCCFRunLoopWorkDistributionUnit unit = runLoopWorkDistribution.tasks.firstObject; //执行block result = unit(); //执行完需要删除任务 [runLoopWorkDistribution.tasks removeObjectAtIndex:0]; [runLoopWorkDistribution.tasksKeys removeObjectAtIndex:0]; &#125;&#125;@end@implementation UITableViewCell (NCCFRunLoopWorkDistribution)@dynamic currentIndexPath;- (NSIndexPath *)currentIndexPath &#123; NSIndexPath *indexPath = objc_getAssociatedObject(self, @selector(currentIndexPath)); return indexPath;&#125;- (void)setCurrentIndexPath:(NSIndexPath *)currentIndexPath &#123; objc_setAssociatedObject(self, @selector(currentIndexPath), currentIndexPath, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 代码中注释就是我个人理解","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"RunLoop线程","slug":"RunLoop线程","date":"2017-04-19T02:12:55.000Z","updated":"2018-03-15T12:49:49.000Z","comments":true,"path":"2017/04/19/RunLoop线程/","link":"","permalink":"http://www.niu-chao.top/2017/04/19/RunLoop线程/","excerpt":"","text":"RunLoopRunloop，顾名思义就是跑圈，他的本质就是一个do，while循环，当有事做时就做事，没事做时就休眠。至于怎么做事，怎么休眠,这个是由系统内核来调度。 首先我们要明确一个概念，线程一般都是一次执行完毕任务，就销毁了。而在线程中添加了runloop，并运行起来，实际上是添加了一个do，while循环，这样这个线程的程序就一直卡在do，while循环上，这样相当于线程的任务一直没有执行完，所有线程一直不会销毁。所有，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop，至于停止的方式，我们接着往下看。 主线程的RunLoopmain.m12345678910111213141516171819202122 /*拓展* 循环与递归 区别???? 方法的调用就是函数的调用,函数调用本质: 分配一块栈区域!!递归就是自己调用自己,反复的调用就会反复的分配空间,所有造成堆栈溢出; 汇编语言中会提到为什么递归即函数的反复调用会反复开辟栈空间,而死循环不会反复开辟空间. */#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123;// NSLog(@\"来了\"); /*UIApplicationMain为我们创建了一个:主循环Runloop,默认开启 1.保证程序不退出; 2.监听事件,触摸事件,时钟,网络事件; 3.如果没有时间发生,就会进入休眠状态,性能损耗低; */ int main = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@\"走了\"); return main; &#125;&#125; Runloop 初探1234567891011121314151617181920212223 - (void)viewDidLoad &#123; [super viewDidLoad]; //此方法默认封装到Runloop里面了; //***此方法默认加入的是默认模式,所以依然会出现UI操作冲突的问题*** [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //此方法默认不加入Runloop,需要手动加入到Runloop循环当中去 NSTimer *time = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //[NSRunLoop mainRunLoop];当前就是主Runloop //NSDefaultRunLoopMode 默认模式 //UITrackingRunLoopMode UI模式 //NSRunLoopCommonModes 占位模式 原则上讲它不属于Runloop模式 // [[NSRunLoop currentRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];//UI操作(触摸)时和timer事件 相互跳动执行 // [[NSRunLoop currentRunLoop] addTimer:time forMode:UITrackingRunLoopMode];//只会在有UI操作(触摸)时执行timer事件 [[NSRunLoop currentRunLoop] addTimer:time forMode:NSRunLoopCommonModes];//UI操作(触摸)时和timer事件正常执行&#125;- (void)timerMethod&#123; NSLog(@\"timerMethod执行 当前线程%@:\",[NSThread currentThread]);&#125; 拓展 Runloop始终与线程将关联Runloop有5中模式 每一种模式中都包含 timer —- source —- observer NSDefaultRunLoopMode 默认模式UITrackingRunLoopMode UI模式–1.用户体验优先级最高 2.只会在有UI操作(触摸)时进行NSRunLoopCommonModes 占位模式 原则上讲它不属于Runloop模式内核模式初始化模式 当将timer事件设定为,可以理解为添加到 默认模式的事件列表下,并添加到主线程的Runloop中,但是我们知道凡是UI操作的事件都是添加到主线程上的,所以在默认模式下的timer事件会与UI操作事件发生冲突,主线程上的Runloop会在timer事件与UI操作事件上来回跳动Run执行;但是如果将timer事件添加到UI模式下,就会发现它只会在有触摸或者说有UI操作时才会执行. RunLoop与线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@interface ViewController ()@property (nonatomic,strong) NCThread *ncThread;//demo2为了测试线程是否被释放----设置strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放;@property (nonatomic, strong) dispatch_source_t timer;@end@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; //子线程 NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSTimer *time = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //注意这里是子线程的Runloop [[NSRunLoop currentRunLoop] addTimer:time forMode:NSRunLoopCommonModes];//UI操作(触摸)时和timer事件正常执行 // while (true) &#123; //什么事情都不做,这里只是让线程有执行不完的任务,进而保住线程不被释放; //----虽然线程保住了,但是timerMethod事件却未处理是为什么呢????? 想一想这里是不是子线程!!!; // &#125; //Runloop ----子线程的Runloop默认是不会开启的,这就解释了为什么线程保住了却未执行timerMethod方法!!!! 看拓展② //currentRunLoop会调用底层的CFRunloop,在这里只有此currentRunLoop()调用时才回去创建一个Runloop,是个懒加载过程!!! [[NSRunLoop currentRunLoop] run];//run起来死循环任务,不会执行下面的代码 //现在考虑一下Runloop如何被停止呢???? 好,尝试在timerMethod方法中将线程退出,线程一但退出那是不是Runloop也就被退出了!!! NSLog(@\"线程来了\");//当run起来后timerMethod虽然执行了,但是这里不会打印执行,因为上面的Runloop是死循环,类似于UIApplicationMain的下面不会执行一样; &#125;]; //这个方法是在主线程上执行的,不会等待block,所以对于Thread的释放是没有关系的. [thread start]; &#125; //1.当子线程thread为局部变量时此方法不会执行,因为被释放了; //2.但是当子线程为_ncThread全局变量时也不会执行, 为什么呢????? ----strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放; - (void)timerMethod&#123; NSLog(@\"timerMethod执行 当前线程%@:\",[NSThread currentThread]);//不会执行 看拓展① //暴力干掉子线程!!!!对应上面的Runloop退出. [NSThread exit]; [NSThread sleepForTimeInterval:1.0];//模拟耗时操作,从而引进子线程概念 &#125; -(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [NSThread exit];//暴力干掉主线程会出现什么情况呢??? //答案是主线程被杀死了,例子中的拖动等主线程UI操作不会执行了, 这是为什么呢???主线程都能被干掉?太不可思议了!!! 看拓展③ &#125;#import \"NCThread.h\"@implementation NCThread-(void)dealloc&#123; NSLog(@\"线程释放!!!\");&#125;@end 拓展 ①线程的生命,只能通过线程的任务去保住,无任务就会被释放!!! —-让线程有执行不完的任务(Runloop 死循环任务),线程就不会释放了!!!! —-所以它在例子中block任务执行完毕后就会被释放; ②主线程的Runloop是在UIApplicationMain中默认开启新创建的线程默认是不会开启的. ③主线程对于系统来说也是一个子线程,这么多APP,对于系统来说的就有这么多子线程;—–APP启动的第一条线程主线程进行UI操作,UIKit框架也是线程不安全的,保证线程安全就需要’锁’,但是凡是’锁’都需要消耗性能,就好像属性里面的nonatomic也是避免消耗性能的,所以苹果规定 “凡是UI操作统一放在—-主线程”,当然可以尝试一下放在子线程,如果出现资源抢夺,会出现未知的问题. RunLoop与线程之间的通信1234567891011121314151617181920212223242526 - (void)viewDidLoad &#123; [super viewDidLoad]; //子线程 NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@\"子线程进来 :%@\",[NSThread currentThread]); while (true) &#123; // ***Runloop启动线程间的通信*** [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.0001]]; &#125; &#125;]; [thread start]; //线程间的通信----在主线程上为子线程添加了一个任务; //但是子线程为启动Runloop,所以otherMethod不会执行,不管它是不是在start之前还是之后; //这个方法实际上是将放在Runloop事件队列里面,所以单纯加一个while死循环也不能执行,需要通过Runloop去启动线程之间的通信 [self performSelector:@selector(otherMethod) onThread:thread withObject:nil waitUntilDone:NO];&#125;-(void)otherMethod&#123; NSLog(@\"otherMethod%@\",[NSThread currentThread]);&#125; Runloop与GCD1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface ViewController ()@property (nonatomic,strong) NCThread *ncThread;//demo2为了测试线程是否被释放----设置strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放;@property (nonatomic, strong) dispatch_source_t timer;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];// GCD与Runloop有紧密的联系// **** 用GCD创建的timer,运行后发现与UI操作完美运行,没有冲突,说明GCD把我们封装好了Runloop, 底层就CFRunloop***** //创建timer 并把它放在全局队列里面 _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); //设置timer dispatch_source_set_timer(_timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC,0); //创建句柄 回调 dispatch_source_set_event_handler(_timer, ^&#123; NSLog(@\"------线程:%@\",[NSThread currentThread]); &#125;); //启动timer dispatch_resume(_timer); // GCD timer创建代码块 // dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, &lt;#dispatchQueue#&gt;); // dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, &lt;#intervalInSeconds#&gt; * NSEC_PER_SEC, &lt;#leewayInSeconds#&gt; * NSEC_PER_SEC); // dispatch_source_set_event_handler(timer, ^&#123; // &lt;#code to be executed when timer fires#&gt; // &#125;); // dispatch_resume(timer);&#125;//打开方法断点,点击屏幕可以查看函数调用栈(如何查看调用栈呢----在lldb模式下输入:thread backtrace ),可以看到CFRunLoopDoSource0,根据拓展我们知道Source0不是内核事件,对啊,因为他是咱们点击出来的,用户事件嘛!!! 拓展①-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;&#125; 拓展 ① 通过GCD代码我们引入了Source这个概念,是不是很眼熟,没错在每个Runloop都包含三个部分: Timer, Source ,Observe;(可以去CFRunloop源码里查看为什么包含这三部分) Source—事件源(输入源) 对应的是—CFRunloopSourceRef,凡是看到” Ref” 这个字的时候就代表他是一个结构体指针; 按照函数调动栈解释:Source分为两个部分;Source0:不是Source1就是Source0Source1:内核与其他线程的通讯事件","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"关于IOS中的深、浅拷贝以及完全拷贝","slug":"关于IOS中的深、浅拷贝以及完全拷贝","date":"2017-03-27T10:44:26.000Z","updated":"2018-04-11T09:45:54.000Z","comments":true,"path":"2017/03/27/关于IOS中的深、浅拷贝以及完全拷贝/","link":"","permalink":"http://www.niu-chao.top/2017/03/27/关于IOS中的深、浅拷贝以及完全拷贝/","excerpt":"","text":"简述深浅拷贝我们实例化的对象存储在堆区，而指向对象的指针一般存储在栈区。我们需要知道这个前提。实际上拷贝分为深拷贝（one level deep copy），浅拷贝（shallow copy）和完全拷贝（real deep copy）三种。 浅拷贝：在操作中，对于被复制对象的每一层都是指针复制。深拷贝：在操作中，对于被复制对象，至少有一层是深复制。完全拷贝：在操作中，对于被复制对象，每一层都是对象复制。 通过下图我们来看深浅拷贝。 通过上面两个图我们可以这么认为，浅拷贝就是指针层面的赋值，指针1复制为指针2，它们指向了同一个对象；深拷贝是指针和对象的全拷贝，指针1拷贝为指针2，对象1拷贝为对象2，对象1和对象2是独立的占用不同的地址。下面我们还可以看这张我在官方文档上借用的图，也可以说明我上面写的问题。 详述深浅拷贝 在深入研究深浅拷贝之前，我们需要载体，这里我们以非可变对象（NSArray、NSString、NSDictionary）和可变对象（NSMutableArray、NSMutableString、NSMutableDictionary）以及自定义对象进行研究测试。分别研究它们的copy和mutableCopy（这里假设阅读者已经知道copy和mutableCopy了，不再赘述），并研究它们的引用计数。 一、NSString 和 NSMutableString的拷贝● ARC下的拷贝 NSString的copy和mutableCopy 12345678910111213141516 - (void)viewDidLoad &#123; [super viewDidLoad]; NSString *str = @\"虫儿不会飞\"; NSString *strCopy = [str copy]; NSMutableString *strMutableCopy = [str mutableCopy]; NSLog(@\"str---%@---%p----%@----\",str,str,[str class]); NSLog(@\"strCopy---%@---%p----%@----\",strCopy,strCopy,[strCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strMutableCopy,strMutableCopy,[strMutableCopy class]);&#125;输出结果：017-03-11 14:07:47.692 test111[5122:374020] str---虫儿不会飞---0x10b8fe078----__NSCFConstantString----2017-03-11 14:07:47.692 test111[5122:374020] strCopy---虫儿不会飞---0x10b8fe078----__NSCFConstantString----2017-03-11 14:07:47.693 test111[5122:374020] strMutableCopy---虫儿不会飞---0x60800026b540----__NSCFString---- 结论：不可变字符串NSString，它的copy出来的对象地址和原对象一样是浅拷贝，而mutableCopy后的对象地址和原对象地址不一样，是深拷贝。 NSMutableString的copy和mutableCopy12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableString *str =[NSMutableString stringWithString:@\"虫儿不会飞\"]; NSString *strCopy = [str copy]; NSMutableString *strMutableCopy = [str mutableCopy]; NSLog(@\"str---%@---%p----%@----\",str,str,[str class]); NSLog(@\"strCopy---%@---%p----%@----\",strCopy,strCopy,[strCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strMutableCopy,strMutableCopy,[strMutableCopy class]);&#125;看打印输出结果2017-03-11 23:34:22.591 test111[6244:450630] str---虫儿不会飞---0x6000000783c0----__NSCFString----2017-03-11 23:34:22.591 test111[6244:450630] strCopy---虫儿不会飞---0x60000005d370----__NSCFString----2017-03-11 23:34:22.591 test111[6244:450630] strMutableCopy---虫儿不会飞---0x6000000786c0----__NSCFString---- 结论：变字符串NSMutableString，它的copy和mutableCopy出来的对象地址和原对象地址都不是一样的，是深拷贝。 ● MRC下的拷贝 NSString的copy和mutableCopy 123456789101112131415161718192021// MRC下NSString 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSString * str = @\"虫儿不会飞\"; NSLog(@\"str--%@--%p--%lu--%@\",str,str,[str retainCount],[str class]); NSString *strCopy = [str copy]; [strCopy retain]; NSLog(@\"strCopy--%@--%p--%lu--%@\",strCopy,strCopy,[strCopy retainCount],[strCopy class]); NSMutableString *strMCopy = [str mutableCopy]; [strMCopy retain]; NSLog(@\"strMCopy--%@--%p--%lu--%@\",strMCopy,strMCopy,[strMCopy retainCount],[strMCopy class]);&#125;输出结果：2017-03-13 21:22:12.676 MRC拷贝研究[2609:156555] str--虫儿不会飞--0x106a8e050--18446744073709551615--__NSCFConstantString2017-03-13 21:22:12.676 MRC拷贝研究[2609:156555] strCopy--虫儿不会飞--0x106a8e050--18446744073709551615--__NSCFConstantString2017-03-13 21:22:12.677 MRC拷贝研究[2609:156555] strMCopy--虫儿不会飞--0x608000070a80--2--__NSCFString 结论：不可变字符串NSString，它的原对象和拷贝对象地址相同copy是浅拷贝，mutableCopy是深拷贝；引用计数，copy以后retainCount近似无穷大的数，所以不用管理它的释放，mutableCopy后的对象计数为1，retain在加1，最后为2。 NSMutableString的copy和mutableCopy 123456789101112131415161718192021222324// MRC下NSMutableString 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSString * strI = @\"虫儿不会飞\"; NSMutableString * str = [NSMutableString stringWithString:strI]; NSLog(@\"str--%@--%p--%lu--%@\",str,str,[str retainCount],[str class]); NSString *strCopy = [str copy]; [strCopy retain]; NSLog(@\"strCopy--%@--%p--%lu--%@\",strCopy,strCopy,[strCopy retainCount],[strCopy class]); NSMutableString *strMCopy = [str mutableCopy]; [strMCopy retain]; NSLog(@\"strMCopy--%@--%p--%lu--%@\",strMCopy,strMCopy,[strMCopy retainCount],[strMCopy class]); &#125;看结果2017-03-13 21:36:25.763 MRC拷贝研究[2831:176161] str--虫儿不会飞--0x600000070000--1--__NSCFString2017-03-13 21:36:25.763 MRC拷贝研究[2831:176161] strCopy--虫儿不会飞--0x608000242c70--2--__NSCFString2017-03-13 21:36:25.764 MRC拷贝研究[2831:176161] strMCopy--虫儿不会飞--0x60000006f740--2--__NSCFString 结论：可变字符串NSMutableString，它的copy和mutableCopy均是深拷贝；引用计数，copy和mutableCopy后引用计数为1，retain在加1，最后为2。 二、NSArray 和 NSMutableArray的拷贝● ARC下的拷贝 NSArray的copy和mutableCopy 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray *strArr = @[@\"111\", @\"222\"]; NSArray *strArrCopy = [strArr copy]; NSMutableArray *strArrMutableCopy = [strArr mutableCopy]; NSLog(@\"str---%@---%p----%@----\",strArr,strArr,[strArr class]); NSLog(@\"strCopy---%@---%p----%@----\",strArrCopy,strArrCopy,[strArrCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strArrMutableCopy,strArrMutableCopy,[strArrMutableCopy class]);&#125;直接看结果2017-03-11 23:46:17.145 test111[6436:467460] str---( 111, 222)---0x60800002ba80----__NSArrayI----2017-03-11 23:46:17.147 test111[6436:467460] strCopy---( 111, 222)---0x60800002ba80----__NSArrayI----2017-03-11 23:46:17.147 test111[6436:467460] strMutableCopy---( 111, 222)---0x6080002441d0----__NSArrayM---- 结论：不可变数组NSArray，它的copy所得对象地址和原对象地址相同，是浅拷贝。而mutableCopy后的对象地址和原对象地址不一样，是深拷贝。 NSMutableArray的copy和mutableCopy1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray *strArr1 = @[@\"111\", @\"222\"]; NSMutableArray *strArrM = [NSMutableArray arrayWithArray:strArr1]; NSArray *strArrMCopy = [strArrM copy]; NSMutableArray *strArrMMutableCopy = [strArrM mutableCopy]; NSLog(@\"str---%@---%p----%@----\",strArrM,strArrM,[strArrM class]); NSLog(@\"strCopy---%@---%p----%@----\",strArrMCopy,strArrMCopy,[strArrMCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strArrMMutableCopy,strArrMMutableCopy,[strArrMMutableCopy class]);&#125;直接查看结果2017-03-12 00:08:00.172 test111[6741:494893] str---( 111, 222)---0x600000056b90----__NSArrayM----2017-03-12 00:08:00.173 test111[6741:494893] strCopy---( 111, 222)---0x600000039f00----__NSArrayI----2017-03-12 00:08:00.173 test111[6741:494893] strMutableCopy---( 111, 222)---0x600000056b30----__NSArrayM---- 结论：可变数组NSMutableArray，它的copy和mutableCopy所得对象地址和原对象地址都不相同，是深拷贝。 ● MRC下的拷贝 NSArray的copy和mutableCopy1234567891011121314151617181920212223242526// MRC下NSArray 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * arrI = @[@\"lalalalala\"]; NSLog(@\"arrI--%@--%p--%lu--%@\",arrI,arrI,[arrI retainCount],[arrI class]); NSArray *arrICopy = [arrI copy]; [arrICopy retain]; NSLog(@\"arrICopy--%@--%p--%lu--%@\",arrICopy,arrICopy,[arrICopy retainCount],[arrICopy class]); NSMutableArray *arrMCopy = [arrI mutableCopy]; [arrMCopy retain]; NSLog(@\"arrMCopy--%@--%p--%lu--%@\",arrMCopy,arrMCopy,[arrMCopy retainCount],[arrMCopy class]);&#125;看结果2017-03-13 21:45:34.180 MRC拷贝研究[2999:188861] arrI--( lalalalala)--0x608000003510--1--__NSSingleObjectArrayI2017-03-13 21:45:34.181 MRC拷贝研究[2999:188861] arrICopy--( lalalalala)--0x608000003510--3--__NSSingleObjectArrayI2017-03-13 21:45:34.182 MRC拷贝研究[2999:188861] arrMCopy--( lalalalala)--0x608000048be0--2--__NSArrayM 结论：NSArray copy后为浅拷贝，mutableCopy后为深拷贝。但是需要注意，浅拷贝对象计数在原有基础上+1 ，为2，retain后再+1，为3。 2. NSMutableArray的copy和mutableCopy 12345678910111213141516171819202122232425262728// MRC下NSMutableArray 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * arrI = @[@\"lalalalala\"]; NSMutableArray *arrM = [NSMutableArray arrayWithArray:arrI]; NSLog(@\"arrI--%@--%p--%lu--%@\",arrM,arrM,[arrM retainCount],[arrM class]); NSArray *arrCopy = [arrM copy]; [arrCopy retain]; NSLog(@\"arrICopy--%@--%p--%lu--%@\",arrCopy,arrCopy,[arrCopy retainCount],[arrCopy class]); NSMutableArray *arrMCopy = [arrM mutableCopy]; [arrMCopy retain]; NSLog(@\"arrMCopy--%@--%p--%lu--%@\",arrMCopy,arrMCopy,[arrMCopy retainCount],[arrMCopy class]);&#125;看结果2017-03-13 22:10:52.515 MRC拷贝研究[3394:225252] arrI--( lalalalala)--0x600000051940--1--__NSArrayM2017-03-13 22:10:52.515 MRC拷贝研究[3394:225252] arrICopy--( lalalalala)--0x60000000d030--2--__NSSingleObjectArrayI2017-03-13 22:10:52.516 MRC拷贝研究[3394:225252] arrMCopy--( lalalalala)--0x600000051850--2--__NSArrayM 结论：可变数组NSMutableArray的copy 和 mutableCopy均为深拷贝，copy 和 mutableCopy后对象的计数为1，retain+1，为2。 三、NSDictionary 和 NSMutableDictionary的拷贝● ARC下的拷贝 1. NSDictionary的copy和mutableCopy 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary *strDict = @&#123;@\"111\":@\"222\"&#125;; NSDictionary *strDictCopy = [strDict copy]; NSMutableDictionary *strDictMutableCopy = [strDict mutableCopy]; NSLog(@\"str---%@---%p----%@----\",strDict,strDict,[strDict class]); NSLog(@\"strCopy---%@---%p----%@----\",strDictCopy,strDictCopy,[strDictCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strDictMutableCopy,strDictMutableCopy,[strDictMutableCopy class]);&#125;直接看结果2017-03-12 08:55:19.709 test111[1138:43171] str---&#123; 111 = 222;&#125;---0x608000037b00----__NSSingleEntryDictionaryI----2017-03-12 08:55:19.710 test111[1138:43171] strCopy---&#123; 111 = 222;&#125;---0x608000037b00----__NSSingleEntryDictionaryI----2017-03-12 08:55:19.710 test111[1138:43171] strMutableCopy---&#123; 111 = 222;&#125;---0x608000059740----__NSDictionaryM---- 结论：不可变字典NSDictionary，它的copy所得对象地址和原对象地址相同，是浅拷贝。而mutableCopy后的对象地址和原对象地址不一样，是深拷贝。 2. NSMutableDictionary的copy和mutableCopy 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary *strDict = @&#123;@\"111\":@\"222\"&#125;; NSMutableDictionary *strDictM = [NSMutableDictionary dictionaryWithDictionary:strDict]; NSDictionary *strDictMCopy = [strDictM copy]; NSMutableDictionary *strDictMutableCopy = [strDictM mutableCopy]; NSLog(@\"str---%@---%p----%@----\",strDictM,strDictM,[strDictM class]); NSLog(@\"strCopy---%@---%p----%@----\",strDictMCopy,strDictMCopy,[strDictMCopy class]); NSLog(@\"strMutableCopy---%@---%p----%@----\",strDictMutableCopy,strDictMutableCopy,[strDictMutableCopy class]);&#125;直接看结果2017-03-12 08:59:03.704 test111[1201:48465] str---&#123; 111 = 222;&#125;---0x60800005e870----__NSDictionaryM----2017-03-12 08:59:03.705 test111[1201:48465] strCopy---&#123; 111 = 222;&#125;---0x608000073f80----__NSDictionaryI----2017-03-12 08:59:03.705 test111[1201:48465] strMutableCopy---&#123; 111 = 222;&#125;---0x60800005e600----__NSDictionaryM---- 结论：可变字典NSMutableDictionary，它的copy和mutableCopy出来的对象地址和原对象地址都不是一样的，是深拷贝。 ● MRC下的拷贝 1. NSDictionary的copy和mutableCopy123456789101112131415161718192021222324252627// MRC下NSDictionary 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary * dictI = @&#123;@\"lalalalala\":@\"heiheiheihei\"&#125;; NSLog(@\"dictI--%@--%p--%lu--%@\",dictI,dictI,[dictI retainCount],[dictI class]); NSDictionary *dictICopy = [dictI copy]; [dictICopy retain]; NSLog(@\"dictICopy--%@--%p--%lu--%@\",dictICopy,dictICopy,[dictICopy retainCount],[dictICopy class]); NSMutableDictionary *dictMCopy = [dictI mutableCopy]; [dictMCopy retain]; NSLog(@\"dictMCopy--%@--%p--%lu--%@\",dictMCopy,dictMCopy,[dictMCopy retainCount],[dictMCopy class]);&#125;看结果2017-03-13 22:22:26.809 MRC拷贝研究[3589:242671] dictI--&#123; lalalalala = heiheiheihei;&#125;--0x60000002ac00--1--__NSSingleEntryDictionaryI2017-03-13 22:22:26.810 MRC拷贝研究[3589:242671] dictICopy--&#123; lalalalala = heiheiheihei;&#125;--0x60000002ac00--3--__NSSingleEntryDictionaryI2017-03-13 22:22:26.810 MRC拷贝研究[3589:242671] dictMCopy--&#123; lalalalala = heiheiheihei;&#125;--0x60800004e5e0--2--__NSDictionaryM 结论：NSDictionary的copy为浅拷贝，mutableCopy为深拷贝，浅拷贝后再retain，最后dictICopy的引用计数为3。 2. NSMutableDictionary的copy和mutableCopy1234567891011121314151617181920212223242526272829// MRC下NSMutableDictionary 拷贝- (void)viewDidLoad &#123; [super viewDidLoad]; NSDictionary * dict = @&#123;@\"lalalalala\":@\"heiheiheihei\"&#125;; NSMutableDictionary *dictM = [NSMutableDictionary dictionaryWithDictionary:dict]; NSLog(@\"dictM--%@--%p--%lu--%@\",dictM,dictM,[dictM retainCount],[dictM class]); NSDictionary *dictCopy = [dictM copy]; [dictCopy retain]; NSLog(@\"dictCopy--%@--%p--%lu--%@\",dictCopy,dictCopy,[dictCopy retainCount],[dictCopy class]); NSMutableDictionary *dictMCopy = [dictM mutableCopy]; [dictMCopy retain]; NSLog(@\"dictMCopy--%@--%p--%lu--%@\",dictMCopy,dictMCopy,[dictMCopy retainCount],[dictMCopy class]);&#125;看结果2017-03-13 22:36:01.475 MRC拷贝研究[3787:261783] dictM--&#123; lalalalala = heiheiheihei;&#125;--0x6000000529c0--1--__NSDictionaryM2017-03-13 22:36:01.475 MRC拷贝研究[3787:261783] dictCopy--&#123; lalalalala = heiheiheihei;&#125;--0x608000267e80--2--__NSDictionaryI2017-03-13 22:36:01.476 MRC拷贝研究[3787:261783] dictMCopy--&#123; lalalalala = heiheiheihei;&#125;--0x6000000529f0--2--__NSDictionaryM 结论：可变字典的copy和mutableCopy均为深拷贝，深拷贝后对象引用计数为1，retain后为2。 四、自定义对象的拷贝● ARC下的拷贝我们先自定义一个对象，先看这个工程框架，为了看着方便，工程名字我就用汉字了，不规范，大家不要学，这里只是为了好识别而已。 我们自定义了一个类 DDCity，下面我们看一下工程里的文件我都在里面写了什么。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475DDCity.h文件#import &lt;Foundation/Foundation.h&gt;@interface DDCity : NSObject@property (nonatomic,copy) NSString * cityName;@property (nonatomic,copy) NSString * cityLocation;@endViewController.m文件#import \"ViewController.h\"#import \"DDCity.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; DDCity *city = [[DDCity alloc] init]; city.cityName = @\"北京\"; city.cityLocation = @\"中国\"; DDCity *cityCopy = [city copy]; DDCity *cityMCopy = [city mutableCopy]; NSLog(@\"city---%@---%@\",city.cityName,city.cityLocation); NSLog(@\"cityCopy---%@---%@\",cityCopy.cityName,cityCopy.cityLocation); NSLog(@\"cityMCopy---%@---%@\",cityMCopy.cityName,cityMCopy.cityLocation); NSLog(@\"city---%@---%p---%@\",city,city,[city class]); NSLog(@\"cityCopy---%@---%p---%@\",cityCopy,cityCopy,[cityCopy class]); NSLog(@\"cityMCopy---%@---%p---%@\",cityMCopy,cityMCopy,[cityMCopy class]);&#125;运行看结果crash，看提示信息2017-03-12 10:54:44.930 自定义对象copy[2428:129638] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[DDCity copyWithZone:]: unrecognized selector sent to instance 0x6000000276e0'*** First throw call stack:( 0 CoreFoundation 0x000000010d3ffd4b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000010ce6121e objc_exception_throw + 48 2 CoreFoundation 0x000000010d46ff04 -[NSObject(NSObject) doesNotRecognizeSelector:] + 132从提示上我们看见是没有实现copyWithZone 方法，这里我们就在DDCity.m中实现对应的copyWithZone方法。在DDCity.h文件中增加协议@interface DDCity : NSObject &lt;NSCopying, NSMutableCopying&gt;在DDCity.m中实现两个协议方法- (instancetype) copyWithZone:(NSZone *)zone &#123; DDCity *city = [[DDCity allocWithZone:zone] init]; NSLog(@\"没有我copyWithZone你自定义对象就不能copy\"); return city;&#125;- (instancetype) mutableCopyWithZone:(NSZone *)zone &#123; DDCity *city = [[DDCity allocWithZone:zone] init]; NSLog(@\"没有我mutableCopyWithZone你自定义对象就不能MCopy\"); return city;&#125;viewController中的代码不动，再次运行看结果2017-03-12 11:32:52.068 自定义对象copy[3039:180702] 没有我copyWithZone你自定义对象就不能copy2017-03-12 11:32:52.068 自定义对象copy[3039:180702] 没有我mutableCopyWithZone你自定义对象就不能MCopy2017-03-12 11:32:52.069 自定义对象copy[3039:180702] city---北京---中国2017-03-12 11:32:52.069 自定义对象copy[3039:180702] cityCopy---(null)---(null)2017-03-12 11:32:52.069 自定义对象copy[3039:180702] cityMCopy---(null)---(null)2017-03-12 11:32:52.070 自定义对象copy[3039:180702] city---&lt;DDCity: 0x600000037020&gt;---0x600000037020---DDCity2017-03-12 11:32:52.070 自定义对象copy[3039:180702] cityCopy---&lt;DDCity: 0x600000037080&gt;---0x600000037080---DDCity2017-03-12 11:32:52.071 自定义对象copy[3039:180702] cityMCopy---&lt;DDCity: 0x6000000370a0&gt;---0x6000000370a0---DDCity 结论：1）自定义对象copy和mutableCopy后的对象地址都不一样，均为深拷贝。2）拷贝后的对象属性cityName和cityLocation均为null，也就是说属性并未拷贝，我们再次改进DDCity.m中的代码。 1234567891011121314151617181920212223242526272829- (instancetype) copyWithZone:(NSZone *)zone &#123; DDCity *city = [[DDCity allocWithZone:zone] init]; //新增下面两行代码 city.cityName = self.cityName; city.cityLocation = self.cityLocation; NSLog(@\"没有我copyWithZone你自定义对象就不能copy\"); return city;&#125;- (instancetype) mutableCopyWithZone:(NSZone *)zone &#123; DDCity *city = [[DDCity allocWithZone:zone] init]; //新增下面两行代码 city.cityName = self.cityName; city.cityLocation = self.cityLocation; NSLog(@\"没有我mutableCopyWithZone你自定义对象就不能MCopy\"); return city;&#125;查看结果2017-03-12 11:49:20.900 自定义对象copy[3304:202108] 没有我copyWithZone你自定义对象就不能copy2017-03-12 11:49:20.901 自定义对象copy[3304:202108] 没有我mutableCopyWithZone你自定义对象就不能MCopy2017-03-12 11:49:20.902 自定义对象copy[3304:202108] city---北京---中国2017-03-12 11:49:20.902 自定义对象copy[3304:202108] cityCopy---北京---中国2017-03-12 11:49:20.902 自定义对象copy[3304:202108] cityMCopy---北京---中国2017-03-12 11:49:20.903 自定义对象copy[3304:202108] city---&lt;DDCity: 0x608000036d60&gt;---0x608000036d60---DDCity2017-03-12 11:49:20.903 自定义对象copy[3304:202108] cityCopy---&lt;DDCity: 0x608000036da0&gt;---0x608000036da0---DDCity2017-03-12 11:49:20.904 自定义对象copy[3304:202108] cityMCopy---&lt;DDCity: 0x600000037560&gt;---0x600000037560---DDCity 结论：通过增加对属性的赋值，新拷贝的对象就拥有了原对象的属性值。 ● MRC下的拷贝 123456789101112131415161718192021222324252627282930313233343536373839- (void)viewDidLoad &#123; [super viewDidLoad]; DDCity *city = [[DDCity alloc] init]; city.cityName = @\"北京\"; city.cityLocation = @\"中国\"; DDCity *cityCopy = [city copy]; [cityCopy retain]; DDCity *cityMCopy = [city mutableCopy]; [cityMCopy retain]; NSLog(@\"city---%@---%@\",city.cityName,city.cityLocation); NSLog(@\"cityCopy---%@---%@\",cityCopy.cityName,cityCopy.cityLocation); NSLog(@\"cityMCopy---%@---%@\",cityMCopy.cityName,cityMCopy.cityLocation); NSLog(@\"city---%@---%p---%@\",city,city,[city class]); NSLog(@\"cityCopy---%@---%p---%@\",cityCopy,cityCopy,[cityCopy class]); NSLog(@\"cityMCopy---%@---%p---%@\",cityMCopy,cityMCopy,[cityMCopy class]); NSLog(@\"city--%lu---%lu---%lu\",city.retainCount,cityCopy.retainCount,cityMCopy.retainCount); NSLog(@\"city--%lu---%lu---%lu\",city.cityName.retainCount,cityCopy.cityName.retainCount,cityMCopy.cityName.retainCount); NSLog(@\"city--%lu---%lu---%lu\",city.cityLocation.retainCount,cityCopy.cityLocation.retainCount,cityMCopy.cityLocation.retainCount);&#125;查看结果2017-03-13 23:08:28.179 自定义对象copy[4284:303058] 没有我copyWithZone你自定义对象就不能copy2017-03-13 23:08:28.180 自定义对象copy[4284:303058] 没有我mutableCopyWithZone你自定义对象就不能MCopy2017-03-13 23:08:28.180 自定义对象copy[4284:303058] city---北京---中国2017-03-13 23:08:28.180 自定义对象copy[4284:303058] cityCopy---北京---中国2017-03-13 23:08:28.181 自定义对象copy[4284:303058] cityMCopy---北京---中国2017-03-13 23:08:28.181 自定义对象copy[4284:303058] city---&lt;DDCity: 0x60000002ab00&gt;---0x60000002ab00---DDCity2017-03-13 23:08:28.182 自定义对象copy[4284:303058] cityCopy---&lt;DDCity: 0x60000002ab60&gt;---0x60000002ab60---DDCity2017-03-13 23:08:28.182 自定义对象copy[4284:303058] cityMCopy---&lt;DDCity: 0x608000028ec0&gt;---0x608000028ec0---DDCity2017-03-13 23:08:28.182 自定义对象copy[4284:303058] city--1---2---22017-03-13 23:08:28.183 自定义对象copy[4284:303058] city--18446744073709551615---18446744073709551615---184467440737095516152017-03-13 23:08:28.183 自定义对象copy[4284:303058] city--18446744073709551615---18446744073709551615---18446744073709551615 结论：copy和mutableCopy均为深拷贝，拷贝后引用计数为1，retain后再+1，为2。 五、一些需要注意的点理解深拷贝和完全拷贝 深复制，就是把原有对象内容直接克隆一份新的对象，但是这里有一个坑，就是深复制只是复制一层对象，而不是复制第二层或者更深层的对象。可能说的有点不好理解，下面看这个例子。1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableString *strM1 = [NSMutableString stringWithString:@\"1\"]; NSMutableString *strM2 = [NSMutableString stringWithString:@\"2\"]; NSMutableArray *arrM1 = [NSMutableArray arrayWithObjects:strM1,strM2, nil]; NSMutableString *strM3 = [arrM1 objectAtIndex:0]; [strM3 appendString:@\"1\"]; NSMutableArray *arrM2 = [arrM1 mutableCopy]; NSLog(@\"strM1--%@\",arrM1); NSLog(@\"strM2--%@\",arrM2);&#125;看结果2017-03-14 00:22:02.260 深复制和完全复制[5522:393850] strM1--( 11, 2)2017-03-14 00:22:02.261 深复制和完全复制[5522:393850] strM2--( 11, 2) 结果：大家可能会想，为什么深拷贝已经复制了对象，那么原对象为什么也跟着变？这里就是深拷贝和完全拷贝的原因，深拷贝只是拷贝了一层数组，但是里面的字符串没有拷贝，两个数组都是用的同一个地址的字符串，所以改变一个，原对象也发生了变化。可以做下面这样的修改。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950NSMutableArray *arrM2 = [[NSMutableArray alloc] initWithArray:arrM1 copyItems:YES];查看结果2017-03-14 00:45:45.389 深复制和完全复制[5916:425450] arrM1--( 11, 2)2017-03-14 00:45:45.390 深复制和完全复制[5916:425450] arrM2--( 1, 2)***可以利用这个方法，得到的是多一层的深复制，里面的字符串地址也进行了复制，所以改变strM3的值，不影响arrM1的值。你认为这样就解决了吗?在看下面的问题。***- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableString *strM1 = [NSMutableString stringWithString:@\"1\"]; NSMutableString *strM2 = [NSMutableString stringWithString:@\"2\"]; NSMutableArray *arrM1 = [NSMutableArray arrayWithObjects:strM1,strM2, nil]; NSMutableArray *arrM2 = [NSMutableArray arrayWithObjects:strM1,strM2,arrM1, nil]; NSMutableArray *arrM3 = [[NSMutableArray alloc] initWithArray:arrM2 copyItems:YES]; NSMutableString *strM3 = [arrM1 objectAtIndex:0]; [strM3 appendString:@\"1\"]; NSLog(@\"arrM2--%@\",arrM2); NSLog(@\"arrM3--%@\",arrM3);&#125;查看结果2017-03-14 00:55:57.604 深复制和完全复制[6080:438490] arrM2--( 11, 2, ( 11, 2 ))2017-03-14 00:55:57.606 深复制和完全复制[6080:438490] arrM3--( 1, 2, ( 11, 2 )) 结论：看这个结果，可以发现外层的深复制了，原对象和拷贝后的对象不是同一地址，再往里看一层都变化了，就没有深复制，也就是说在增加一层，NSMutableArray *arrM2 = [[NSMutableArray alloc] initWithArray:arrM1 copyItems:YES];这个方法不能管那么多层数了。采用归档和解档可以解决这个问题。 1234567891011121314151617181920NSMutableArray *arrM3 = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:arrM2]];查看结果2017-03-14 01:17:23.204 深复制和完全复制[6396:464958] arrM2--( 11, 2, ( 11, 2 ))2017-03-14 01:17:23.204 深复制和完全复制[6396:464958] arrM3--( 1, 2, ( 1, 2 )) 结论：可以看到实现了完全复制，就没有层数的限制了。 理解字符串NSString的copy和strong的不同 NSString被copy和strong修饰有什么不同，不多说废话，直接上代码了。 123456789101112131415161718192021222324252627#import \"ViewController.h\"@interface ViewController ()@property (nonatomic,copy) NSString *str;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableString *strM = [[NSMutableString alloc] initWithString:@\"bestDay\"]; self.str = strM; [strM appendString:@\"OfThisYear\"]; NSLog(@\"str----%@---%p\",self.str,self.str); NSLog(@\"strM----%@---%p\",strM,strM);&#125;@end直接查看结果2017-03-14 08:53:01.874 strong修饰不同[789:18128] str----bestDay---0xa7961447473656272017-03-14 08:53:01.875 strong修饰不同[789:18128] strM----bestDayOfThisYear---0x600000071280 结论：可以看到copy修饰的str，在赋值以后，可变字符串strM发生了变化并不会影响str的值。从打印结果来看是因为二者不是一个地址，所以不会相互影响。为什么？是因为copy修饰的属性setter方法，走的是先release旧值，copy新值再赋值给成员变量，不可变copy是深拷贝，就是内容拷贝，地址变化了。不理解的可以看我的另外一篇文章ios属性修饰符的作用。接着看strong修饰的情况。 12345@property (nonatomic,strong) NSString *str;直接查看结果2017-03-14 09:03:36.756 strong修饰不同[968:29890] str----bestDayOfThisYear---0x6000002600c02017-03-14 09:03:36.757 strong修饰不同[968:29890] strM----bestDayOfThisYear---0x6000002600c0 结论：被strong修饰以后只是强指针引用，并未改变地址，所以str的值会随着strM进行变化，二者的地址也是相同的。 理解copy和retain的不同 在MRC下进行测试，先看代码1234567891011121314151617181920212223242526//copy和retain的区别- (void)viewDidLoad &#123; [super viewDidLoad]; NSMutableArray *arrM = [NSMutableArray arrayWithObjects:@\"111\",@\"222\",@\"333\", nil]; NSMutableArray *arrMRetain = [arrM retain]; NSMutableArray *arrMCopy = [arrM copy]; [arrM removeLastObject]; NSLog(@\"arrMCopy--%@--%p--%lu\",arrMCopy,arrMCopy,[arrMCopy retainCount]); NSLog(@\"arrMRetain--%@--%p--%lu\",arrMRetain,arrMRetain,[arrMRetain retainCount]); &#125;查看结果2017-03-14 20:16:59.895 copy和retain的区别[2816:177901] arrMCopy--( 111, 222, 333)--0x60000005cf80--12017-03-14 20:16:59.895 copy和retain的区别[2816:177901] arrMRetain--( 111, 222)--0x60000005cf50--2 结论：copy是深复制，retainCount为1，retain是浅复制，retain是使原来对象引用计数加1，所以arrM和arrMRetain是同一地址，所以remove最后一个元素，arrMRetain也跟着变化了。 总结通过上面的分析，大家可以记住两点： 原对象和拷贝对象都是不可变对象时，为浅拷贝。其他情况均为深拷贝。具体如下表所示。 转载作者：刀客传奇链接：https://www.jianshu.com/p/4e5fde48fcda來源：简书","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"浅析KVO原理以及自己完成简单的KVO代码实现","slug":"浅析KVO原理以及自己完成简单的KVO代码实现","date":"2017-01-16T03:44:23.000Z","updated":"2018-04-11T09:46:25.000Z","comments":true,"path":"2017/01/16/浅析KVO原理以及自己完成简单的KVO代码实现/","link":"","permalink":"http://www.niu-chao.top/2017/01/16/浅析KVO原理以及自己完成简单的KVO代码实现/","excerpt":"","text":"KVO KVO 是 Objective-C 对观察者设计模式的一种实现。【另外一种是：通知机制（notification）】；KVO 提供一种机制，指定一个被观察对象(例如 A 类)，当对象某个属性(例如 A 中的字符串 name)发生更改时，对象会获得通知，并作出相应处理；【且不需要给被观察的对象添加任何额外代码，就能使用 KVO 机制】 在 MVC 设计架构下的项目，KVO 机制很适合实现 mode 模型和 view 视图之间的通讯。例如：代码中，在模型类A创建属性数据，在控制器中创建观察者，一旦属性数据发生改变就收到观察者收到通知，通过 KVO 再在控制器使用回调方法处理实现视图 B 的更新； 实现原理KVO 在 Apple 中的 API 文档如下： 1234 Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … KVO 的实现依赖于 Objective-C 强大的 Runtime，从以上 Apple 的文档可以看出苹果对于 KVO 机制的实现是一笔带过，而具体的细节没有过多的描述，关于KVO 机制的底层实现原理，从网上的一些关于 KVO 的资料总结了有关的内容： 基本原理 1、KVO是基于runtime机制实现的 2、当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3、如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4、每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法 5、键值观察通知依赖于NSObject 的两个方法:willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 深度剖析 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；） 1、NSKVONotifying_A 类剖析：在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被 KVO 机制修改为指向系统新创建的子类 NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。（备注：isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。这也是 KVO 回调机制，为什么都俗称KVO技术为黑魔法的原因之一吧：内部神秘、外观简洁。 2、子类setter方法剖析：KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用 2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后，observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 相关特点 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @&quot;newName&quot;，这时是不会触发 KVO 机制，更加不会调用回调方法的。所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。 代码实现代码由ViewController（观察者）、NSObject+NCKVO（KVO实现）、NCperson（被观察者）、Dog（扩展类），几个类组成，分为五项代码线流程进行演示； ViewController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899.h#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@end.m#import \"ViewController.h\"#import \"NCperson.h\"#import \"NSObject+NCKVO.h\"#import &lt;objc/message.h&gt;/**拓展 NSKeyValueObservingOptionNew 返回新值 NSKeyValueObservingOptionOld 返回旧值 NSKeyValueObservingOptionInitial 注册的时候就会发一次通知，改变后也会发通知 NSKeyValueObservingOptionPrior 改变之前发一次，改变之后发一次 *//** 打印出的kind = 1 表示的为set方法 */@interface ViewController ()@property (nonatomic, strong) NCperson *p;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NCperson *person = [[NCperson alloc] init];// 一.系统方法添加观察者// [person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// [person addObserver:self forKeyPath:@\"dog.age\" options:NSKeyValueObservingOptionNew context:nil];// 三.观察内部属性(容器)dog类中的多个属性// [person addObserver:self forKeyPath:@\"dog\" options:NSKeyValueObservingOptionNew context:nil];// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// [person addObserver:self forKeyPath:@\"code\" options:NSKeyValueObservingOptionNew context:nil];// ********* 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加 [person NC_addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; _p = person;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; //五.传过来的object为子类（派生类），不知道正确不正确 NSLog(@\"成功通知到了新值：%@\",change);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static int a = 0;// 一.手动添加KVO (观察者类中关闭自动模式)，实现手动观察方法 will did ；// [_p willChangeValueForKey:@\"name\"];// _p.name = [NSString stringWithFormat:@\"%d\", a++];// [_p didChangeValueForKey:@\"name\"];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// _p.dog.age = a++;// 三.观察内部属性(容器)dog类中的多个属性 ，KVO的本质是观察set方法，需结合KVC去实现// _p.dog.age = a++;// _p.dog.height = a++;// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// _p-&gt;code = [NSString stringWithFormat:@\"%d\",a++]; // -&gt; 访问成员变量// 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// _p.name = [NSString stringWithFormat:@\"%d\",a++]; objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]); NSLog(@\"修改了%@\",_p.name);&#125;@end NSObject+NCKVO (头部拓展可忽略)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137NSObject+NCKVO.h#import &lt;Foundation/Foundation.h&gt;@interface NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;@endNSObject+NCKVO.m#import \"NSObject+NCKVO.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;/*拓展 方法、成员变量、类、对象 Class typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif &#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： // 成员变量列表 struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif variable length structurestruct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif variable length structure struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125;由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。*//*拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） 添加子类的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； */#define force_inline __inline__ __attribute__((always_inline))// 未用@implementation NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; //1.动态的创建一个派生类：NSKVONotifying_NCperson； NSString *oldClassName = NSStringFromClass(self.class); NSString *newClassName = [@\"NCKVO_\" stringByAppendingString:oldClassName]; //运行时创建类 Class myClass = objc_allocateClassPair(self.class, [newClassName UTF8String], 0); //注册类 objc_registerClassPair(myClass); //2.动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类 object_setClass(self, myClass);// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； /***** 拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） */ //oc方法 SEL IMP 第四个参数：添加这个方法它的方法类型 //当第三个参数IMP有参数的情况下需要强转 //第四个参数type\"v@:\" 变成\"v@:@\",其中v表示void，@表示对象参数，：表示sel，@还是表示对象参数，可在开发文档中查询 class_addMethod(myClass, @selector(setName:), (IMP)impSetName, \"v@:@\"); //4.将观察者保存到当前的对象当中,当前例子中观察者应该是ViewController objc_setAssociatedObject(self,\"observer\",observer,OBJC_ASSOCIATION_ASSIGN);&#125;//OC中方法的调用里面有两个隐藏的参数！！！ 1、id self 2、SEL _cmd//objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]);//***要想获得第三个参数的值必须在参数列表中补齐 id self,SEL _cmdvoid impSetName(id self,SEL _cmd,NSString *name)&#123; id class = [self class]; //修改子类与父类的isa object_setClass(self, class_getSuperclass([self class])); //给父类发送消息，让他拿到newName的值 objc_msgSend(self, @selector(setName:),name); //再修改回来子类与父类的isa object_setClass(self, class); NSLog(@\"父类拿到了新值：%@\",name); //取出观察者,当前例子中观察者应该是ViewController id observer = objc_getAssociatedObject(self, \"observer\"); //给观察者发送消息，并发送change值，当前传过去的self为子类（派生类） NSDictionary *change = [NSDictionary dictionaryWithObjectsAndKeys:@\"1\",@\"kind\",name,@\"new\", nil]; objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:),@\"name\",self,change,nil);&#125;@end NCperson1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 NCperson.h#import &lt;Foundation/Foundation.h&gt;#import \"Dog.h\"@interface NCperson : NSObject&#123; @public NSString *code; //类的属性实质是是成员变量、set、get方法的封装，而KVO实际上是对Set方法的观察&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) Dog *dog;@property (nonatomic, strong) NSMutableArray *mArray;@endNCperson.m#import \"NCperson.h\"@implementation NCperson- (instancetype)init&#123; if (self = [super init]) &#123; _dog = [[Dog alloc] init]; _mArray = NSMutableArray.array; &#125; return self;&#125;//三.返回一个容器，里面是字符串类型！ key：被观察的key字符串//+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;//// NSLog(@\"%@\",key);//// NSSet *set = [super keyPathsForValuesAffectingValueForKey:key];// if ([key isEqualToString:@\"dog\"]) &#123;// NSArray *array = @[@\"_dog.age\",@\"_dog.height\"];// set = [set setByAddingObjectsFromArray:array];// &#125;// return set;//&#125;//一.默认为自动通知模式的KVO；这将其关闭，实现手动KVO//+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;//// return NO;//&#125;@end Dog1234567891011121314151617181920Dog.h#import &lt;Foundation/Foundation.h&gt;@interface Dog : NSObject@property (nonatomic ,assign) int age;@property (nonatomic ,assign) int height;@endDog.m#import \"Dog.h\"@implementation Dog@end 以上就是代码的实现，很简单，盼指点！！！","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"GCD队列相关","slug":"GCD队列相关","date":"2016-12-21T07:34:18.000Z","updated":"2018-04-11T10:57:28.000Z","comments":true,"path":"2016/12/21/GCD队列相关/","link":"","permalink":"http://www.niu-chao.top/2016/12/21/GCD队列相关/","excerpt":"","text":"dispatch_queue_t 要申明一个dispatch的属性。一般情况下我们只需要用strong即可。 12@property (nonatomic, strong) dispatch_queue_t queue; 如果你是写一个framework，framework的使用者的SDK有可能还是古董级的iOS6之前。那么你需要根据OS_OBJECT_USE_OBJC做一个判断是使用strong还是assign。（一般github上的优秀第三方库都会这么做） 12345#if OS_OBJECT_USE_OBJC @property (nonatomic, strong) dispatch_queue_t queue;#else @property (nonatomic, assign) dispatch_queue_t queue;#endif AsyncGCD中有2个异步的API: 123void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);//接受block作为参数void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);//接受函数作为参数 他们都是将一个任务提交到queue中，提交之后立即返回(在之前本博客其他文章中试验过立即返回造成崩溃的例子)，不等待任务的的执行。提交之后，系统会对queue做retain操作，任务执行完成之后，queue再被release。两个函数实际的功能是一样的，唯一的区别在于dispatch_async接受block作为参数，dispatch_async_f接受函数。 使用dispatch_async的时候block会被copy，在block执行完成之后block再release，由于是系统持有block，所以不用担心循环引用的问题，block里面的self不需要weak 在dispatch_async_f中，context会作为第一个参数传给work函数。如果work不需要参数，context可以传入NULL。work参数不能传入NULL，否则可能发生无法预料的事儿 1234567NSLog(@\"这是主线前面：创建一个串行队列前\");dispatch_queue_t globalQueue = dispatch_queue_create(\"com.liancheng.global_queue\", DISPATCH_QUEUE_SERIAL);dispatch_async(globalQueue, ^&#123; // task&#125;);NSLog(@\"这是主线程后面\"); 上段代码执行步骤: 1、先在main queue中执行第一个nslog 2、dispatch_async会将block提交到globalQueue中，提交成功之后立即返回 3、main queue执行第二个nslog 4、等global queue中block前面的任务执行完成之后，block被执行。 Sync与异步相似，GCD中同步的API也是2个12 12void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work); 2个API作用相同：将任务提交到queue中，任务加入queue之后不会立即返回，等待任务执行完成之后再返回。同Async类似，dispatch_sync与dispatch_sync_f唯一的区别在于dispatch_sync接收block作为参数，block被系统持有，不需要对self使用weak。dispatch_sync_f接受函数work作为参数，context作为传给work函数的第一个参数。同样，work参数也不能传入NULL，否则会发生无法预料的事儿 同步表示任务加入到队列中之后不会立即返回，等待任务完成再返回。语言的描述比较抽象，我们再次用代码加深一下对概念的理解 1234567NSLog(@\"这是主线前面：创建一个串行队列前\");dispatch_queue_t globalQueue = dispatch_queue_create(\"com.liancheng.global_queue\", DISPATCH_QUEUE_SERIAL); dispatch_sync(globalQueue, ^&#123; NSLog(@\"dispatch_sync执行中\"); &#125;);NSLog(@\"这是主线程后面\"); 我们来看看代码的运行方式： 1、先在main queue中执行第一个nslog 2、dispatch_sync会将block提交到global queue中，等待block的执行 3、global queue中block前面的任务执行完成之后，block执行 4、block执行完成之后，dispatch_sync返回 5、dispatch_sync之后的代码执行 1234567891011121314151617NSLog(@\"这是主线前面：创建一个串行队列qian\");dispatch_queue_t globalQueue = dispatch_queue_create(\"com.liancheng.global_queue\", DISPATCH_QUEUE_SERIAL);dispatch_async(globalQueue, ^&#123;//如果将全部就是连同下面的globalQueue换成dispatch_get_main_queue()执行效果是一样的因为dispatch_get_main_queue()就是主线程的串行队列 NSLog(@\"dispatch_sync执行前\"); dispatch_sync(globalQueue(), ^&#123;//只将这里的队列globalQueue换成其他队列不会造成死锁 NSLog(@\"dispatch_sync执行中\"); &#125;); NSLog(@\"dispatch_sync执行后，将要执行完async—-block\");&#125;);NSLog(@\"这是主线程后面\");打印结果GCD深究[34268:6758027] 这是主线前面：创建一个串行队列qianGCD深究[34268:6758027] 这是主线程后面GCD深究[34268:6758866] dispatch_sync执行前后面因为死锁奔溃 dispatch_sync需要等待block执行完成，同时由于队列串行，block的执行需要等待前面的任务，也就是dispatch_sync执行完成。两者互相等待，永远也不会执行完成，死锁就这样发生了从这里看发生死锁需要2个条件： 代码运行的当前队列是串行队列使用sync将任务加入到自己队列中 如果queue是并行队列，或者将任务加入到其他队列中，这是不会发生死锁的。 或者如果将队列分为两个队列去执行，如下面的代码，不会造成死锁123456789101112131415161718NSLog(@\"这是主线前面：创建一个串行队列qian\");dispatch_queue_t globalQueue = dispatch_queue_create(\"com.liancheng.global_queue\", DISPATCH_QUEUE_SERIAL);dispatch_async(globalQueue, ^&#123;//如果将全部就是连同下面的globalQueue换成dispatch_get_main_queue()执行效果是一样的因为dispatch_get_main_queue()就是主线程的串行队列 NSLog(@\"dispatch_sync执行前\"); dispatch_sync(dispatch_get_main_queue(), ^&#123;//只将这里的队列globalQueue换成其他队列不会造成死锁 NSLog(@\"dispatch_sync执行中\"); &#125;); NSLog(@\"dispatch_sync执行后，将要执行完async—-block\");&#125;);NSLog(@\"这是主线程后面\");打印结果：GCD深究[34499:6789064] 这是主线前面：创建一个串行队列qianGCD深究[34499:6789064] 这是主线程后面GCD深究[34499:6789565] dispatch_sync执行前GCD深究[34499:6789064] dispatch_sync执行中GCD深究[34499:6789565] dispatch_sync执行后，将要执行完async—-block 队列优先级dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);dispatch_get_global_queue方法获取的全局队列都是并行队列，并且队列不能被修改，也就是说对全局队列调用dispatch_suspend(), dispatch_resume(), dispatch_set_context()等方法无效 identifier: 用以标识队列优先级，推荐用qos_class枚举作为参数，也可以使用dispatch_queue_priority_tflags: 预留字段，传入任何非0的值都可能导致返回NULL可以看到dispatch_get_global_queue根据identifier参数返回相应的全局队列。identifier推荐使用qos_class枚举 1234567891011121314__QOS_ENUM(qos_class, unsigned int, QOS_CLASS_USER_INTERACTIVE __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x21, QOS_CLASS_USER_INITIATED __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x19, QOS_CLASS_DEFAULT __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x15, QOS_CLASS_UTILITY __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x11, QOS_CLASS_BACKGROUND __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x09, QOS_CLASS_UNSPECIFIED __QOS_CLASS_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_8_0) = 0x00, ); 这个枚举与NSThread中的NSQualityOfService类似 1234567891011121314151617181920QOS_CLASS_USER_INTERACTIVE: 最高优先级，交互级别。使用这个优先级会占用几乎所有的系统CUP和I/O带宽，仅限用于交互的UI操作，比如处理点击事件，绘制图像到屏幕上，动画等QOS_CLASS_USER_INITIATED: 次高优先级，用于执行类似初始化等需要立即返回的事件QOS_CLASS_DEFAULT: 默认优先级，当没有设置优先级的时候，线程默认优先级。一般情况下用的都是这个优先级QOS_CLASS_UTILITY: 普通优先级，主要用于不需要立即返回的任务QOS_CLASS_BACKGROUND: 后台优先级，用于用户几乎不感知的任务。QOS_CLASS_UNSPECIFIED: 未知优先级，表示服务质量信息缺失identifier除了使用qos_class枚举，也可以用dispatch_queue_priority_t作为参数。#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MINtypedef long dispatch_queue_priority_t;dispatch_queue_priority_t对应到qos_class枚举有：- DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED- DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT- DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY- DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND很多时候我们喜欢将0或者NULL传入作为参数 dispatch_get_global_queue(NULL, NULL)由于NULL等于0，也就是DISPATCH_QUEUE_PRIORITY_DEFAULT，所以返回的是默认优先级 队列的创建相关1dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr); 如果未使用ARC，dispatch_queue_create创建的queue在使用结束之后需要调用dispatch_release。 label: 队列的名称，调试的时候可以区分其他的队列attr: 队列的属性，dispatch_queue_attr_t类型。用以标识队列串行，并行，以及优先级等信息 attr参数有三种传值方式：123456781、 串行#define DISPATCH_QUEUE_SERIAL NULL// 2、并行#define DISPATCH_QUEUE_CONCURRENT \\DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, \\_dispatch_queue_attr_concurrent)3、自定义属性值dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority); DISPATCH_QUEUE_SERIAL或者NULL，表示创建串行队列，优先级为目标队列优先级。DISPATCH_QUEUE_CONCURRENT表示创建并行队列，优先级也为目标队列优先级。dispatch_queue_attr_make_with_qos_class函数可以创建带有优先级的dispatch_queue_attr_t对象。通过这个对象可以自定义queue的优先级。 attr: 传入DISPATCH_QUEUE_SERIAL、NULL或者DISPATCH_QUEUE_CONCURRENT，表示串行或者并行；qos_class: 传入qos_class枚举，表示优先级级别relative_priority: 相对于qos_class的相对优先级，qos_class用于区分大的优先级级别，relative_priority表示大级别下的小级别。relative_priority必须大于QOS_MIN_RELATIVE_PRIORITY小于0，否则将返回NULL。从GCD源码中可以查到QOS_MIN_RELATIVE_PRIORITY等于-15 使用dispatch_queue_attr_make_with_qos_class创建队列时，需要注意，非法的参数可能导致dispatch_queue_attr_make_with_qos_class返回NULL，dispatch_queue_create传入NULL会创建出串行队列。写代码过程中需要确保这是否是预期的结果. 设置目标队列 除了通过dispatch_queue_attr_make_with_qos_class设置队列的优先级之外，也可以使用设置目标队列的方法，设置队列的优先级。当队列创建时未设置优先级，队列将继承目标队列的优先级。（不过一般情况下还是推荐使用dispatch_queue_attr_make_with_qos_class设置队列的优先级）1void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue); 调用dispatch_set_target_queue会retain新目标队列queue，release原有目标队列。设置目标队列之后，block将会在目标队列中执行。注意：当目标队列串行时，任何在目标队列中执行的block都会串行执行，无论原队列是否串行 假设有队列A、B是并行队列，C为串行队列。A,B的目标队列均设置为C，那么A、B、C中的block在设置目标队列之后最终都会串行执行:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 例： 队列1并行，队列2串行 dispatch_queue_t queue1 = dispatch_queue_create(\"com.company.queue1\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(\"com.company.queue2\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue1, ^&#123; // block1 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block1\"); &#125; &#125;); dispatch_async(queue1, ^&#123; // block2 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block2\"); &#125; &#125;); dispatch_async(queue2, ^&#123; // block3 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block3\"); &#125; &#125;); 运行一下可知block1,block2,block3并行执行 GCD深究[35074:6898162] block2 GCD深究[35074:6898163] block1 GCD深究[35074:6898164] block3 GCD深究[35074:6898162] block2 GCD深究[35074:6898163] block1 GCD深究[35074:6898164] block3 GCD深究[35074:6898162] block2 GCD深究[35074:6898163] block1 GCD深究[35074:6898164] block3如果将队列1的目标队列设置为队列2，会发生什么情况呢？ dispatch_queue_t queue1 = dispatch_queue_create(\"com.company.queue1\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t queue2 = dispatch_queue_create(\"com.company.queue2\", DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(queue1, queue2); dispatch_async(queue1, ^&#123; // block1 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block1\"); &#125; &#125;); dispatch_async(queue1, ^&#123; // block2 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block2\"); &#125; &#125;); dispatch_async(queue2, ^&#123; // block3 for (int i = 0; i &lt; 3; i ++) &#123; NSLog(@\"block3\"); &#125; &#125;); block1，block2，block3变为了串行 GCD深究[35131:6905431] block1 GCD深究[35131:6905431] block1 GCD深究[35131:6905431] block1 GCD深究[35131:6905431] block2 GCD深究[35131:6905431] block2 GCD深究[35131:6905431] block2 GCD深究[35131:6905431] block3 GCD深究[35131:6905431] block3 GCD深究[35131:6905431] block3 注意不要循环设置目标队列，如A的目标队列为B，B的目标队列为A。这将会导致无法预知的错误","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"GCD队列与同/异步执行 & NSOperationQueue","slug":"GCD队列与同:异步执行 & NSOperationQueue","date":"2016-12-14T06:38:05.000Z","updated":"2018-04-10T13:13:54.000Z","comments":true,"path":"2016/12/14/GCD队列与同:异步执行 & NSOperationQueue/","link":"","permalink":"http://www.niu-chao.top/2016/12/14/GCD队列与同:异步执行 & NSOperationQueue/","excerpt":"","text":"同步-异步 串行-并行同步异步、并行串行的区分同步异步：是指任务添加到线程上这个过程的同步和异步串行并行：是指任务在线程上运行的串行和并行 使用block，invocation或者是dispatch_function_t(C函数)添加任务，任务中都是需要执行return返回的，同步异步就是指是否和这个return同步，如果是同步添加到线程上的任务，把任务添加到线程上的添加操作本身会等到任务中的return执行之后才执行自己的return。如果是异步添加到线程上的任务，添加任务操作本身执行后会立即返回，并不会等待任务完成后自己才返回,例如如下这个bug: 建了一个线程(串行：并行串行不关紧要，只有一个任务，都是串行),声明一个数组指针 p 传给sumAB函数，添加到线程上，结果崩溃了BAD_ACCESS，原因如下：dispatch_async_f执行的是异步把任务添加到线程中，添加完成后立刻就返回了，这个时候任务还没执行，等到任务执行的时候viewDidLoad函数已经执行完,p 指针已经被释放了,就引起了BAD_ACCESS。然后我们将dispatch_async_f改为dispatch_sync_f ——结果正常运行 关于这句话(dispatch_async_f执行的是异步把任务添加到线程中，添加完成后立刻就返回了)可以查看官方文档dispatch解释:Submits an application-defined functionfor asynchronous execution on a dispatch queue and returns immediately; 另外：如果一定要异步添加到线程上，需要保证p只能不被释放掉，使用__bridge_retain和__bridge_transfer关键字转交所有权，P指针指向对象的所有权会转交到sumAB的object手中，直到sumAB执行完之前该对象都不会被释放。 12345678910111213141516171819 - (void)dispatch_async_fTest&#123; dispatch_queue_t queue = dispatch_queue_create(\"Serial\", DISPATCH_QUEUE_SERIAL); NSArray * array = [[NSArray alloc] initWithObjects:@\"niuchao\",nil];// void * p = (__bridge void*) array;//桥接将OC对象转为C指针 void * p = (__bridge_retained void*)array;//retain dispatch_async_f(queue, p, sumAB);//异步把任务添加到线程// dispatch_sync_f(queue, p, sumAB);//同步把任务添加到线程,修改这里 将async改成sync;&#125;void sumAB(void* input)&#123;// id object = (__bridge id )input;//桥接将C指针转为OC对象 id object = (__bridge_transfer id)input;//transfer [NSThread sleepForTimeInterval:3]; NSLog(@\"%@\", object); NSLog(@\"线程结束\");&#125; 串·并队列 与 异.同执行方式的搭配主队列：系统为我们创建好的一个串行队列，牛逼之处在于它管理必须在主线程中执行的任务，属于有劳保的。全局队列：系统为我们创建好的一个并行队列，使用起来与我们自己创建的并行队列无本质差别。 上面说了系统自带的两个队列，下面我们来用自己创建的队列研究一下各种搭配情况。我们先创建两个队列，并且测试方法都是在主线程中调用：//串行队列self.serialQueue = dispatch_queue_create(&quot;serialQueue.ys.com&quot;, DISPATCH_QUEUE_SERIAL);//并行队列self.concurrentQueue = dispatch_queue_create(&quot;concurrentQueue.ys.com&quot;, DISPATCH_QUEUE_CONCURRENT); (一)串行队列 + 同步执行123456789101112131415161718192021 dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"4========%@\",[NSThread currentThread]); &#125;);打印结果:[6735:1064390] 1========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 2========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 3========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 4========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125; 全部都在当前线程顺序执行，也就是说，同步执行不具备开辟新线程的能力。 (二)串行队列 + 异步执行12345678910111213141516171819 dispatch_async(self.serialQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); &#125;); dispatch_async(self.serialQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); &#125;); dispatch_async(self.serialQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[6774:1073235] 4========&lt;NSThread: 0x60800006e9c0&gt;&#123;number = 1, name = main&#125;[6774:1073290] 1========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125;[6774:1073290] 2========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125;[6774:1073290] 3========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125; 先打印了4，然后顺序在子线程中打印1，2，3。说明异步执行具有开辟新线程的能力，并且串行队列必须等到前一个任务执行完才能开始执行下一个任务，同时，异步执行会使内部函数率先返回，不会与正在执行的外部函数发生死锁。 (三)并行队列 + 同步执行12345678910111213141516171819 dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[7012:1113594] 1========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 2========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 3========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 4========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125; 未开启新的线程执行任务，并且Block函数执行完成后dispatch函数才会返回，才能继续向下执行，所以我们看到的结果是顺序打印的。 (四)并行队列 + 异步执行12345678910111213141516171819 dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[7042:1117492] 1========&lt;NSThread: 0x600000071900&gt;&#123;number = 3, name = (null)&#125;[7042:1117491] 3========&lt;NSThread: 0x608000070240&gt;&#123;number = 5, name = (null)&#125;[7042:1117451] 4========&lt;NSThread: 0x600000067400&gt;&#123;number = 1, name = main&#125;[7042:1117494] 2========&lt;NSThread: 0x600000071880&gt;&#123;number = 4, name = (null)&#125; 开辟了多个线程，触发任务的时机是顺序的，但是我们看到完成任务的时间却是随机的，这取决于CPU对于不同线程的调度分配，但是，线程不是无条件无限开辟的，当任务量足够大时，线程是会重复利用的。 ⚠️重点⚠️: 想要开辟新线程必须让任务在异步执行，想要开辟多个线程，只有让任务在并行队列中异步执行才可以。执行方式和队列类型多层组合在一定程度上能够实现对于代码执行顺序的调度。同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 对于单核CPU来说，不存在真正意义上的并行，所以，多线程执行任务，其实也只是一个人在干活，CPU的调度决定了非等待任务的执行速率，同时对于非等待任务，多线程并没有真正意义提高效率。 线程可以简单的认为就是一段代码+运行时数据。 同步执行会在当前线程执行任务，不具备开辟线程的能力或者说没有必要开辟新的线程。并且，同步执行必须等到Block函数执行完毕，dispatch函数才会返回，从而阻塞同一串行队列中外部方法的执行。 异步执行dispatch函数会直接返回，Block函数我们可以认为它会在下一帧加入队列，并根据所在队列目前的任务情况无限下一帧执行，从而不会阻塞当前外部任务的执行。只有异步执行才有开辟新线程的必要，但是异步执行不一定会开辟新线程。 只要是队列，肯定是FIFO（先进先出），但是谁先执行完要看第1条。 只要是串行队列，肯定要等上一个任务执行完成，才能开始下一个任务。但是并行队列当上一个任务开始执行后，下一个任务就可以开始执行。 想要开辟新线程必须让任务在异步执行，想要开辟多个线程，只有让任务在并行队列中异步执行才可以。执行方式和队列类型多层组合在一定程度上能够实现对于代码执行顺序的调度。 同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 对于多核CPU来说，线程数量也不能无限开辟，线程的开辟同样会消耗资源，过多线程同时处理任务并不是你想像中的人多力量大。 GCD APIdispatch_after 该函数用于任务延时执行，其中参数dispatch_time_t代表延时时长，dispatch_queue_t代表使用哪个队列。如果队列未主队列，那么任务在主线程执行，如果队列为全局队列或者自己创建的队列，那么任务在子线程执行，代码如下: 1234567891011121314151617181920 //主队列延时 dispatch_time_t when_main = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)); dispatch_after(when_main, dispatch_get_main_queue(), ^&#123; NSLog(@\"main_%@\",[NSThread currentThread]); &#125;); //全局队列延时 dispatch_time_t when_global = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4.0 * NSEC_PER_SEC)); dispatch_after(when_global, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"global_%@\",[NSThread currentThread]); &#125;); //自定义队列延时 dispatch_time_t when_custom = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)); dispatch_after(when_custom, self.serialQueue, ^&#123; NSLog(@\"custom_%@\",[NSThread currentThread]); &#125;);打印结果:[1508:499647] main_&lt;NSThread: 0x60000007cf40&gt;&#123;number = 1, name = main&#125;[1508:499697] global_&lt;NSThread: 0x608000262d80&gt;&#123;number = 3, name = (null)&#125;[1508:499697] custom_&lt;NSThread: 0x608000262d80&gt;&#123;number = 3, name = (null)&#125; dispatch_once 保证函数在整个生命周期内只会执行一次，看代码: 123456789-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"无论如何点击只执行一次once:%@\",[NSThread currentThread]); &#125;);&#125;打印结果:[1524:509261]无论如何点击只执行一次once: &lt;NSThread: 0x600000262940&gt;&#123;number = 1, name = main&#125; 这里的dispatch_once_t必须是静态的。也就是要有APP一样长的生存期来保证这段时间内task只被执行一次。如果不是static的，那么只被执行一次是保证不了的。dispatch_once方法在这里执行，onceToken在这里有一个取地址的操作。也就是onceToken把地址传入方法内部被初始化和赋值。 dispatch_group_async &amp; dispatch_group_notify GCD有一个神器的东西叫做队列组，当加入到队列组中的所有任务执行完成之后，会调用dispatch_group_notify函数通知任务全部完成，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 dispatch_group_t group = dispatch_group_create(); __block NSString *A; __block NSString *B; __block NSString *C; dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"1========开始%@\",[NSThread currentThread]); sleep(1); A = @\"I\"; NSLog(@\"1========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"2========开始%@\",[NSThread currentThread]); sleep(1); B = @\"Love\"; NSLog(@\"2========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"3========开始%@\",[NSThread currentThread]); sleep(1); C = @\"You\"; NSLog(@\"3========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; for (int i = 10; i &gt;= 1; i--) &#123; NSLog(@\"%d\",i); [NSThread sleepForTimeInterval:1.0]; &#125; NSString *love = [@\"牛超--\"stringByAppendingFormat:@\"%@-%@-%@ \",A,B,C]; NSLog(@\"%@\",love); &#125;);打印结果:GCD[31406:6418787] 2========开始&lt;NSThread: 0x60000007cdc0&gt;&#123;number = 4, name = (null)&#125;GCD[31406:6418785] 3========开始&lt;NSThread: 0x604000466200&gt;&#123;number = 5, name = (null)&#125;GCD[31406:6418803] 1========开始&lt;NSThread: 0x604000466140&gt;&#123;number = 3, name = (null)&#125;GCD[31406:6418787] 2========结束&lt;NSThread: 0x60000007cdc0&gt;&#123;number = 4, name = (null)&#125;GCD[31406:6418785] 3========结束&lt;NSThread: 0x604000466200&gt;&#123;number = 5, name = (null)&#125;GCD[31406:6418803] 1========结束&lt;NSThread: 0x604000466140&gt;&#123;number = 3, name = (null)&#125;GCD[31406:6418643] 10 ....GCD[31406:6418643] 1GCD[31406:6418643] 牛超--I-Love-You 打印结果这里再次验证:异步执行+并行队列(global_queue就是一个全局的并行队列) 会开辟多个线程. 那我们用串行队列试一试呢?1234567891011GCD[31509:6433454] 1========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 1========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 2========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 2========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 3========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 3========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433023] 10 ....GCD[31509:6433023] 1GCD[31509:6433023] 牛超--I-Love-You 打印结果: 再次验证了异步执行+串行队列 会新开辟一条新线程，串行执行任务 dispatch_barrier_async 栅栏函数 栅栏函数，此方法创建的任务，会查找当前队列中有没有其他任务要执行，如果有，则等待已有任务执行完毕后再执行，同时，在此任务之后进入队列的任务，需要等待此任务执行完成后，才能执行。看代码 这里异步执行并行队列 123456789101112131415161718192021222324252627282930313233343536 dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"1========%@\",[NSThread currentThread]);&#125;);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"2========%@\",[NSThread currentThread]);&#125;);dispatch_barrier_sync(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"barrier========%@\",[NSThread currentThread]);&#125;);NSLog(@\"代码位置在barrier任务之后========%@\",[NSThread currentThread]);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"3========%@\",[NSThread currentThread]);&#125;);NSLog(@\"任务3之后========%@\",[NSThread currentThread]);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"4========%@\",[NSThread currentThread]);&#125;);打印结果:GCD[32294:6533209] 代码位置在barrier任务之后========&lt;NSThread: 0x600000069880&gt;&#123;number = 1, name = main&#125;GCD[32294:6533209] 任务3之后========&lt;NSThread: 0x600000069880&gt;&#123;number = 1, name = main&#125;GCD[32294:6533334] 1========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125;GCD[32294:6533337] 2========&lt;NSThread: 0x600000274a80&gt;&#123;number = 4, name = (null)&#125;GCD[32294:6533334] barrier========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125;GCD[32294:6533337] 4========&lt;NSThread: 0x600000274a80&gt;&#123;number = 4, name = (null)&#125;GCD[32294:6533334] 3========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125; 因为在任务中加入了耗时操作,所以主线程先执行完.而且1,2,barrier,3,4任务,都同为异步执行+同步队列,是不是也和咱们之前说的规则吻合:会开辟多个线程,并且并行执行任务(任务结束前后顺序随机); 那么我们将dispatch_barrier_async异步换成dispatch_barrier_sync同步,会有什么样的效果呢????? 12345678打印结果:GCD[32439:6550892] 2========&lt;NSThread: 0x604000277bc0&gt;&#123;number = 4, name = (null)&#125;GCD[32439:6550894] 1========&lt;NSThread: 0x600000263580&gt;&#123;number = 3, name = (null)&#125;GCD[32439:6550537] barrier========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550537] 代码位置在barrier任务之后========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550537] 任务3之后========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550892] 3========&lt;NSThread: 0x604000277bc0&gt;&#123;number = 4, name = (null)&#125;GCD[32439:6550902] 4========&lt;NSThread: 0x604000272680&gt;&#123;number = 5, name = (null)&#125; barrier变成了主线程,想一想和咱们之前的规则是不是吻合,同步执行一个并行队列:不会开辟新线程,在主线程上串行执行任务;但依然是先执行完并行队列中再barrier之前加入的任务;再去执行再barrier之后加入的任务而且1,2,3,4任务,为异步执行+同步队列,是不是也和咱们之前说的规则吻合:会开辟多个线程,并且并行执行任务(任务结束前后顺序随机); dispatch_apply该函数用于重复执行某个任务，如果任务队列是并行队列，重复执行的任务会并发执行，如果任务队列为串行队列，则任务会顺序执行，需要注意的是，该函数为同步函数，要防止线程阻塞和死锁! 12345678910111213141516171819 //重复执行 dispatch_apply(5, self.serialQueue, ^(size_t i) &#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]); &#125;);打印结果: GCD[33023:6656397] 第0次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第1次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第2次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第3次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第4次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; 如果将其换成并行队列呢??打印结果: GCD[33123:6672667] 第3次_&lt;NSThread: 0x60400027cf00&gt;&#123;number = 4, name = (null)&#125; GCD[33123:6672668] 第2次_&lt;NSThread: 0x600000270040&gt;&#123;number = 5, name = (null)&#125; GCD[33123:6672669] 第1次_&lt;NSThread: 0x60000026ff00&gt;&#123;number = 3, name = (null)&#125; GCD[33123:6672525] 第0次_&lt;NSThread: 0x60000006fd80&gt;&#123;number = 1, name = main&#125; GCD[33123:6672668] 第4次_&lt;NSThread: 0x600000270040&gt;&#123;number = 5, name = (null)&#125; 12345该方法会造成死锁dispatch_apply(5, dispatch_get_main_queue(), ^(size_t i) &#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]);&#125;); 该函数用于重复执行某个任务，如果任务队列是并行队列，重复执行的任务会并发执行，如果任务队列为串行队列，则任务会顺序执行，需要注意的是，该函数为同步函数，要防止线程阻塞和死锁!!!!dispatch_apply 如果是一个同步执行的话,那就与之前的规律不吻合,暂时还不知道为什么?? 官方文档的解释:该函数将一个应用程序定义的函数提交给调度队列以进行多个调用，并在返回之前等待该函数的所有迭代完成。如果目标队列是返回的并发队列dispatch_get_global_queue，则该功能可以同时调用，因此它必须是可重入安全的。在并发队列中使用此函数可以作为有效的并行for循环很有用。迭代的当前索引被传递给函数的每个调用。 dispatch_semaphore GCD信号量 看这几个函数的时候你需要抛开队列，丢掉同步异步，不要把它们想到一起，混为一谈，信号量只是控制任务执行的一个条件而已，相对于上面通过队列以及执行方式来控制线程的开辟和任务的执行，它更贴近对于任务直接的控制。类似于单个队列的最大并发数的控制机制，提高并行效率的同时，也防止太多线程的开辟对CPU早层负面的效率负担。dispatch_semaphore_create创建信号量，初始值不能小于0；dispatch_semaphore_wait等待降低信号量，也就是信号量-1；dispatch_semaphore_signal提高信号量，也就是信号量+1；dispatch_semaphore_wait和dispatch_semaphore_signal通常配对使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i=0; i&lt;5; i++) &#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); &#125;将dispatch_semaphore_t代码注释掉看看出现什么效果 GCD[33996:6868522] 第2次_&lt;NSThread: 0x60400046ac00&gt;&#123;number = 5, name = (null)&#125; GCD[33996:6868525] 第1次_&lt;NSThread: 0x600000069a40&gt;&#123;number = 4, name = (null)&#125; GCD[33996:6868521] 第0次_&lt;NSThread: 0x600000069a00&gt;&#123;number = 3, name = (null)&#125; GCD[33996:6868524] 第3次_&lt;NSThread: 0x600000069b00&gt;&#123;number = 6, name = (null)&#125; GCD[33996:6868571] 第4次_&lt;NSThread: 0x60400046ad40&gt;&#123;number = 7, name = (null)&#125;将dispatch_semaphore_t代码打开看看出现什么效果 GCD[34054:6874836] 第0次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第1次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第2次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第3次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第4次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; - (void)dispatch_semaphore_tDemo&#123; //###通过dispatch_semaphore_t控制最大并发线程数量 dispatch_queue_t conturrent = dispatch_queue_create(\"concurrent\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t serial = dispatch_queue_create(\"serial\", DISPATCH_QUEUE_SERIAL); dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); for (int i= 0; i&lt; 10 ; i++) &#123; dispatch_async(serial, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); //信号量-1 dispatch_async(conturrent, ^&#123; NSLog(@\"thread-info:%@开始执行任务%d\",[NSThread currentThread],(int)i); sleep(1); NSLog(@\"thread-info:%@结束执行任务%d\",[NSThread currentThread],(int)i); dispatch_semaphore_signal(semaphore); //信号量+1 &#125;); &#125;); &#125;&#125; 信号量是控制任务执行的重要条件，当信号量为0时，所有任务等待，信号量越大，允许可并行执行的任务数量越多。 NSOperation &amp;&amp; NSOperationQueueNSOperation 它提供了关于任务的执行，取消，以及随时获取任务的状态，添加任务依赖以及优先级等方法和属性，相对于GCD提供的方法来说，更直观，更方便，并且提供了更多的控制接口。（很多时候，苹果设计的架构是很棒的，不要只是在乎他实现了什么，可能你学到的东西会更多），有几个方法和属性我们了解一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface NSOperation : NSObject &#123;@private id _private; int32_t _private1;#if __LP64__ int32_t _private1b;#endif&#125;- (void)start;//启动任务 默认在当前线程执行- (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。@property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读- (void)cancel;//取消任务@property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读@property (readonly, getter=isFinished) BOOL finished;//执行结束，只读@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读@property (readonly, getter=isReady) BOOL ready;//准备执行- (void)addDependency:(NSOperation *)op;//添加依赖- (void)removeDependency:(NSOperation *)op;//移除依赖@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;;//系统提供的优先级关系枚举@property NSOperationQueuePriority queuePriority;//执行优先级@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称@end NSOperation本身是个抽象类，不能直接使用，我们有三种方式赋予它新的生命，就是下面这三个东西: 1.NSOperation自定义子类这是我要说的第一个任务类型，我们可以自定义继承于NSOperation的子类，并重写父类提供的方法;2.NSBlockOperation第二个就是系统提供的NSOperation的子类NSBlockOperation，我们看一下他提供的API： 123456789101112@interface NSBlockOperation : NSOperation &#123;@private id _private2; void *_reserved2;&#125;+ (instancetype)blockOperationWithBlock:(void (^)(void))block;- (void)addExecutionBlock:(void (^)(void))block;@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;@end 123456789-(void)NSBlockOperationRun&#123; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_%@_%@\",[NSOperationQueue currentQueue],[NSThread currentThread]); &#125;]; [blockOper start];&#125;打印结果:[4313:1121900] NSBlockOperationRun_&lt;NSOperationQueue: 0x608000037420&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;_&lt;NSThread: 0x60000006dd80&gt;&#123;number = 1, name = main&#125; 我们发现这个任务是在当前线程顺序执行的，我们发现还有一个方法addExecutionBlock:试一下：1234567891011121314151617181920-(void)NSBlockOperationRun&#123; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_1_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_2_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_3_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_4_%@\",[NSThread currentThread]); &#125;]; [blockOper start];打印结果:[4516:1169835] NSBlockOperationRun_1_&lt;NSThread: 0x60000006d880&gt;&#123;number = 1, name = main&#125;[4516:1169875] NSBlockOperationRun_3_&lt;NSThread: 0x600000070800&gt;&#123;number = 4, name = (null)&#125;[4516:1169877] NSBlockOperationRun_4_&lt;NSThread: 0x6080000762c0&gt;&#123;number = 5, name = (null)&#125;[4516:1169893] NSBlockOperationRun_2_&lt;NSThread: 0x608000076100&gt;&#123;number = 3, name = (null)&#125; 从打印结果来看，这个4个任务是异步并发执行的，开辟了多条线程。 3.NSInvocationOperation第三个同样也是系统提供给我们的一个任务类，基于一个target对象以及一个selector来创建任务，具体代码：12345678910-(void)NSInvocationOperationRun&#123; NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; [invocationOper start];&#125;-(void)invocationOperSel&#123; NSLog(@\"NSInvocationOperationRun_%@\",[NSThread currentThread]);&#125;运行结果：[4538:1173118] NSInvocationOperationRun_&lt;NSThread: 0x60800006e900&gt;&#123;number = 1, name = main&#125; 运行结果与NSBlockOperation单个block函数的执行方式相同，同步顺序执行。的确系统的封装给予我们关于任务更直观的东西，但是对于多个任务的控制机制并不完善，所以我们有请下一位，也许你会眼前一亮。 NSOperationQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; queue.maxConcurrentOperationCount = 1;// NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];// [queue addOperation:invocationOper];// invocationOper.queuePriority = NSOperationQueuePriorityVeryLow; NSBlockOperation *blockOper1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun____1%@\",[NSThread currentThread]); &#125;]; blockOper1.queuePriority = NSOperationQueuePriorityVeryLow;// [queue addOperation:blockOper1]; NSBlockOperation *blockOper2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____2%@\",[NSThread currentThread]); &#125;]; blockOper2.queuePriority = NSOperationQueuePriorityLow;// [queue addOperation:blockOper2]; NSBlockOperation *blockOper3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____3%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper3]; NSBlockOperation *blockOper4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____4%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper4]; NSBlockOperation *blockOper5 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____5%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper5]; blockOper1.queuePriority=NSOperationQueuePriorityVeryLow; blockOper2.queuePriority=NSOperationQueuePriorityLow; blockOper3.queuePriority=NSOperationQueuePriorityNormal; blockOper4.queuePriority=NSOperationQueuePriorityHigh; blockOper5.queuePriority=NSOperationQueuePriorityVeryHigh; NSArray *aray = @[blockOper1,blockOper2,blockOper3,blockOper4,blockOper5]; [queue addOperations:aray waitUntilFinished:NO];// 加入队列之后不用调用任务的start方法，队列会帮你管理任务的执行情况。// 上诉执行结果开辟多条线程,说明这些任务在队列中为并发执行的。****下面我们改变一下任务的优先级*** 打印结果:未添加queue.maxConcurrentOperationCount = 1时,优先级添加无效果,随机执行!!!! GCD[43375:9146881] NSBlockOperationRun_____5&lt;NSThread: 0x600000273a80&gt;&#123;number = 5, name = (null)&#125; GCD[43375:9146878] NSBlockOperationRun____1&lt;NSThread: 0x604000469b00&gt;&#123;number = 7, name = (null)&#125; GCD[43375:9147158] NSBlockOperationRun_____3&lt;NSThread: 0x604000469600&gt;&#123;number = 3, name = (null)&#125; GCD[43375:9146880] NSBlockOperationRun_____4&lt;NSThread: 0x604000469ac0&gt;&#123;number = 6, name = (null)&#125; GCD[43375:9146877] NSBlockOperationRun_____2&lt;NSThread: 0x600000273940&gt;&#123;number = 4, name = (null)&#125; 打印结果:添加queue.maxConcurrentOperationCount = 1时,优先级有效果!!! 开辟了三个小城 GCD[43441:9153871] NSBlockOperationRun_____5&lt;NSThread: 0x6000004769c0&gt;&#123;number = 3, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____4&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____3&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____2&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153870] NSBlockOperationRun____1&lt;NSThread: 0x60400027a780&gt;&#123;number = 5, name = (null)&#125; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; queue.maxConcurrentOperationCount = 1; // NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; // [queue addOperation:invocationOper]; // invocationOper.queuePriority = NSOperationQueuePriorityVeryLow; NSBlockOperation *blockOper1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun____1%@\",[NSThread currentThread]); &#125;]; blockOper1.queuePriority = NSOperationQueuePriorityVeryLow; [queue addOperation:blockOper1]; NSBlockOperation *blockOper2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____2%@\",[NSThread currentThread]); &#125;]; blockOper2.queuePriority = NSOperationQueuePriorityLow; [queue addOperation:blockOper2]; NSBlockOperation *blockOper3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____3%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper3]; NSBlockOperation *blockOper4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____4%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper4]; NSBlockOperation *blockOper5 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____5%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper5]; blockOper1.queuePriority=NSOperationQueuePriorityVeryLow; blockOper2.queuePriority=NSOperationQueuePriorityLow; blockOper3.queuePriority=NSOperationQueuePriorityNormal; blockOper4.queuePriority=NSOperationQueuePriorityHigh; blockOper5.queuePriority=NSOperationQueuePriorityVeryHigh; // NSArray *aray = @[blockOper1,blockOper2,blockOper3,blockOper4,blockOper5]; [queue addOperations:aray waitUntilFinished:NO]; ** 而且如果测试的各个线程不是按数组直接添加话的,而是逐个添加的,优先级也是没有效果的!!! (逐个添加任务到队列 + 没有添加queue.maxConcurrentOperationCount = 1) 打印结果:-------结果完全随机,开辟多个线程 GCD[43634:9173255] NSBlockOperationRun____1&lt;NSThread: 0x604000269940&gt;&#123;number = 4, name = (null)&#125; GCD[43634:9173257] NSBlockOperationRun_____4&lt;NSThread: 0x6000002769c0&gt;&#123;number = 5, name = (null)&#125; GCD[43634:9173258] NSBlockOperationRun_____3&lt;NSThread: 0x604000269a00&gt;&#123;number = 3, name = (null)&#125; GCD[43634:9173261] NSBlockOperationRun_____5&lt;NSThread: 0x600000276a80&gt;&#123;number = 7, name = (null)&#125; GCD[43634:9173256] NSBlockOperationRun_____2&lt;NSThread: 0x600000276a00&gt;&#123;number = 6, name = (null)&#125; (逐个添加任务到队列 + 添加了queue.maxConcurrentOperationCount = 1) 打印结果:-------打印多次依然是这个结果,优先级未完全出现效果,开辟两个线程 GCD[43700:9180313] NSBlockOperationRun____1&lt;NSThread: 0x604000270d00&gt;&#123;number = 3, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____5&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____4&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____3&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180313] NSBlockOperationRun_____2&lt;NSThread: 0x604000270d00&gt;&#123;number = 3, name = (null)&#125;- (void)invocationOperSel&#123; NSLog(@\"NSInvocationOperationRun_%@\",[NSThread currentThread]);&#125; 总结:NSOperationQueue在没指定最大并发数的情况下默认是0，无限的，意思就是能开多少子线程就开多少子线程，所以MAX&gt;5的情况下，就是1-5随机排列，这种情况下优先级顺序不生效，因为能力太强不用考虑谁优先，大家都优先，都优先就随机.发现优先级低的任务会后执行，但是，这并不是绝对的，还有很多东西可以左右CPU分配，以及操作系统对于任务和线程的控制，只能说，优先级会在一定程度上让优先级高的任务开始执行。同时，优先级只对同一队列中的任务有效哦。 下面我们就再再再看一个会忽视优先级的情况。添加依赖之后，依赖任务必须等待被依赖任务执行完毕之后才会开始执行。就算依赖任务的优先级再高，也是被依赖任务先执行，同时，和优先级不同，依赖关系不受队列的局限，爱哪哪，只要是我依赖于你，那你必须先执行完，我才执行。 1234567891011121314151617NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 1000; i++) &#123; NSLog(@\"blockOper_1_%@_%@\",@(i),[NSThread currentThread]); &#125;&#125;];NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 1000; i++) &#123; NSLog(@\"blockOper_2_%@_%@\",@(i),[NSThread currentThread]); &#125;&#125;];[blockOper_1 addDependency:blockOper_2];[queue addOperation:blockOper_1];[queue addOperation:blockOper_2]; 队列的最大并发数 就是说，这个队列最多可以有多少任务同时执行，或者说最多开辟多少条线程，如果设置为1，那就一次只能执行一个任务，但是，不要以为这和GCD的串行队列一样，就算最大并发数为1，队列任务的执行顺序依然取决于很多因素。 关于NSOperationQueue还有取消啊，暂停啊等操作方式，大家可以试一下，应该注意的是，和学习GCD的方式不同，不要总是站在面向过程的角度看带这些面向对象的类，因为它的面相对象化的封装过程中，肯定有很多你看不到的面相过程的操作，所以你也没有必要用使用GCD的思想来套用它，否则你可能会迷糊的一塌糊涂。 取消线程：[operation cancel]; 取消队列中的所有线程:[operationQueue cancelAllOperations]; 挂起：[queue setSuspended:YES]; 恢复：[queue setSuspended:NO]; 等待某个操作:[operation waitUntilFinished];//注意：千万不要在主线程中执行这个 等待queue中的操作都完成:[queue waitUntilAllOperationsAreFinished];","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"利用Runtime解决NSArray越界等问题","slug":"利用Runtime解决NSArray越界等问题","date":"2016-10-08T08:23:48.000Z","updated":"2018-03-20T08:21:43.000Z","comments":true,"path":"2016/10/08/利用Runtime解决NSArray越界等问题/","link":"","permalink":"http://www.niu-chao.top/2016/10/08/利用Runtime解决NSArray越界等问题/","excerpt":"","text":"runtime 是 OC底层的一套C语言的API（引入 &lt;objc/runtime.h&gt; 或&lt;objc/message.h&gt;），编译器最终都会将OC代码转化为运行时代码，通过终端命令编译.m 文件： clang -rewrite-objc xxx.m 可以看到编译后的xxx.cpp（C++文件）。 比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象.cpp 文件 删除掉一些强制转换语句，可以看到调用方法本质就是发消息，[[NSObject alloc]init] 语句发了两次消息，第一次发了alloc 消息，第二次发送init 消息。利用这个功能我们可以探究底层，比如block的实现原理。 需要注意的是，使用 objc_msgSend() sel_registerName()方法需要导入头文件&lt;objc/message.h&gt; 利用Runtime解决NSArray和NSMutableArray数组越界的crash问题废话不多说，直接上代码，其实是很小的功能！！！首先给NSArray创建一个类别，Xcode -&gt; File -&gt; New -&gt; -&gt;File,然后在弹出的视图中选择 source目录下的 Objective-C file 选项，可以直接创建Empty FIle，Category，Protocol和Extension类型的文件，我们选择创建Category(类别文件)，class选择NSArray，名称填写为NSArray+Safe。 .h文件123456789101112#import &lt;Foundation/Foundation.h&gt;/** * 解决NSArray和NSMutableArray数组越界的crash问题，当debug模式下会crash报错方便调试，release模式下会返回nil */@interface NSArray (Safe)@end@interface NSMutableArray (Safe)@end .m文件在.m文件下import 运行文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#import \"NSArray+Safe.h\"#import &lt;objc/runtime.h&gt;@implementation NSArray (Safe)//这个方法无论如何都会执行，而且是最开始执行+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayI\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end@implementation NSMutableArray (SafetyArray)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayM\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end 解析以上代码逻辑主要是在最开始执行的load方法中，通过method_exchangeImplementations 函数去交换函数指针（OC中的方法实际上就是C的函数）IMP。 dispatch_once这里不是“单例”，是保证方法替换只执行一次. load 方法是可以当做类方法主动调用的,为的是避免这种情况.（在我的理解中load方法是被import了以后就会被调用）NSObject的load和initialize方法 方法替换”这种使用情况下,发现有两种写法. 其实也不是两种写法,准确的来说一种是比较严谨的,另一种则没有那么严谨. 发现这两种写法的差异后,我主要集中在下列: class_addMethodclass_replaceMethodmethod_exchangeImplementations 利用Runtime设置字体方法(方法替换的另一种写法—-严谨的写法).h文件12345@interface UIFont(Swizzle)+(void)load;@end .m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import \"UIfont+Swizzle.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation UIFont(Swizzle)+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [UIFont swizzleMethodOrginalMtd:@selector(systemFontOfSize:) newMtd:@selector(myFontOfSize:)]; [UIFont swizzleMethodOrginalMtd:@selector(boldSystemFontOfSize:) newMtd:@selector(myboldFontOfSize:)]; &#125;);&#125;+ (BOOL)swizzleMethodOrginalMtd:(SEL)origSelector newMtd:(SEL)altSelector&#123; Method origMethod = class_getClassMethod([self class], origSelector); if (nil == origMethod) &#123; return NO; &#125; Method altMethod = class_getClassMethod([self class], altSelector); if (nil == altMethod) &#123; return NO; &#125; BOOL didAddMethod = class_addMethod([self class], origSelector, method_getImplementation(altMethod), method_getTypeEncoding(altMethod)); if (didAddMethod) &#123; class_replaceMethod([self class], altSelector, method_getImplementation(origMethod), method_getTypeEncoding(origMethod)); &#125; else &#123; method_exchangeImplementations(origMethod, altMethod); &#125; return YES;&#125;+ (UIFont *)myFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName: @\"Avenir-Light\" size:fontSize];&#125;+ (UIFont *)myboldFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName:@\"Avenir-Medium\" size:fontSize];&#125; 说明:class_addMethod:如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现 1.如果返回成功:则说明被替换方法没有存在.也就是被替换的方法没有被实现,我们需要先把这个方法实现,然后再执行我们想要的效果,用我们自定义的方法去替换被替换的方法. 这里使用到的是class_replaceMethod 这个方法. class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了) 2.如果返回失败:则说明被替换方法已经存在.直接将两个方法的实现交换即可 另外: 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP我们可以利用 class_replaceMethod 来修改类我们可以利用 method_setImplementation 来直接设置某个方法的IMP 其实我们如果 研究过 AFN 代码的话,会发现, AFN 就是第二种写法.在AFURLSessionManager.m的第296行: 123456789static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; Runtime运行时添加属性，或者block属性知识点 key：要保证全局唯一，key与关联的对象是一一对应关系。必须全局唯一。通常用@selector(methodName)作为key。value：要关联的对象。policy：关联策略。有五种关联策略。OBJC_ASSOCIATION_ASSIGN 等价于 @property(assign)。OBJC_ASSOCIATION_RETAIN_NONATOMIC等价于 @property(strong, nonatomic)。OBJC_ASSOCIATION_COPY_NONATOMIC等价于@property(copy, nonatomic)。OBJC_ASSOCIATION_RETAIN等价于@property(strong,atomic)。OBJC_ASSOCIATION_COPY等价于@property(copy, atomic)。 .h123456789#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(id sender);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m1234567891011121314151617181920212223#import \"UIButton+Block.h\"#import &lt;objc/runtime.h&gt;@implementation UIButton (Block)- (void)handelWithBlock:(btnBlock)block &#123; if (block) &#123; objc_setAssociatedObject(self,@selector(btnAction:) , block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction:(id)sender&#123; btnBlock block = objc_getAssociatedObject(self,@selector(btnAction:)); if (block) &#123; block(sender); &#125;&#125;@end 注意：@selector(btnAction:) 部分是第二个参数 ;类型通常都是通常都是会采用静态变量static const char btnKey 来作为关键字 &amp;btnkey ,也可以使用”@selector(btnAction:) “。 第二个参数进一步优化，出现了_cmd 代替了 &amp;btnKey 或者 @selector(methodName). 因为： _cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例. 这里强调当前，_cmd的作用域只在当前方法里，直指当前方法名@selector。** Runtime 动态添加方法 OC的方法有哪几部分组成,在我的博客中反复强调的. SEL:方法编号 IMP:方法实现 (指向一个函数的指针) Class 源码可以查看objc_method_list方法定义的链表 本质是一个有 objc_method元素的可变长度的数组。一个 objc_method 结构体中有SEL，表示函数类型的字符串以及函数的实现IMP objc_method_list就好比一本书,SEL是标题,IMP是页码,真正的内容就是IMP指针指向的区域; struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !OBJC2 Class _Nullable super_class OBJC2_UNAVAILABLE; const char _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list _Nullable ivars OBJC2_UNAVAILABLE; //该类的成员变量链表 struct objc_method_list _Nullable _Nullable methodLists OBJC2_UNAVAILABLE; //方法定义的链表 struct objc_cache _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list _Nullable protocols OBJC2_UNAVAILABLE; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject- (void)eatWith:(NSString *)food;@end@implementation Person//记住:这个是动态添加一个类方法+ (BOOL)resolveClassMethod:(SEL)sel&#123;// 动态添加eat方法,IMP再有参数的情况下需要强转(IMP) class_addMethod(self, sel, (IMP)eat, \"v@:@\"); return [super resolveClassMethod:sel];&#125;//记住:这个是动态添加一个实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; // 动态添加eat方法,IMP再有参数的情况下需要强转(IMP) class_addMethod(self, sel, (IMP)eat, \"v@:@\"); return [super resolveInstanceMethod:sel];&#125;////OC中方法的调用里面有两个隐藏的参数！！！ 1、id self 2、SEL _cmd//***要想获得第三个参数的值必须在参数列表中补齐 id self,SEL _cmdvoid eat(id self,SEL _cmd, NSString *food)&#123; NSLog(@\"我今天吃了%@,倍儿开心!!!\",food);&#125;@end#import \"ViewController.h\"#import \"Person.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; [p eatWith:@\"火烧\"];&#125;","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://www.niu-chao.top/tags/Runtime/"}]},{"title":"Block与链式编程","slug":"Block与链式编程","date":"2016-09-21T06:12:57.000Z","updated":"2018-03-23T10:28:30.000Z","comments":true,"path":"2016/09/21/Block与链式编程/","link":"","permalink":"http://www.niu-chao.top/2016/09/21/Block与链式编程/","excerpt":"","text":"Block关于block代码块格式省略的小问题! 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; //block? 直接打块代码:inlinBlock,会在block实现中省略返回类型 id(^blockA)(void) = ^id(void) &#123; NSLog(@\"这一个BlockA\"); //return @\"......\"; return nil;//在block实现中因为省略了返回类型,所以返回一个nil会直接报错,要在实现中加上: ^id(void)&#123;&#125; 这段代码中的返回类型:id &#125;; NSLog(@\"%@\",blockA());&#125; Block应用场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 //1.对象的属性!示例 - (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc]init]; _p.eat = ^()&#123;//这个是实现 NSLog(@\"这是一个对象中的Block!!!\"); &#125;; //_p.eat();//block应用场景1:调用对象的属性block &#125; //2.方法的参数!示例 - (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc] init]; [_p eat:^&#123; NSLog(@\"吃火烧\"); &#125;]; //在这个思考一下使用block回调的与使用代理有什么区别呢?? //Block:1.解耦性强 2.如果封装的好,对于P对象是没有什么影响的; //代理:1.需要设置代理 2.遵守p对象的协议 3.在下面实现代理方法(需要脱离这个函数体) &#125;//编程思想: 响应式--函数式--链式//AFN网络回调 ---响应式 : 代理 通知 KVO//思考一下网络回调用代理怎么做呢?以下为思考过程//设置代理 AFNetworking.delegate = self;//遵守协议//需要的代理方法? ---请求数据成功!! 请求数据失败!! 监听数据下载进度!! //3.作为方法的返回值!- (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc] init]; //我们写了一个普通的方法,直接调用; //[_p run:10]; //现在我们思考Masonry的链式编程,我们如何让方法这样调用呢:_p.run(10); //首先能够使用点语法的是不是setter和getter方法 //因为我这里是是要拿出来在执行block,那我们使用getter方法,特点:1.有返回值 2.没有参数 //_p.run 现在我们已经用getter点出方法了,那么怎么加上(10)一个参数呢,我们将get方法返回值设置为一个Block; //_p.run(100);这个方法分解后: 1.void(^blocka)(int m) = _p.run; // 2.blocka(100); //链式编程思想:直接将方法的block返回值变成Niuchao *类型 //_p.run(3).run(3).run(3);//这样就执行了三遍run方法 _p.run(1000).sleep(10);&#125;.h@interface Niuchao : NSObject//block ARC:可以使用Strong MRC:必须使用Copy//block的应用场景:1.对象的属性//@property(nonatomic, strong) void(^eat)();//block的应用场景:2.方法的参数//- (void)eat:(void(^)(void))block;////block的应用场景:3.方法的返回值//- (void)run:(int)m;//- (int)run;//- (void(^)(int))run;//链式编程思想:当我们上面的方法的block返回值变成Niuchao *类型- (Niuchao * (^)(int))run;- (void(^)(int))sleep;@end.m@implementation Niuchao//block的应用场景:2.方法的参数- (void)eat:(void (^)(void))block&#123; block(); //如果用Block做参数的话我们一般会怎么做? //1.保存这个block; //2.做一些特定的事情,比如网络请求数据并解析; //3.然后得到结果,将结果给block&#125;//block的应用场景:3.作为方法的返回值!- (void (^)(int))run&#123; return ^(int m)&#123; NSLog(@\"我跑了%d\",m); &#125;;&#125;//链式编程思想:当我们上面的方法的block返回值变成Niuchao *类型时直接在block的实现中返回self- (Niuchao * (^)(int))run&#123; return ^(int m)&#123; NSLog(@\"我跑了%d米\",m); return self; &#125;;&#125;- (void (^)(int))sleep&#123; return ^(int h)&#123; NSLog(@\"我又休息了%d小时\",h); &#125;;&#125;@end 链式编程示例Masonry编程思想分析 self.view.backgroundColor = [UIColor whiteColor]; UIView *red = [[UIView alloc] init]; red.backgroundColor = [UIColor redColor]; [self.view addSubview:red]; mas设置约束 [red mas_makeConstraints:^(MASConstraintMaker *make) { make.left.top.equalTo(@20); make.right.bottom.equalTo(@-20); }]; mas_makeConstraints 会重置约束 //将Autoresizing设置为NO,重置约束 self.translatesAutoresizingMaskIntoConstraints = NO; 1.创建了一个Maker 绑定了View; 2.在里面创建了一个空的可变数组. MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; 3.将Maker执行block传出来了,就是我们外面使用的make block(constraintMaker); 4.让Maker安装约束 return [constraintMaker install]; // 清空之前所有的约束 遍历约束数组,一个一个设置安装 5.通过Maker进行设置约束,并添加到约束数组里面 make.left.top. 创建一个NSObject的分类1234567891011121314151617181920212223242526272829.h#import &lt;Foundation/Foundation.h&gt;#import \"SumManager.h\"@interface NSObject (Sum)//我们学习Masonry的样子写一个方法,Masonry方法中有带maker类型参数的Block,我们再设置一个sumManager- (int)NC_MakeSum:(void(^)(SumManager *manager))block;@end.m#import \"NSObject+Sum.h\"@implementation NSObject (Sum)- (int)NC_MakeSum:(void (^)(SumManager *))block&#123; //我们想一想这里面是实现,首先方法参数是一个带有SumManager参数的block,所以我们在调用Block的时候需要传递一个SumManager,好,去创建; SumManager *sumManager = [[SumManager alloc] init]; //我们不管外面用sumManager怎么操作,我们只管把sumManager对象传出去, block(sumManager); //*****通过上面的block调用,用户就会去执行add等一系列方法,等待sumManager里面都操作完了我们直接通过方法返回结果; return sumManager.result;&#125;@end 在创建一个管理类:SumManager 1234567891011121314151617181920212223242526272829303132333435.h#import &lt;Foundation/Foundation.h&gt;@class SumManager;typedef SumManager *(^block)(int value);@interface SumManager : NSObject@property(nonatomic,assign) int result;- (SumManager *(^)(int value))add;- (block)reduce;@end.m@implementation SumManager- (SumManager *(^)(int))add&#123; return ^(int value)&#123; _result += value;//将值通过属性保存起来 return self; //返回block的返回值 &#125;;&#125;- (block)reduce&#123; return ^(int value)&#123; _result -= value; return self; &#125;;&#125;@end 执行测试1234567891011121314151617181920@interface MasonryViewController ()@end@implementation MasonryViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int a = 9999; int b = 1; int result = [self NC_MakeSum:^(SumManager *manager) &#123; //这里我们需要在SumManager设置他的add方法,如何想通masonry一样使用; //首先add是个getter方法,然后返回值是个block; //其次如果继续使用点语法,那block也得有返回值,而且这个返回值是SumManager本身类型的类 manager.add(a).reduce(b); &#125;]; NSLog(@\"+a -b =%d\",result);&#125; 代码中注释就是我个人理解","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"IOS-锁","slug":"IOS-锁","date":"2016-07-08T06:15:22.000Z","updated":"2018-03-13T12:25:47.000Z","comments":true,"path":"2016/07/08/IOS-锁/","link":"","permalink":"http://www.niu-chao.top/2016/07/08/IOS-锁/","excerpt":"","text":"在平时的开发中经常使用到多线程，在使用多线程的过程中，难免会遇到资源竞争的问题，那我们怎么来避免出现这种问题那？ 线程安全是什么？ 当一个线程访问数据的时候，其他的线程不能对其进行访问，直到该线程访问完毕。简单来讲就是在同一时刻，对同一个数据操作的线程只有一个。只有确保了这样，才能使数据不会被其他线程影响。而线程不安全，则是在同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果。 比如写文件和读文件，当一个线程在写文件的时候，理论上来说，如果这个时候另一个线程来直接读取的话，那么得到的结果可能是你无法预料的。 怎么来保证线程安全？ 通常我们使用锁的机制来保证线程安全，即确保同一时刻只有同一个线程来对同一个数据源进行访问。 @synchronized@synchronized是 iOS 中最常见的锁，用法很简单： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; [self synchronized];&#125; - (void)synchronized &#123; NSObject * cjobj = [NSObject new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(cjobj)&#123; NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); @synchronized(cjobj)&#123; NSLog(@\"线程2\"); &#125; &#125;);&#125; 控制台输出：12311:35:13.459194+0800 Thread-Lock[24855:431100] 线程1开始11:35:16.460210+0800 Thread-Lock[24855:431100] 线程1结束11:35:16.460434+0800 Thread-Lock[24855:431101] 线程2 解析从上面的控制台输出时间可以看出来，在线程 1 内容全部输出之后，才输出了线程 2 的内容，“线程1结束”与“线程2”都是在“线程1开始”3 秒后输出的。 @synchronized(cjobj) 指令使用的 cjobj 为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程 2 中的 @synchronized(cjobj) 改为 @synchronized(self) ，那么线程 2就不会被阻塞，@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 @sychronized(cjobj){} 内部 cjobj 被释放或被设为 nil 不会影响锁的功能，但如果 cjobj 一开始就是 nil，那就会丢失了锁的功能了。 这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 NSLock先看看iOS中NSLock类的.h文件，从代码中可以看出，该类分成了几个子类：NSLock、NSConditionLock、NSRecursiveLock、NSCondition，然后有一个 NSLocking&gt;协议： 1234@protocol NSLocking- (void)lock;- (void)unlock;@end 虽然 NSLock、NSConditionLock、NSRecursiveLock、NSCondition 都遵循的了 NSLocking 协议，但是它们并不相同。 NSLock 实现了最基本的互斥锁，遵循了 NSLocking 协议，通过 lock 和 unlock 来进行锁定和解锁。 源码1234567891011@interface NSLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; [self nslock];&#125; - (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lock]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;);&#125;控制台输出： 15:03:58.868708+0800 Thread-Lock[39059:846493] 线程1加锁成功 15:04:00.872714+0800 Thread-Lock[39059:846493] 线程1解锁成功 15:04:00.872722+0800 Thread-Lock[39059:846492] 线程2加锁成功 15:04:00.873000+0800 Thread-Lock[39059:846492] 线程2解锁成功 1234567891011121314151617181920212223242526- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock tryLock]) &#123; NSLog(@\"线程3加锁成功\"); [cjlock unlock]; NSLog(@\"线程3解锁成功\"); &#125;else &#123; NSLog(@\"线程3加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:05:38.627767+0800 Thread-Lock[39118:849171] 线程1加锁成功 15:05:38.627767+0800 Thread-Lock[39118:849169] 线程3加锁失败 15:05:40.629969+0800 Thread-Lock[39118:849171] 线程1解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(3); if ([cjlock tryLock]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlock]; NSLog(@\"线程4解锁成功\"); &#125;else &#123; NSLog(@\"线程4加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:07:14.872279+0800 Thread-Lock[39166:851060] 线程1加锁成功 15:07:16.876108+0800 Thread-Lock[39166:851060] 线程1解锁成功 15:07:17.876208+0800 Thread-Lock[39166:851052] 线程4加锁成功 15:07:17.876527+0800 Thread-Lock[39166:851052] 线程4解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程5加锁成功\"); [cjlock unlock]; NSLog(@\"线程5解锁成功\"); &#125;else &#123; NSLog(@\"线程5加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:08:39.705131+0800 Thread-Lock[39204:852782] 线程1加锁成功 15:08:41.708717+0800 Thread-Lock[39204:852782] 线程1解锁成功 15:08:41.708717+0800 Thread-Lock[39204:852784] 线程5加锁成功 15:08:41.708935+0800 Thread-Lock[39204:852784] 线程5解锁成功注意：lock与unlock操作必须在同一线程，否则结果不确定甚至会引起死锁 解析： 除 lock 和 unlock 方法外，NSLock 还提供了 tryLock 和 lockBeforeDate:两个方法。 由上面的结果可以看到 tryLock 并不会阻塞线程，[cjlock tryLock] 能加锁返回 YES，不能加锁返回 NO，然后都会执行后续代码。 这里顺便提一下 trylock 和 lock 使用场景：当前线程锁失败，也可以继续其它任务，用 trylock 合适；当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock。以下的锁都是这样。 lockBeforeDate: 方法会在所指定 Date 之前尝试加锁，会阻塞线程，如果在指定时间之前都不能加锁，则返回 NO，指定时间之前能加锁，则返回 YES。 由于是互斥锁，当一个线程进行访问的时候，该线程获得锁，其他线程进行访问的时候，将被操作系统挂起，直到该线程释放锁，其他线程才能对其进行访问，从而却确保了线程安全。但是如果连续锁定两次，则会造成死锁问题。 NSRecursiveLockNSRecursiveLock 是递归锁，顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 源码：1234567891011@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsrecursivelock];&#125; - (void)nsrecursivelock&#123; NSRecursiveLock * cjlock = [[NSRecursiveLock alloc] init]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; [cjlock lock]; NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value:%d\", value); RecursiveBlock(value - 1); &#125; [cjlock unlock]; NSLog(@\"%d解锁成功\",value); &#125;; RecursiveBlock(3); &#125;);&#125;控制台输出： 16:15:40.584213+0800 Thread-Lock[39579:894111] 3加锁成功 16:15:40.584387+0800 Thread-Lock[39579:894111] value:3 16:15:40.584552+0800 Thread-Lock[39579:894111] 2加锁成功 16:15:40.584635+0800 Thread-Lock[39579:894111] value:2 16:15:40.584810+0800 Thread-Lock[39579:894111] 1加锁成功 16:15:40.585267+0800 Thread-Lock[39579:894111] value:1 16:15:40.585714+0800 Thread-Lock[39579:894111] 0加锁成功 16:15:40.585906+0800 Thread-Lock[39579:894111] 0解锁成功 16:15:40.586138+0800 Thread-Lock[39579:894111] 1解锁成功 16:15:40.586217+0800 Thread-Lock[39579:894111] 2解锁成功 16:15:40.586314+0800 Thread-Lock[39579:894111] 3解锁成功 解析 如果用 NSLock 的话，cjlock 先锁上了，但未执行解锁的时候，就会进入递归的下一层，而再次请求上锁，阻塞了该线程，线程被阻塞了，自然后面的解锁代码不会执行，而形成了死锁。而 NSRecursiveLock 递归锁就是为了解决这个问题。 NSConditionLock NSConditionLock 对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁，它和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock、tryLockWhenCondition:，所以 NSConditionLock 可以称为条件锁。 只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。 unlockWithCondition: 并不是当 condition 符合条件时才解锁，而是解锁之后，修改 condition 的值。 源码123456789101112131415161718@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER; @property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsconditionlock];&#125; - (void)nsconditionlock &#123; NSConditionLock * cjlock = [[NSConditionLock alloc] initWithCondition:0]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(1); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lockWhenCondition:1]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(2); if ([cjlock tryLockWhenCondition:0]) &#123; NSLog(@\"线程3加锁成功\"); sleep(2); [cjlock unlockWithCondition:2]; NSLog(@\"线程3解锁成功\"); &#125; else &#123; NSLog(@\"线程3尝试加锁失败\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockWhenCondition:2 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlockWithCondition:1]; NSLog(@\"线程4解锁成功\"); &#125; else &#123; NSLog(@\"线程4尝试加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:09:44.010992+0800 Thread-Lock[39230:853946] 线程1加锁成功 15:09:45.012045+0800 Thread-Lock[39230:853946] 线程1解锁成功 15:09:46.012692+0800 Thread-Lock[39230:853947] 线程3加锁成功 15:09:48.016536+0800 Thread-Lock[39230:853947] 线程3解锁成功 15:09:48.016564+0800 Thread-Lock[39230:853944] 线程4加锁成功 15:09:48.017039+0800 Thread-Lock[39230:853944] 线程4解锁成功 15:09:48.017040+0800 Thread-Lock[39230:853945] 线程2加锁成功 15:09:48.017215+0800 Thread-Lock[39230:853945] 线程2解锁成功 解析 在线程 1 解锁成功之后，线程 2 并没有加锁成功，而是继续等了 1 秒之后线程 3 加锁成功，这是因为线程 2 的加锁条件不满足，初始化时候的 condition 参数为 0，而线程 2加锁条件是 condition 为 1，所以线程 2 加锁失败。 lockWhenCondition 与 lock 方法类似，加锁失败会阻塞线程，所以线程 2 会被阻塞着。 tryLockWhenCondition: 方法就算条件不满足，也会返回 NO，不会阻塞当前线程。 lockWhenCondition:beforeDate:方法会在约定的时间内一直等待 condition 变为 2，并阻塞当前线程，直到超时后返回 NO。 锁定和解锁的调用可以随意组合，也就是说 lock、lockWhenCondition:与unlock、unlockWithCondition: 是可以按照自己的需求随意组合的。 NSCondition NSCondition 是一种特殊类型的锁，通过它可以实现不同线程的调度。一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。比如说，你可以开启一个线程下载图片，一个线程处理图片。这样的话，需要处理图片的线程由于没有图片会阻塞，当下载线程下载完成之后，则满足了需要处理图片的线程的需求，这样可以给定一个信号，让处理图片的线程恢复运行。 NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，如果进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 NSCondition 可以手动控制线程的挂起与唤醒，可以利用这个特性设置依赖。 源码12345678910111213@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (void)wait; //挂起线程- (BOOL)waitUntilDate:(NSDate *)limit; //什么时候挂起线程- (void)signal; // 唤醒一条挂起线程- (void)broadcast; //唤醒所有挂起线程 @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)viewDidLoad &#123; [super viewDidLoad]; [self nscondition];&#125; - (void)nscondition &#123; NSCondition * cjcondition = [NSCondition new]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程1线程加锁\"); [cjcondition wait]; NSLog(@\"线程1线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程1线程解锁\"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程2线程加锁\"); if ([cjcondition waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程2线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程2线程解锁\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition signal]; &#125;);&#125;控制台输出： 17:15:48.410316+0800 Thread-Lock[40011:943638] 线程1线程加锁 17:15:48.410757+0800 Thread-Lock[40011:943640] 线程2线程加锁 17:15:50.414288+0800 Thread-Lock[40011:943638] 线程1线程唤醒 17:15:50.414454+0800 Thread-Lock[40011:943638] 线程1线程解锁//如果 [cjcondition signal]; 改成 [cjcondition broadcast]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition broadcast]; &#125;);控制台输出： 17:18:08.054109+0800 Thread-Lock[40056:946099] 线程1线程加锁 17:18:08.054304+0800 Thread-Lock[40056:946096] 线程2线程加锁 17:18:10.056071+0800 Thread-Lock[40056:946099] 线程1线程唤醒 17:18:10.056231+0800 Thread-Lock[40056:946099] 线程1线程解锁 17:18:10.056244+0800 Thread-Lock[40056:946096] 线程2线程唤醒 17:18:10.056445+0800 Thread-Lock[40056:946096] 线程2线程解锁 解析 在加上锁之后，调用条件对象的 wait 或 waitUntilDate: 方法来阻塞线程，直到条件对象发出唤醒信号或者超时之后，再进行之后的操作。signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。 dispatch_semaphoredispatch_semaphore 使用信号量机制实现锁，等待信号和发送信号。 dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的只有三个函数，一个是创建信号量，一个是等待信号，一个是发送信号。dispatch_semaphore 的机制就是当有多个线程进行访问的时候，只要有一个获得了信号，其他线程的就必须等待该信号释放。 常用相关API：123dispatch_semaphore_create(long value);dispatch_semaphore_wait(dispatch_semaphore_t _Nonnull dsema, dispatch_time_t timeout);dispatch_semaphore_signal(dispatch_semaphore_t _Nonnull dsema); 用法：12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; [self dispatch_semaphore];&#125; - (void)dispatch_semaphore &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 6 * NSEC_PER_SEC); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程1开始\"); sleep(5); NSLog(@\"线程1结束\"); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程2开始\"); dispatch_semaphore_signal(semaphore); &#125;);&#125;控制台输出： 18:30:37.672490+0800 Thread-Lock[40569:993613] 线程1开始 18:30:42.673845+0800 Thread-Lock[40569:993613] 线程1结束 18:30:42.674165+0800 Thread-Lock[40569:993612] 线程2开始//如果 overTime 改成 3 秒控制台输出： 18:32:32.078186+0800 Thread-Lock[40634:995921] 线程1开始 18:32:35.082943+0800 Thread-Lock[40634:995920] 线程2开始 18:32:37.083115+0800 Thread-Lock[40634:995921] 线程1结束 解析 dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。 dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。 dispatch_semaphore_wait(semaphore, overTime); 方法会判断 semaphore 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime 时限到了，也会执行后续任务。 dispatch_semaphore_signal(semaphore); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。 一个 dispatch_semaphore_wait(semaphore, overTime); 方法会去对应一个 dispatch_semaphore_signal(semaphore); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区。 pthread_mutex 与 pthread_mutex(recursive) pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，POSIX 互斥锁是一种超级易用的互斥锁，使用的时候： 只需要使用 pthread_mutex_init 初始化一个 pthread_mutex_t，pthread_mutex_lock 或者 pthread_mutex_trylock 来锁定 ，pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。 常用相关API：12345pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable);pthread_mutex_lock(pthread_mutex_t * _Nonnull);pthread_mutex_trylock(pthread_mutex_t * _Nonnull);pthread_mutex_unlock(pthread_mutex_t * _Nonnull);pthread_mutex_destroy(pthread_mutex_t * _Nonnull); 用法：pthread_mutex123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex];&#125; - (void)pthread_mutex &#123; __block pthread_mutex_t cjlock; pthread_mutex_init(&amp;cjlock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); pthread_mutex_unlock(&amp;cjlock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程2\"); pthread_mutex_unlock(&amp;cjlock); &#125;);&#125;控制台输出： 14:50:29.842180+0800 Thread-Lock[74478:1647362] 线程1开始 14:50:32.846786+0800 Thread-Lock[74478:1647362] 线程1结束 14:50:32.847001+0800 Thread-Lock[74478:1647359] 线程2 pthread_mutex(recursive) 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex_recursive];&#125; - (void)pthread_mutex_recursive &#123; __block pthread_mutex_t cjlock; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;cjlock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value = %d\", value); sleep(1); RecursiveBlock(value - 1); &#125; NSLog(@\"%d解锁成功\",value); pthread_mutex_unlock(&amp;cjlock); &#125;; RecursiveBlock(3); &#125;);&#125;//控制台输出： 15:31:51.599693+0800 Thread-Lock[74723:1668089] 3加锁成功 15:31:51.599912+0800 Thread-Lock[74723:1668089] value = 3 15:31:52.602002+0800 Thread-Lock[74723:1668089] 2加锁成功 15:31:52.602317+0800 Thread-Lock[74723:1668089] value = 2 15:31:53.604669+0800 Thread-Lock[74723:1668089] 1加锁成功 15:31:53.604957+0800 Thread-Lock[74723:1668089] value = 1 15:31:54.607778+0800 Thread-Lock[74723:1668089] 0加锁成功 15:31:54.608109+0800 Thread-Lock[74723:1668089] 0解锁成功 15:31:54.608391+0800 Thread-Lock[74723:1668089] 1解锁成功 15:31:54.608622+0800 Thread-Lock[74723:1668089] 2解锁成功 15:31:54.608945+0800 Thread-Lock[74723:1668089] 3解锁成功 解析 它的用法和 NSLock 的 lock unlock 用法一致，而它也有一个 pthread_mutex_trylock 方法，pthread_mutex_trylock 和 tryLock 的区别在于，tryLock 返回的是 YES 和 NO，pthread_mutex_trylock 加锁成功返回的是 0，失败返回的是错误提示码。 pthread_mutex(recursive) 作用和 NSRecursiveLock 递归锁类似。如果使用 pthread_mutex_init(&amp;theLock, NULL); 初始化锁的话，上面的代码的第二部分会出现死锁现象，使用递归锁就可以避免这种现象。 OSSpinLock OSSpinLock 是一种自旋锁，和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。 只有加锁，解锁，尝试加锁三个方法。 常用相关API：12345678typedef int32_t OSSpinLock; // 加锁void OSSpinLockLock( volatile OSSpinLock *__lock );// 尝试加锁bool OSSpinLockTry( volatile OSSpinLock *__lock );// 解锁void OSSpinLockUnlock( volatile OSSpinLock *__lock ); 用法：12345678910111213141516171819202122232425262728293031#import &lt;libkern/OSAtomic.h&gt; - (void)viewDidLoad &#123; [super viewDidLoad]; [self osspinlock];&#125; - (void)osspinlock &#123; __block OSSpinLock theLock = OS_SPINLOCK_INIT; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); OSSpinLockUnlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); sleep(1); NSLog(@\"线程2\"); OSSpinLockUnlock(&amp;theLock); &#125;);&#125;控制台输出： 16:02:48.865501+0800 Thread-Lock[75025:1684487] 线程1开始 16:02:51.868736+0800 Thread-Lock[75025:1684487] 线程1结束 16:02:52.922911+0800 Thread-Lock[75025:1684486] 线程2 YY大神 @ibireme 的文章也有说这个自旋锁存在优先级反转问题，具体文章可以戳 不再安全的 OSSpinLock，而 OSSpinLock 在iOS 10.0中被 中的 os_unfair_lock 取代。&gt; 介绍了 OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 os_unfair_lock 自旋锁已经不再安全，然后苹果又整出来个 os_unfair_lock，这个锁解决了优先级反转问题。 常用相关API：123456789// 初始化os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);// 加锁os_unfair_lock_lock(unfairLock);// 尝试加锁BOOL b = os_unfair_lock_trylock(unfairLock);// 解锁os_unfair_lock_unlock(unfairLock);os_unfair_lock 用法和 OSSpinLock 基本一直，就不一一列出了。 总结应当针对不同的操作使用不同的锁，而不能一概而论哪种锁的加锁解锁速度快。 其实每一种锁基本上都是加锁、等待、解锁的步骤，理解了这三个步骤就可以帮你快速的学会各种锁的用法。 @synchronized 的效率最低，不过它的确用起来最方便，所以如果没什么性能瓶颈的话，可以选择使用 @synchronized。 当性能要求较高时候，可以使用 pthread_mutex 或者 dispath_semaphore，由于 OSSpinLock 不能很好的保证线程安全，而在只有在 iOS10 中才有 os_unfair_lock ，所以，前两个是比较好的选择。既可以保证速度，又可以保证线程安全。 对于 NSLock 及其子类，速度来说 NSLock &lt; NSCondition &lt; NSRecursiveLock &lt; NSConditionLock 。&gt;","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"IOS关于内存的一些分析","slug":"IOS关于内存分析","date":"2016-04-09T10:44:32.000Z","updated":"2018-03-20T08:43:27.000Z","comments":true,"path":"2016/04/09/IOS关于内存分析/","link":"","permalink":"http://www.niu-chao.top/2016/04/09/IOS关于内存分析/","excerpt":"","text":"堆栈内存条,我们去操作可读可写的部分,怎么划分堆和栈呢?如果说直接规定一块内存地址为堆,一块内存地址是栈,这样行不行?首先是可以,其次是不好,到底谁应该分配的多一些呢?所以我们不知道谁应该分配的多一些,那么就给它一个弹性划分 创建的对象是放在堆还是栈??对象(结构体数据)放在堆区,假如它的起始地址在堆里面是0xff6543占用四个字节的话,那么它的结束地址是多少,是从高到低还是从低到高?结论：它是从低地址往高地址走的那么就是0xfff6547; 相反在栈区上存储的是对象的起始地址也就是指针,它的地址存储是从高到底的!!!!! 对象 (结构体)通过malloc开辟一段堆空间,返回一个指针地址,就是栈区存放的指针地址; malloc(开辟大小) =相对应= free(放个指针) free(指针):单纯的使用free(传入一个栈空间的地址指针) ,它就会把指针所指向的堆空间释放,但是存在于栈空间中的地址指针不会被释放,所以就会造成野指针 ARC环境:一个存在于栈区的对象指针object,假如是个局部变量,那么在一个方法(即函数)结束后就会被自动释放; 内存泄漏:MRC环境下,如果存在于栈空间的指针地址被销毁了,但是堆空间的数据还没被释放,那么就会造成内存浪费,因为没有地址指向它了,不会被调用了,但系统认为它一直有用不会被释放,所以它就浪费了一段堆空间,造成内存泄漏;野指针:单纯的使用free(传入一个栈空间的地址指针) ,它就会把指针所指向的堆空间释放,但是存在于栈空间中的地址指针不会被释放,当再次访问这个指针时,所以就会造成野指针. C语言的结构体指针与结构体数据的释放CFRunLoopObserverRef observer = CFRunLoopObserverCreate(省略) 怎么释放一个指针?把它指向一个空地址就行了,但是单纯的释放指针而不处理堆空间就会造成内存泄漏,就会引出下面的问题(结构体的释放?)observer = nil; 结构体的释放？C语言中但凡是看到 Create, new , copy ,都会默认开辟对空间就是(malloc),这里返回一个结构体指针,指向这个在堆区中的结构体,那么这个&gt;&gt;&gt;&gt;&gt;&gt;结构体如何释放呢???CFRunLoopObserverRef observer = CFRunLoopObserverCreate 苹果为什么会提供一个CFReleasefree(observer);//这个可不可以释放???CFRelease(observer);//这个又可以不可以呢???? 针对这个问题分析一下,这个结构体里面有哪些数据呢??????? 我们不知道,既然不知道,是不是结构体里面会有可能再次开辟一块堆空间,就是说结构体里面的数据是不是可以再次存一个开辟堆空间的指针,答案是的; 既然我们知道结构体里面可能会存有一个开辟了堆空间的指针的话,那么我们回到上面的问题直接用free(observer)去释放observer所指向的堆空间(结构体)就是不可以的,因为会直接将observer所指向的结构体释放掉’包含’里面的二次指针,而不会去处理’二次’指针开辟的堆空间….,就会造成结构体里面二次开辟的堆空间的内存泄漏(内存浪费),因为它的指针已经被free(observer)释放了…..哈哈哈哈对不对!!!!!! 所以结论就是只能用CFRelease(observer),因为CFRelease拿到这个结构体指针后知道它又开辟了那些堆空间,就会去处理干净,先把结构体里面的二次指针所指向的二次堆空间释放掉,然后再释放结构体. 这个例子类似于dealloc{}这个方法,就在再Viewcontroller要被释放之前,先去清空开辟了的二次堆区域…. 123- (void)dealloc&#123;&#125; Autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。 函数调用栈OC方法的本质 == C函数,其中有个概念叫函数调用栈 栈平衡(占内存的释放),一个函数调用完毕,栈内存就会被释放 object本质 === 指针 —-&gt; 它指向一个对象,对象 === 结构体数据那么一个指针在栈区域占用多少字节,和操作系统32位和64位有关系—&gt;32占4个—&gt;64占8个 NSObject * object = [[NSObject alloc] init];object是个局部变量,它存在于ViewDidLoad大括号中的函数体里面,一个函数调用完毕,栈内存就会被释放NSLog(@”%@”,object); 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)viewDidLoad &#123; [super viewDidLoad];// 死循环 这个不会崩溃 while (true) &#123; 测试随便调用一个方法 [self didReceiveMemoryWarning]; &#125;// 这个会崩溃会造成内存不够,堆栈溢出 [self viewDidLoad];// 栈平衡(占内存的释放),一个函数调用完毕,栈内存就会被释放// sp :指向栈顶! 类似栈顶指针,有些函数有 ,而有些函数没有,// 当这个方法(函数)调用时,就会将sp指针往下减,下面是打断点查看汇编代码(如果看不到可以在菜单DEbug-&gt;Debug Workflow-&gt;Show Disassembly 设置).// 内存`-[ViewController viewDidLoad]:// 0x10e344690 &lt;+0&gt;: pushq %rbp //push入栈空间// 0x10e344691 &lt;+1&gt;: movq %rsp, %rbp// 0x10e344694 &lt;+4&gt;: subq $0x20, %rsp //sub代表减, 0x20十六进制32,表示让sp减32个字节,开辟一段栈空间// 0x10e344698 &lt;+8&gt;: leaq -0x20(%rbp), %rax// 0x10e34469c &lt;+12&gt;: movq %rdi, -0x8(%rbp)// 0x10e3446a0 &lt;+16&gt;: movq %rsi, -0x10(%rbp)// -&gt; 0x10e3446a4 &lt;+20&gt;: movq -0x8(%rbp), %rsi// 0x10e3446a8 &lt;+24&gt;: movq %rsi, -0x20(%rbp)// 0x10e3446ac &lt;+28&gt;: movq 0x260d(%rip), %rsi ; (void *)0x000000010e346cd0: ViewController// 0x10e3446b3 &lt;+35&gt;: movq %rsi, -0x18(%rbp)// 0x10e3446b7 &lt;+39&gt;: movq 0x25da(%rip), %rsi ; \"viewDidLoad\"// 0x10e3446be &lt;+46&gt;: movq %rax, %rdi// 0x10e3446c1 &lt;+49&gt;: callq 0x10e344a52 ; symbol stub for: objc_msgSendSuper2// 0x10e3446c6 &lt;+54&gt;: addq $0x20, %rsp //add代表加, 0x20十六进制32,表示让sp加32个字节,回复一段栈空间// 0x10e3446ca &lt;+58&gt;: popq %rbp// 0x10e3446cb &lt;+59&gt;: retq //ret出栈之前又加回来了// 但是什么函数不会有栈空间呢------叶子函数:最后一个函数,不会再去调用其他函数,下面举个栗子!!! printf(\"niuchao\");//**************以上的例子就解释了 为什么递归会造成内存不够溢出的原因了....因为会一直去调用栈空间,无法完成栈平衡******************&#125;","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"NSString属性copy/strong以及NSMutableString属性copy/strong","slug":"NSString属性copy:strong 以及 NSMutableString属性copy:strong","date":"2015-11-02T02:43:12.000Z","updated":"2018-04-12T12:05:33.000Z","comments":true,"path":"2015/11/02/NSString属性copy:strong 以及 NSMutableString属性copy:strong/","link":"","permalink":"http://www.niu-chao.top/2015/11/02/NSString属性copy:strong 以及 NSMutableString属性copy:strong/","excerpt":"","text":"NSString?copy:strong直接上代码： 对属性进行不可变字符串的赋值12345678910111213141516171819202122232425262728293031@interface ViewController ()@property (nonatomic, copy) NSString *copyedStr;//不可以写成copyStr会报错，意思是不能使用copy来作为开头命名，copy是cocoa用的，就是这么屌@property (nonatomic, strong) NSString *strongStr;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSString *testStr = [NSString stringWithFormat:@\"牛超\"]; self.strongStr = testStr; self.copyedStr = testStr; //前面的是内存地址，后面的是指针地址 NSLog(@\"testStr: %p, %p\",testStr,&amp;testStr); NSLog(@\"strongStr: %p, %p\",_strongStr,&amp;_strongStr); NSLog(@\"copyedStr: %p, %p\",_copyedStr,&amp;_copyedStr); NSLog(@\"textStr的引用计数=%lu strongStr引用计数=%lu copyedStr的引用计数=%lu\",testStr.retainCount,_strongStr.retainCount,_copyedStr.retainCount); 打印结果： NSString?copy:strong[58679:12037746] testStr: 0x6000000290c0, 0x7fff55b1dbe8 NSString?copy:strong[58679:12037746] strongStr: 0x6000000290c0, 0x7fad10408fb8 NSString?copy:strong[58679:12037746] copyedStr: 0x6000000290c0, 0x7fad10408fb0 NSString?copy:strong[58679:12037746] textStr的引用计数=3 strongStr引用计数=3 copyedStr的引用计数=3&#125; 根据输出的内存地址，我们发现，不管用的是strong还是copy，指向的都是同一个地址，也就是testStr的地址。strongStr和copyedStr都只是对testStr的引用，只会导致testStr的计数器加1，并没有拷贝一份新的，就是说有三个指针地址指向一块内存地址,所以他们的引用计数都是3。 这里加深一下对浅拷贝的理解，这里不管是strongStr还是copyedStr都只是对testStr进行了浅拷贝，因为只是复制了一份新的指针地址，而内存地址并没有改变！！！ 对属性进行可变字符串的赋值1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; NSMutableString *testStr = [NSMutableString stringWithFormat:@\"牛超\"]; self.strongStr = testStr; self.copyedStr = testStr; NSLog(@\"testStr: %p, %p\",testStr,&amp;testStr); NSLog(@\"strongStr: %p, %p\",_strongStr,&amp;_strongStr); NSLog(@\"copyedStr: %p, %p\",_copyedStr,&amp;_copyedStr); [testStr appendString:@\"大帅哥\"];//修改一下 NSLog(@\"testStr: %@, %p\",testStr,&amp;testStr); NSLog(@\"strongStr: %@, %p\",_strongStr,&amp;_strongStr); NSLog(@\"copyedStr: %@, %p\",_copyedStr,&amp;_copyedStr); NSLog(@\"textStr的引用计数=%lu strongStr引用计数=%lu copyedStr的引用计数=%lu\",testStr.retainCount,_strongStr.retainCount,_copyedStr.retainCount); 打印结果 NSString?copy:strong[58737:12041684] testStr: 0x6000004443b0, 0x7fff50091be8 NSString?copy:strong[58737:12041684] strongStr: 0x6000004443b0, 0x7fdd58f0af38 NSString?copy:strong[58737:12041684] copyedStr: 0x600000028ee0, 0x7fdd58f0af30 NSString?copy:strong[58737:12041684] testStr: 牛超大帅哥, 0x7fff50091be8 NSString?copy:strong[58737:12041684] strongStr: 牛超大帅哥, 0x7fdd58f0af38 NSString?copy:strong[58737:12041684] copyedStr: 牛超, 0x7fdd58f0af30 NSString?copy:strong[58737:12041684] textStr的引用计数=2 strongStr引用计数=2 copyedStr的引用计数=1 &#125; 可以这个时候，copy修饰的copyedStr字符串，已经不再是简单的引用了，而是拷贝了一个新的，重新开辟了内存空间，让copyedStr指向了这个新的内存地址 == copyedStr进行了深拷贝。而此时的strongStr还只是对testStr进行了浅拷贝，只是复制了一份新的指针地址，内存地址并没有改变 === strongStr进行的浅拷贝。所以此时testStr的retainCount应该是2，strongStr的retainCount应该也是2，就是说有两个指针地址指向一块内存地址。 后面我们把testStr修改一下，后面接上了“大帅哥”，输出内容会发现testStr变化后，strongStr也会随之改变了，为什么？？？因为strong指向的内存地址和testStr指向的内存地址是一样一样一样的，记住是一样的，他们的内存地址都是一样，只是strongStr加了一个指向这块内存空间的指针地址，只是增加的一个引用计数。 而copyStr则为什么不会变化呢？？因为copyStr开辟了新的内存空间了，进行深拷贝了，所以copyStr是新的内存空间，新的指针，它和testStr完全没有关联了，所以copyedStr的retainCount和那两个同流合污的家伙不一样了。。。 由上面的例子可以得出：总结 一、当源字符串是NSString时，是不可变字符串，所以，不管是使用strong还是copy修饰，都是指向原来的对象即指向原来的内存空间，copy与strong操作都只是做了次浅拷贝。二、而当源字符串是NSMutableString时，strong还是只做了浅拷贝，只是将原字符串的引用计数加1了，（需要注意的是，此时_strongString的类型实际上是NSMutableString，而不是NSString)，而copy则是对原字符串做了次深拷贝，从而生成了一个新的对象。（需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString），如果想让拷贝过来的对象是可变的，就需要使mutableCopy函数进行操作。 说来说去，说来说去那么NSString到底是用copy还是strong呢？ 本质上来讲,copy和strong都没有错,但不是说,NSString用copy就一定是最好的—–简直是个屁话，没说一样。 当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。 当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。 这里还有一个性能问题，即在源字符串是NSMutableString，strong是单纯的增加对象的引用计数，而copy操作是执行了一次深拷贝，所以性能上会有所差异。而如果源字符串是NSString时，则没有这个问题。 举个栗子为什么会有性能问题，123456789@property(nonatomic,copy) NSString *str; NSMutableString *mutableStr; str = mutableStr;//copy修饰的NSString在进行set操作时,底层是这样实现的,进行str = mutableStr操作时,内部会执行一个操作: str = [mutableStr copy];//那么这个copy里面做了什么呢?if ([str isMemberOfClass:[str class]]) 没错,就是进行一次判断,判断来源如果是可变的,那么会进行一次深拷贝,如果是不可变,那么好,接下来的操作就跟strong修饰的没有区别,进行浅拷贝; 所以,copy操作内部会进行判断,你别小看了这个if操作所消耗的内存,一次不重要,十次可能也可以忽略不计,但当你的项目十分庞大时,有成百上千个个NSString对象,多多少少会对你的app的性能造成一定的影响. 最后真的是最后了： 当你给你的NSString对象赋值时,如果来源是NSMutableString,那么这种情况就必须要用copy，可以避免NSMutableString带来的非预期问题，就是你不知道NSMutableString在哪改动了，如果用strong的话，你之前需要赋值的NSString对象也会跟随后面来源NSMutableString的改变而改变，但是你最初的需要的是NSString类型的，你肯定是不想让他随便改动的;如果你确定给你的属性赋值的来源是不可变类型的,比如@”牛超大帅哥”这种固定的字符串,那么用strong比较好一点，能节省一点性能，哈哈哈哈。 NSMutableString?copy/strong123456789101112131415161718192021NSMutableString *testStr = [@\"牛超\" mutableCopy];self.strongMutStr = testStr;self.copyedMutStr = testStr;NSLog(@\"testStr: %p, %p\",testStr,&amp;testStr);NSLog(@\"strongMutStr: %p, %p\",_strongMutStr,&amp;_strongMutStr);NSLog(@\"copyedMutStr: %p, %p\",_copyedMutStr,&amp;_copyedMutStr);[testStr appendString:@\"大帅哥\"];//修改一下NSLog(@\"testStr: %@, %p\",testStr,&amp;testStr);NSLog(@\"strongMutStr: %@, %p\",_strongMutStr,&amp;_strongMutStr);NSLog(@\"copyedMutStr: %@, %p\",_copyedMutStr,&amp;_copyedMutStr);NSLog(@\"textStr的引用计数=%lu strongMutStr引用计数=%lu copyedMutStr的引用计数=%lu\",testStr.retainCount,_strongMutStr.retainCount,_copyedMutStr.retainCount);NSString?copy:strong[60617:12359919] testStr: 0x600000446f90, 0x7fff5438cbe8NSString?copy:strong[60617:12359919] strongMutStr: 0x600000446f90, 0x7fef6140cbe8NSString?copy:strong[60617:12359919] copyedMutStr: 0x60000003fca0, 0x7fef6140cbe0NSString?copy:strong[60617:12359919] testStr: 牛超大帅哥, 0x7fff5438cbe8NSString?copy:strong[60617:12359919] strongMutStr: 牛超大帅哥, 0x7fef6140cbe8NSString?copy:strong[60617:12359919] copyedMutStr: 牛超, 0x7fef6140cbe0NSString?copy:strong[60617:12359919] textStr的引用计数=2 strongMutStr引用计数=2 copyedMutStr的引用计数=1 打印结果和NSString属性进行NSMutableString数据源赋值没啥区别：接下来我们进行测试 后面进行测试：在后面分别加上测试一或者测试二代码测试一、12 [self.copyedMutStr appendString:@\"吗？\"];//使用copy修饰的NSMutableString类型的属性去使用可变的专属方法会崩溃崩溃： *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Attempt to mutate immutable object with appendString:' 测试二、123456 NSString *str = [NSString stringWithFormat:@\"牛超\"]; self.copyedMutStr = [NSMutableString stringWithFormat:@\"%@\", str]; NSLog(@\"self.copyedMutStr的class类型 = %s\",object_getClassName(self.copyedMutStr)); NSLog(@\"self.copyedMutStr的class类型 = %@\",NSStringFromClass([self.copyedMutStr class])); [self.copyedMutStr appendString:@\"大帅哥吗？\"];//使用copy修饰的NSMutableString类型的属性去使用可变的专属方法会崩溃崩溃： -[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa6f61686375696e7 原因很明显，是向NSTaggedPointerString对象发了一个它不能识别的selector。原因是copy版本的NSMutableString属性本质上不是一个NSMutableString对象，而是一个NSTaggedPointerString对象，它是一个不可变对象。该对象是NSMutableString对象执行copy得来的，还记得我们上一节的结论吗？（注意：对一个对象执行copy得到的是一个不可变的对象）。 结论： 定义一个可变类型的属性，不能使用copy，因为copy修饰词在属性set方法赋值时（不管赋值源是可变还是不可变的）产生为的对象是一个不可变对象，跟其可变属性类型是冲突的，当使用可变类型的专属方法时会出现崩溃。","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"Markdown","slug":"MarkDown","date":"2015-10-08T05:24:22.000Z","updated":"2018-03-07T06:58:46.000Z","comments":true,"path":"2015/10/08/MarkDown/","link":"","permalink":"http://www.niu-chao.top/2015/10/08/MarkDown/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0):'''A docstring'''if param1 &gt; param2: # interestingprint 'Greater'return (param2 - param1 + 1) or Noneclass SomeClass:pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.niu-chao.top/tags/Markdown/"}]},{"title":"一头驮砖的牛博客","slug":"一头驮砖的牛博客","date":"2014-10-08T03:53:46.000Z","updated":"2018-04-12T03:03:54.000Z","comments":true,"path":"2014/10/08/一头驮砖的牛博客/","link":"","permalink":"http://www.niu-chao.top/2014/10/08/一头驮砖的牛博客/","excerpt":"","text":"","categories":[],"tags":[]}]}