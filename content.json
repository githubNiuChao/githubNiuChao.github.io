{"meta":{"title":"一头驮砖的牛","subtitle":null,"description":"------ IOS | Python ------","author":null,"url":"http://www.niu-chao.top"},"pages":[{"title":"关于","date":"2017-03-13T09:55:52.000Z","updated":"2018-03-20T12:02:51.000Z","comments":true,"path":"about/index.html","permalink":"http://www.niu-chao.top/about/index.html","excerpt":"","text":"[ 始 终 在 奔 跑 ]"},{"title":"标签","date":"2017-03-14T03:54:25.000Z","updated":"2018-03-13T10:17:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.niu-chao.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-02T04:33:16.000Z","updated":"2018-03-13T10:17:12.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.niu-chao.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CFRunLoop应用","slug":"CFRunLoop应用","date":"2017-04-21T04:34:56.000Z","updated":"2018-03-15T12:51:26.000Z","comments":true,"path":"2017/04/21/CFRunLoop应用/","link":"","permalink":"http://www.niu-chao.top/2017/04/21/CFRunLoop应用/","excerpt":"","text":"CFRunLoop分析卡顿的原因 –所有cell加载都在主线程的一次Runloop循环里面!!!UI的渲染也属于Runloop的事情!!!卡顿就是因为一次Runloop循环,渲染的图片太多了,而且都是高清大图!!! 解决思路 —&gt;让Runloop循环每次只加载一张图片步骤:—通过观察(oberserver)Runloop的循环;—Runloop循环一次,只加载一张图片;—-&gt; Cell数据源加载图片的代码放在数组列表中去.—-&gt; Runloop循环一次,就从数组里面拿到一张图片加载 查看系统CFRunloop代码,我们可以知道,对应之前的说的Runloop包含三个部分, Timer, Source ,Observe; 里面包含—–APP启动的第一条线程这三个结构体指针 typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopSource * CFRunLoopSourceRef; typedef struct CF_BRIDGED_MUTABLE_TYPE(id) __CFRunLoopObserver * CFRunLoopObserverRef; typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef; —-运行循环观察者活动Run Loop Observer Activitiestypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), //进入Runloop循环通知 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //Runloop在处理Timer之前通知 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //Runloop在处理Sources之前通知 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //Runloop在处理完Sources/Timer之后即将要进入Waiting状态通知 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //Runloop在结束Waiting状态即将要处理Sources/Timer时通知,与BeforeTimers/BeforeSources异曲同工,但是它可以观察即将要处理Sources/Timer,BeforeTimers/BeforeSources只能观察各种对应的….!!! kCFRunLoopExit = (1UL &lt;&lt; 7), //Runloop退出通知 kCFRunLoopAllActivities = 0x0FFFFFFFU //Runloop以上所有的活动都会通知!!!}; —–OC里面回调有Block,代理,KVO!!! 但是在C语言里面只有函数指针 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169.h#import &lt;UIKit/UIKit.h&gt;@interface NCViewController : UIViewController+ (void)task_1:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_2:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_3:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_4:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;+ (void)task_5:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath;@end.m#import \"NCViewController.h\"#import \"NCCFRunLoopWorkDistribution.h\"static NSString *IDENTIFIER = @\"IDENTIFIER\";static CGFloat CELL_HEIGHT = 135.f;@interface NCViewController () &lt;UITableViewDataSource, UITableViewDelegate&gt;@property (nonatomic, strong) UITableView *ncTableView;@end@implementation NCViewController- (void)loadView &#123; self.view = [UIView new]; self.ncTableView = [UITableView new]; self.ncTableView.delegate = self; self.ncTableView.dataSource = self; [self.view addSubview:self.ncTableView];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.ncTableView.frame = self.view.bounds;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self.ncTableView registerClass:[UITableViewCell class] forCellReuseIdentifier:IDENTIFIER];&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 520;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:IDENTIFIER]; cell.selectionStyle = UITableViewCellSelectionStyleNone; cell.currentIndexPath = indexPath; [NCViewController task_5:cell indexPath:indexPath]; [NCViewController task_1:cell indexPath:indexPath]; //添加Runloop的任务列表里面 [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_2:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_3:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; [[NCCFRunLoopWorkDistribution sharedRunLoopWorkDistribution] addTask:^BOOL(void) &#123; if (![cell.currentIndexPath isEqual:indexPath]) &#123; return NO; &#125; [NCViewController task_4:cell indexPath:indexPath]; return YES; &#125; withKey:indexPath]; return cell;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return CELL_HEIGHT;&#125;+ (void)task_5:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; for (NSInteger i = 1; i &lt;= 5; i++) &#123; [[cell.contentView viewWithTag:i] removeFromSuperview]; &#125;&#125;+ (void)task_1:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(5, 5, 300, 25)]; label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor redColor]; label.text = [NSString stringWithFormat:@\"%zd - 图纸索引是重中之重\", indexPath.row]; label.font = [UIFont boldSystemFontOfSize:13]; label.tag = 1; [cell.contentView addSubview:label];&#125;+ (void)task_2:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(105, 20, 85, 85)]; imageView.tag = 2; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;+ (void)task_3:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(200, 20, 85, 85)]; imageView.tag = 3; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;+ (void)task_4:(UITableViewCell *)cell indexPath:(NSIndexPath *)indexPath &#123; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(5, 99, 300, 35)]; label.lineBreakMode = NSLineBreakByWordWrapping; label.numberOfLines = 0; label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor colorWithRed:0 green:100.f/255.f blue:0 alpha:1]; label.text = [NSString stringWithFormat:@\"%zd - 绘制大图像的优先级较低。 应分配到不同的运行循环中.\", indexPath.row]; label.font = [UIFont boldSystemFontOfSize:13]; label.tag = 4; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(5, 20, 85, 85)]; imageView.tag = 5; NSString *path = [[NSBundle mainBundle] pathForResource:@\"Image\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.contentMode = UIViewContentModeScaleAspectFit; imageView.image = image; [UIView transitionWithView:cell.contentView duration:0.3 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionTransitionCrossDissolve animations:^&#123; [cell.contentView addSubview:label]; [cell.contentView addSubview:imageView]; &#125; completion:^(BOOL finished) &#123; &#125;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; &#125;@end CFRunLoop处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178.h#import &lt;UIKit/UIKit.h&gt;typedef BOOL(^NCCFRunLoopWorkDistributionUnit)(void);@interface NCCFRunLoopWorkDistribution : NSObject@property (nonatomic, assign) NSUInteger maximumQueueLength;+ (instancetype)sharedRunLoopWorkDistribution;- (void)addTask:(NCCFRunLoopWorkDistributionUnit)unit withKey:(id)key;- (void)removeAllTasks;@end@interface UITableViewCell (NCCFRunLoopWorkDistribution)@property (nonatomic, strong) NSIndexPath *currentIndexPath;@end.m#import \"NCCFRunLoopWorkDistribution.h\"#import &lt;objc/runtime.h&gt;#define NCCFRunLoopWorkDistribution_DEBUG 1@interface NCCFRunLoopWorkDistribution ()//(4.....) 定义任务数组@property (nonatomic, strong) NSMutableArray *tasks;@property (nonatomic, strong) NSMutableArray *tasksKeys;@property (nonatomic, strong) NSTimer *timer;@end@implementation NCCFRunLoopWorkDistribution- (void)removeAllTasks &#123; [self.tasks removeAllObjects]; [self.tasksKeys removeAllObjects];&#125;//(5....)保存block任务到数组- (void)addTask:(NCCFRunLoopWorkDistributionUnit)unit withKey:(id)key&#123; [self.tasks addObject:unit]; [self.tasksKeys addObject:key]; //如果要执行的Task任务超出屏幕范围个数就把第一个删了... if (self.tasks.count &gt; self.maximumQueueLength) &#123; [self.tasks removeObjectAtIndex:0]; [self.tasksKeys removeObjectAtIndex:0]; &#125;&#125;- (void)_timerFiredMethod:(NSTimer *)timer &#123; //We do nothing here&#125;- (instancetype)init&#123; if ((self = [super init])) &#123; _maximumQueueLength = 30; _tasks = [NSMutableArray array]; _tasksKeys = [NSMutableArray array]; _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(_timerFiredMethod:) userInfo:nil repeats:YES]; &#125; return self;&#125;+ (instancetype)sharedRunLoopWorkDistribution &#123; static NCCFRunLoopWorkDistribution *singleton; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; singleton = [[NCCFRunLoopWorkDistribution alloc] init]; //注意这里传的是一个self的OC对象 [self _registerRunLoopWorkDistributionAsMainRunloopObserver:singleton]; &#125;); return singleton;&#125;+ (void)_registerRunLoopWorkDistributionAsMainRunloopObserver:(NCCFRunLoopWorkDistribution *)runLoopWorkDistribution &#123; static CFRunLoopObserverRef defaultModeObserver; // (2.....) 创建观察者CFRunLoopObserver,封装了一个函数方法 _registerObserver(kCFRunLoopBeforeWaiting, defaultModeObserver, NSIntegerMax - 999, kCFRunLoopCommonModes, (__bridge void *)runLoopWorkDistribution, &amp;_defaultModeRunLoopWorkDistributionCallback);&#125;//创建观察者CFRunLoopObserver函数方法static void _registerObserver(CFOptionFlags activities, CFRunLoopObserverRef observer, CFIndex order, CFStringRef mode, void *info, CFRunLoopObserverCallBack callback) &#123;// (1....)拿到当前的Runloop CFRunLoopRef runLoop = CFRunLoopGetCurrent(); //定义第六个参数,上下文结构体,里面的info同callback函数中的void *info参数有联系,会传一个self CFRunLoopObserverContext context = &#123; 0, info, //这个info实际上就是self , info == (__bridge void *)self; (需要__bridge桥接,因为这里是将OC转为C语言) &amp;CFRetain, &amp;CFRelease, NULL &#125;; //创建观察者 CFRunLoopObserver 关键系统方法 //二参数看扩展②,我们选择的是kCFRunLoopBeforeWaiting //三参数是否循环观察 //五参数创建函数的回调,直接写callback函数指针,所以我们定义了一个函数:_defaultModeRunLoopWorkDistributionCallback //六参数创建上下文,取定义好的一个结构体指针 observer = CFRunLoopObserverCreate(NULL, activities, YES, order, callback, &amp;context);// (3.....)添加观察者,这里用的mode是kCFRunLoopDefaultMode---只能拖拽完毕后加载, kCFRunLoopCommonModes----可以边拖动边加载 CFRunLoopAddObserver(runLoop, observer, mode); //释放:因为这里是C语言环境,不属于ARC,所有带有几个单词的函数需要注意'释放' -- new,cope,create 会在堆区域开辟内存空间!!! CFRelease(observer);&#125;// (4....)//定义一个函数方法,用于创建创建观察者 CFRunLoopObserverstatic void _defaultModeRunLoopWorkDistributionCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; _runLoopWorkDistributionCallback(observer, activity, info);&#125;//在源码中我们看到CallBack是这个样式的,理由有三个参数,第一个和第二个我们都有解释,那三个是什么??//------void *info 是一个万能指针,直接打印啥都没有,需要同CFRunLoopObserverCreate中的上下文结构体指针(&amp;context)有联系,在里面传selfstatic void _runLoopWorkDistributionCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; //(5....)提取self的tesks任务列表 //*********这里为什么取不到self******** //因为只有OC的方法本质是消息机制,就是发送消息megSend(),里面才有两个隐藏的函数: 1、id self(方法调用者) 2、SEL _cmd,C语言函数里面是没有的. //通过上下文指针&amp;context传值self,然后桥接__bridge成OC的self NCCFRunLoopWorkDistribution *runLoopWorkDistribution = (__bridge NCCFRunLoopWorkDistribution *)info; //取到self就能拿到它的任务列表tasks,tasks里面是NCCFRunLoopWorkDistributionUnitBlock. //如果tasks里面没有block任务,那就直接返回 if (runLoopWorkDistribution.tasks.count == 0) &#123; return; &#125; BOOL result = NO; while (result == NO &amp;&amp; runLoopWorkDistribution.tasks.count) &#123; //取到NCCFRunLoopWorkDistributionUnitBlock任务 NCCFRunLoopWorkDistributionUnit unit = runLoopWorkDistribution.tasks.firstObject; //执行block result = unit(); //执行完需要删除任务 [runLoopWorkDistribution.tasks removeObjectAtIndex:0]; [runLoopWorkDistribution.tasksKeys removeObjectAtIndex:0]; &#125;&#125;@end@implementation UITableViewCell (NCCFRunLoopWorkDistribution)@dynamic currentIndexPath;- (NSIndexPath *)currentIndexPath &#123; NSIndexPath *indexPath = objc_getAssociatedObject(self, @selector(currentIndexPath)); return indexPath;&#125;- (void)setCurrentIndexPath:(NSIndexPath *)currentIndexPath &#123; objc_setAssociatedObject(self, @selector(currentIndexPath), currentIndexPath, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 代码中注释就是我个人理解","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"RunLoop线程","slug":"RunLoop线程","date":"2017-04-19T02:12:55.000Z","updated":"2018-03-15T12:49:49.000Z","comments":true,"path":"2017/04/19/RunLoop线程/","link":"","permalink":"http://www.niu-chao.top/2017/04/19/RunLoop线程/","excerpt":"","text":"RunLoopRunloop，顾名思义就是跑圈，他的本质就是一个do，while循环，当有事做时就做事，没事做时就休眠。至于怎么做事，怎么休眠,这个是由系统内核来调度。 首先我们要明确一个概念，线程一般都是一次执行完毕任务，就销毁了。而在线程中添加了runloop，并运行起来，实际上是添加了一个do，while循环，这样这个线程的程序就一直卡在do，while循环上，这样相当于线程的任务一直没有执行完，所有线程一直不会销毁。所有，一旦我们添加了一个runloop，并run了，我们如果要销毁这个线程，必须停止runloop，至于停止的方式，我们接着往下看。 主线程的RunLoopmain.m12345678910111213141516171819202122 /*拓展* 循环与递归 区别???? 方法的调用就是函数的调用,函数调用本质: 分配一块栈区域!!递归就是自己调用自己,反复的调用就会反复的分配空间,所有造成堆栈溢出; 汇编语言中会提到为什么递归即函数的反复调用会反复开辟栈空间,而死循环不会反复开辟空间. */#import &lt;UIKit/UIKit.h&gt;#import \"AppDelegate.h\"int main(int argc, char * argv[]) &#123; @autoreleasepool &#123;// NSLog(@\"来了\"); /*UIApplicationMain为我们创建了一个:主循环Runloop,默认开启 1.保证程序不退出; 2.监听事件,触摸事件,时钟,网络事件; 3.如果没有时间发生,就会进入休眠状态,性能损耗低; */ int main = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@\"走了\"); return main; &#125;&#125; Runloop 初探1234567891011121314151617181920212223 - (void)viewDidLoad &#123; [super viewDidLoad]; //此方法默认封装到Runloop里面了; //***此方法默认加入的是默认模式,所以依然会出现UI操作冲突的问题*** [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //此方法默认不加入Runloop,需要手动加入到Runloop循环当中去 NSTimer *time = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //[NSRunLoop mainRunLoop];当前就是主Runloop //NSDefaultRunLoopMode 默认模式 //UITrackingRunLoopMode UI模式 //NSRunLoopCommonModes 占位模式 原则上讲它不属于Runloop模式 // [[NSRunLoop currentRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];//UI操作(触摸)时和timer事件 相互跳动执行 // [[NSRunLoop currentRunLoop] addTimer:time forMode:UITrackingRunLoopMode];//只会在有UI操作(触摸)时执行timer事件 [[NSRunLoop currentRunLoop] addTimer:time forMode:NSRunLoopCommonModes];//UI操作(触摸)时和timer事件正常执行&#125;- (void)timerMethod&#123; NSLog(@\"timerMethod执行 当前线程%@:\",[NSThread currentThread]);&#125; 拓展 Runloop始终与线程将关联Runloop有5中模式 每一种模式中都包含 timer —- source —- observer NSDefaultRunLoopMode 默认模式UITrackingRunLoopMode UI模式–1.用户体验优先级最高 2.只会在有UI操作(触摸)时进行NSRunLoopCommonModes 占位模式 原则上讲它不属于Runloop模式内核模式初始化模式 当将timer事件设定为,可以理解为添加到 默认模式的事件列表下,并添加到主线程的Runloop中,但是我们知道凡是UI操作的事件都是添加到主线程上的,所以在默认模式下的timer事件会与UI操作事件发生冲突,主线程上的Runloop会在timer事件与UI操作事件上来回跳动Run执行;但是如果将timer事件添加到UI模式下,就会发现它只会在有触摸或者说有UI操作时才会执行. RunLoop与线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@interface ViewController ()@property (nonatomic,strong) NCThread *ncThread;//demo2为了测试线程是否被释放----设置strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放;@property (nonatomic, strong) dispatch_source_t timer;@end@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; //子线程 NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSTimer *time = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES]; //注意这里是子线程的Runloop [[NSRunLoop currentRunLoop] addTimer:time forMode:NSRunLoopCommonModes];//UI操作(触摸)时和timer事件正常执行 // while (true) &#123; //什么事情都不做,这里只是让线程有执行不完的任务,进而保住线程不被释放; //----虽然线程保住了,但是timerMethod事件却未处理是为什么呢????? 想一想这里是不是子线程!!!; // &#125; //Runloop ----子线程的Runloop默认是不会开启的,这就解释了为什么线程保住了却未执行timerMethod方法!!!! 看拓展② //currentRunLoop会调用底层的CFRunloop,在这里只有此currentRunLoop()调用时才回去创建一个Runloop,是个懒加载过程!!! [[NSRunLoop currentRunLoop] run];//run起来死循环任务,不会执行下面的代码 //现在考虑一下Runloop如何被停止呢???? 好,尝试在timerMethod方法中将线程退出,线程一但退出那是不是Runloop也就被退出了!!! NSLog(@\"线程来了\");//当run起来后timerMethod虽然执行了,但是这里不会打印执行,因为上面的Runloop是死循环,类似于UIApplicationMain的下面不会执行一样; &#125;]; //这个方法是在主线程上执行的,不会等待block,所以对于Thread的释放是没有关系的. [thread start]; &#125; //1.当子线程thread为局部变量时此方法不会执行,因为被释放了; //2.但是当子线程为_ncThread全局变量时也不会执行, 为什么呢????? ----strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放; - (void)timerMethod&#123; NSLog(@\"timerMethod执行 当前线程%@:\",[NSThread currentThread]);//不会执行 看拓展① //暴力干掉子线程!!!!对应上面的Runloop退出. [NSThread exit]; [NSThread sleepForTimeInterval:1.0];//模拟耗时操作,从而引进子线程概念 &#125; -(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [NSThread exit];//暴力干掉主线程会出现什么情况呢??? //答案是主线程被杀死了,例子中的拖动等主线程UI操作不会执行了, 这是为什么呢???主线程都能被干掉?太不可思议了!!! 看拓展③ &#125;#import \"NCThread.h\"@implementation NCThread-(void)dealloc&#123; NSLog(@\"线程释放!!!\");&#125;@end 拓展 ①线程的生命,只能通过线程的任务去保住,无任务就会被释放!!! —-让线程有执行不完的任务(Runloop 死循环任务),线程就不会释放了!!!! —-所以它在例子中block任务执行完毕后就会被释放; ②主线程的Runloop是在UIApplicationMain中默认开启新创建的线程默认是不会开启的. ③主线程对于系统来说也是一个子线程,这么多APP,对于系统来说的就有这么多子线程;—–APP启动的第一条线程主线程进行UI操作,UIKit框架也是线程不安全的,保证线程安全就需要’锁’,但是凡是’锁’都需要消耗性能,就好像属性里面的nonatomic也是避免消耗性能的,所以苹果规定 “凡是UI操作统一放在—-主线程”,当然可以尝试一下放在子线程,如果出现资源抢夺,会出现未知的问题. RunLoop与线程之间的通信1234567891011121314151617181920212223242526 - (void)viewDidLoad &#123; [super viewDidLoad]; //子线程 NSThread *thread = [[NSThread alloc] initWithBlock:^&#123; NSLog(@\"子线程进来 :%@\",[NSThread currentThread]); while (true) &#123; // ***Runloop启动线程间的通信*** [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.0001]]; &#125; &#125;]; [thread start]; //线程间的通信----在主线程上为子线程添加了一个任务; //但是子线程为启动Runloop,所以otherMethod不会执行,不管它是不是在start之前还是之后; //这个方法实际上是将放在Runloop事件队列里面,所以单纯加一个while死循环也不能执行,需要通过Runloop去启动线程之间的通信 [self performSelector:@selector(otherMethod) onThread:thread withObject:nil waitUntilDone:NO];&#125;-(void)otherMethod&#123; NSLog(@\"otherMethod%@\",[NSThread currentThread]);&#125; Runloop与GCD1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface ViewController ()@property (nonatomic,strong) NCThread *ncThread;//demo2为了测试线程是否被释放----设置strong只是保存了_ncThread这个OC对象的生命,线程是由CPU直接调度的,所以它在例子中block任务执行完毕后就会被释放;@property (nonatomic, strong) dispatch_source_t timer;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];// GCD与Runloop有紧密的联系// **** 用GCD创建的timer,运行后发现与UI操作完美运行,没有冲突,说明GCD把我们封装好了Runloop, 底层就CFRunloop***** //创建timer 并把它放在全局队列里面 _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); //设置timer dispatch_source_set_timer(_timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC,0); //创建句柄 回调 dispatch_source_set_event_handler(_timer, ^&#123; NSLog(@\"------线程:%@\",[NSThread currentThread]); &#125;); //启动timer dispatch_resume(_timer); // GCD timer创建代码块 // dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, &lt;#dispatchQueue#&gt;); // dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, &lt;#intervalInSeconds#&gt; * NSEC_PER_SEC, &lt;#leewayInSeconds#&gt; * NSEC_PER_SEC); // dispatch_source_set_event_handler(timer, ^&#123; // &lt;#code to be executed when timer fires#&gt; // &#125;); // dispatch_resume(timer);&#125;//打开方法断点,点击屏幕可以查看函数调用栈(如何查看调用栈呢----在lldb模式下输入:thread backtrace ),可以看到CFRunLoopDoSource0,根据拓展我们知道Source0不是内核事件,对啊,因为他是咱们点击出来的,用户事件嘛!!! 拓展①-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;&#125; 拓展 ① 通过GCD代码我们引入了Source这个概念,是不是很眼熟,没错在每个Runloop都包含三个部分: Timer, Source ,Observe;(可以去CFRunloop源码里查看为什么包含这三部分) Source—事件源(输入源) 对应的是—CFRunloopSourceRef,凡是看到” Ref” 这个字的时候就代表他是一个结构体指针; 按照函数调动栈解释:Source分为两个部分;Source0:不是Source1就是Source0Source1:内核与其他线程的通讯事件","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"浅析KVO原理以及自己完成简单的KVO代码实现","slug":"浅析KVO原理以及自己完成简单的KVO代码实现","date":"2017-03-18T09:44:48.000Z","updated":"2018-03-13T12:13:00.000Z","comments":true,"path":"2017/03/18/浅析KVO原理以及自己完成简单的KVO代码实现/","link":"","permalink":"http://www.niu-chao.top/2017/03/18/浅析KVO原理以及自己完成简单的KVO代码实现/","excerpt":"","text":"KVO KVO 是 Objective-C 对观察者设计模式的一种实现。【另外一种是：通知机制（notification）】；KVO 提供一种机制，指定一个被观察对象(例如 A 类)，当对象某个属性(例如 A 中的字符串 name)发生更改时，对象会获得通知，并作出相应处理；【且不需要给被观察的对象添加任何额外代码，就能使用 KVO 机制】 在 MVC 设计架构下的项目，KVO 机制很适合实现 mode 模型和 view 视图之间的通讯。例如：代码中，在模型类A创建属性数据，在控制器中创建观察者，一旦属性数据发生改变就收到观察者收到通知，通过 KVO 再在控制器使用回调方法处理实现视图 B 的更新； 实现原理KVO 在 Apple 中的 API 文档如下： 1234 Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … KVO 的实现依赖于 Objective-C 强大的 Runtime，从以上 Apple 的文档可以看出苹果对于 KVO 机制的实现是一笔带过，而具体的细节没有过多的描述，关于KVO 机制的底层实现原理，从网上的一些关于 KVO 的资料总结了有关的内容： 基本原理 1、KVO是基于runtime机制实现的 2、当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3、如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4、每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法 5、键值观察通知依赖于NSObject 的两个方法:willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 深度剖析 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；） 1、NSKVONotifying_A 类剖析：在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被 KVO 机制修改为指向系统新创建的子类 NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。（备注：isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。这也是 KVO 回调机制，为什么都俗称KVO技术为黑魔法的原因之一吧：内部神秘、外观简洁。 2、子类setter方法剖析：KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用 2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后，observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 相关特点 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @&quot;newName&quot;，这时是不会触发 KVO 机制，更加不会调用回调方法的。所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。 代码实现代码由ViewController（观察者）、NSObject+NCKVO（KVO实现）、NCperson（被观察者）、Dog（扩展类），几个类组成，分为五项代码线流程进行演示； ViewController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899.h#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@end.m#import \"ViewController.h\"#import \"NCperson.h\"#import \"NSObject+NCKVO.h\"#import &lt;objc/message.h&gt;/**拓展 NSKeyValueObservingOptionNew 返回新值 NSKeyValueObservingOptionOld 返回旧值 NSKeyValueObservingOptionInitial 注册的时候就会发一次通知，改变后也会发通知 NSKeyValueObservingOptionPrior 改变之前发一次，改变之后发一次 *//** 打印出的kind = 1 表示的为set方法 */@interface ViewController ()@property (nonatomic, strong) NCperson *p;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NCperson *person = [[NCperson alloc] init];// 一.系统方法添加观察者// [person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// [person addObserver:self forKeyPath:@\"dog.age\" options:NSKeyValueObservingOptionNew context:nil];// 三.观察内部属性(容器)dog类中的多个属性// [person addObserver:self forKeyPath:@\"dog\" options:NSKeyValueObservingOptionNew context:nil];// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// [person addObserver:self forKeyPath:@\"code\" options:NSKeyValueObservingOptionNew context:nil];// ********* 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加 [person NC_addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; _p = person;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; //五.传过来的object为子类（派生类），不知道正确不正确 NSLog(@\"成功通知到了新值：%@\",change);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static int a = 0;// 一.手动添加KVO (观察者类中关闭自动模式)，实现手动观察方法 will did ；// [_p willChangeValueForKey:@\"name\"];// _p.name = [NSString stringWithFormat:@\"%d\", a++];// [_p didChangeValueForKey:@\"name\"];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// _p.dog.age = a++;// 三.观察内部属性(容器)dog类中的多个属性 ，KVO的本质是观察set方法，需结合KVC去实现// _p.dog.age = a++;// _p.dog.height = a++;// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// _p-&gt;code = [NSString stringWithFormat:@\"%d\",a++]; // -&gt; 访问成员变量// 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// _p.name = [NSString stringWithFormat:@\"%d\",a++]; objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]); NSLog(@\"修改了%@\",_p.name);&#125;@end NSObject+NCKVO (头部拓展可忽略)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137NSObject+NCKVO.h#import &lt;Foundation/Foundation.h&gt;@interface NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;@endNSObject+NCKVO.m#import \"NSObject+NCKVO.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;/*拓展 方法、成员变量、类、对象 Class typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif &#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： // 成员变量列表 struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif variable length structurestruct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif variable length structure struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125;由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。*//*拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） 添加子类的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； */#define force_inline __inline__ __attribute__((always_inline))// 未用@implementation NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; //1.动态的创建一个派生类：NSKVONotifying_NCperson； NSString *oldClassName = NSStringFromClass(self.class); NSString *newClassName = [@\"NCKVO_\" stringByAppendingString:oldClassName]; //运行时创建类 Class myClass = objc_allocateClassPair(self.class, [newClassName UTF8String], 0); //注册类 objc_registerClassPair(myClass); //2.动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类 object_setClass(self, myClass);// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； /***** 拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） */ //oc方法 SEL IMP 第四个参数：添加这个方法它的方法类型 //当第三个参数IMP有参数的情况下需要强转 //第四个参数type\"v@:\" 变成\"v@:@\",其中v表示void，@表示对象参数，：表示sel，@还是表示对象参数，可在开发文档中查询 class_addMethod(myClass, @selector(setName:), (IMP)impSetName, \"v@:@\"); //4.将观察者保存到当前的对象当中,当前例子中观察者应该是ViewController objc_setAssociatedObject(self,\"observer\",observer,OBJC_ASSOCIATION_ASSIGN);&#125;//OC中方法的调用里面有两个隐藏的参数！！！ 1、id self 2、SEL _cmd//objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]);//***要想获得第三个参数的值必须在参数列表中补齐 id self,SEL _cmdvoid impSetName(id self,SEL _cmd,NSString *name)&#123; id class = [self class]; //修改子类与父类的isa object_setClass(self, class_getSuperclass([self class])); //给父类发送消息，让他拿到newName的值 objc_msgSend(self, @selector(setName:),name); //再修改回来子类与父类的isa object_setClass(self, class); NSLog(@\"父类拿到了新值：%@\",name); //取出观察者,当前例子中观察者应该是ViewController id observer = objc_getAssociatedObject(self, \"observer\"); //给观察者发送消息，并发送change值，当前传过去的self为子类（派生类） NSDictionary *change = [NSDictionary dictionaryWithObjectsAndKeys:@\"1\",@\"kind\",name,@\"new\", nil]; objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:),@\"name\",self,change,nil);&#125;@end NCperson1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 NCperson.h#import &lt;Foundation/Foundation.h&gt;#import \"Dog.h\"@interface NCperson : NSObject&#123; @public NSString *code; //类的属性实质是是成员变量、set、get方法的封装，而KVO实际上是对Set方法的观察&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) Dog *dog;@property (nonatomic, strong) NSMutableArray *mArray;@endNCperson.m#import \"NCperson.h\"@implementation NCperson- (instancetype)init&#123; if (self = [super init]) &#123; _dog = [[Dog alloc] init]; _mArray = NSMutableArray.array; &#125; return self;&#125;//三.返回一个容器，里面是字符串类型！ key：被观察的key字符串//+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;//// NSLog(@\"%@\",key);//// NSSet *set = [super keyPathsForValuesAffectingValueForKey:key];// if ([key isEqualToString:@\"dog\"]) &#123;// NSArray *array = @[@\"_dog.age\",@\"_dog.height\"];// set = [set setByAddingObjectsFromArray:array];// &#125;// return set;//&#125;//一.默认为自动通知模式的KVO；这将其关闭，实现手动KVO//+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;//// return NO;//&#125;@end Dog1234567891011121314151617181920Dog.h#import &lt;Foundation/Foundation.h&gt;@interface Dog : NSObject@property (nonatomic ,assign) int age;@property (nonatomic ,assign) int height;@endDog.m#import \"Dog.h\"@implementation Dog@end 以上就是代码的实现，很简单，盼指点！！！","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"GCD队列与同/异步执行 & NSOperationQueue","slug":"GCD队列与同:异步执行 & NSOperationQueue","date":"2016-12-14T06:38:05.000Z","updated":"2018-03-30T10:52:06.000Z","comments":true,"path":"2016/12/14/GCD队列与同:异步执行 & NSOperationQueue/","link":"","permalink":"http://www.niu-chao.top/2016/12/14/GCD队列与同:异步执行 & NSOperationQueue/","excerpt":"","text":"同步-异步 串行-并行同步异步、并行串行的区分同步异步：是指任务添加到线程上这个过程的同步和异步串行并行：是指任务在线程上运行的串行和并行 使用block，invocation或者是dispatch_function_t(C函数)添加任务，任务中都是需要执行return返回的，同步异步就是指是否和这个return同步，如果是同步添加到线程上的任务，把任务添加到线程上的添加操作本身会等到任务中的return执行之后才执行自己的return。如果是异步添加到线程上的任务，添加任务操作本身执行后会立即返回，并不会等待任务完成后自己才返回,例如如下这个bug: 建了一个线程(串行：并行串行不关紧要，只有一个任务，都是串行),声明一个数组指针 p 传给sumAB函数，添加到线程上，结果崩溃了BAD_ACCESS，原因如下：dispatch_async_f执行的是异步把任务添加到线程中，添加完成后立刻就返回了，这个时候任务还没执行，等到任务执行的时候viewDidLoad函数已经执行完,p 指针已经被释放了,就引起了BAD_ACCESS。然后我们将dispatch_async_f改为dispatch_sync_f ——结果正常运行 关于这句话(dispatch_async_f执行的是异步把任务添加到线程中，添加完成后立刻就返回了)可以查看官方文档dispatch解释:Submits an application-defined functionfor asynchronous execution on a dispatch queue and returns immediately; 另外：如果一定要异步添加到线程上，需要保证p只能不被释放掉，使用__bridge_retain和__bridge_transfer关键字转交所有权，P指针指向对象的所有权会转交到sumAB的object手中，直到sumAB执行完之前该对象都不会被释放。 12345678910111213141516171819 - (void)dispatch_async_fTest&#123; dispatch_queue_t queue = dispatch_queue_create(\"Serial\", DISPATCH_QUEUE_SERIAL); NSArray * array = [[NSArray alloc] initWithObjects:@\"niuchao\",nil];// void * p = (__bridge void*) array;//桥接将OC对象转为C指针 void * p = (__bridge_retained void*)array;//retain dispatch_async_f(queue, p, sumAB);//异步把任务添加到线程// dispatch_sync_f(queue, p, sumAB);//同步把任务添加到线程,修改这里 将async改成sync;&#125;void sumAB(void* input)&#123;// id object = (__bridge id )input;//桥接将C指针转为OC对象 id object = (__bridge_transfer id)input;//transfer [NSThread sleepForTimeInterval:3]; NSLog(@\"%@\", object); NSLog(@\"线程结束\");&#125; 串·并队列 与 异.同执行方式的搭配主队列：系统为我们创建好的一个串行队列，牛逼之处在于它管理必须在主线程中执行的任务，属于有劳保的。全局队列：系统为我们创建好的一个并行队列，使用起来与我们自己创建的并行队列无本质差别。 上面说了系统自带的两个队列，下面我们来用自己创建的队列研究一下各种搭配情况。我们先创建两个队列，并且测试方法都是在主线程中调用：//串行队列self.serialQueue = dispatch_queue_create(&quot;serialQueue.ys.com&quot;, DISPATCH_QUEUE_SERIAL);//并行队列self.concurrentQueue = dispatch_queue_create(&quot;concurrentQueue.ys.com&quot;, DISPATCH_QUEUE_CONCURRENT); (一)串行队列 + 同步执行123456789101112131415161718192021 dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); &#125;); dispatch_sync(self.serialQueue, ^&#123; NSLog(@\"4========%@\",[NSThread currentThread]); &#125;);打印结果:[6735:1064390] 1========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 2========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 3========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125;[6735:1064390] 4========&lt;NSThread: 0x600000073cc0&gt;&#123;number = 1, name = main&#125; 全部都在当前线程顺序执行，也就是说，同步执行不具备开辟新线程的能力。 (二)串行队列 + 异步执行12345678910111213141516171819 dispatch_async(self.serialQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); &#125;); dispatch_async(self.serialQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); &#125;); dispatch_async(self.serialQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[6774:1073235] 4========&lt;NSThread: 0x60800006e9c0&gt;&#123;number = 1, name = main&#125;[6774:1073290] 1========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125;[6774:1073290] 2========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125;[6774:1073290] 3========&lt;NSThread: 0x608000077000&gt;&#123;number = 3, name = (null)&#125; 先打印了4，然后顺序在子线程中打印1，2，3。说明异步执行具有开辟新线程的能力，并且串行队列必须等到前一个任务执行完才能开始执行下一个任务，同时，异步执行会使内部函数率先返回，不会与正在执行的外部函数发生死锁。 (三)并行队列 + 同步执行12345678910111213141516171819 dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_sync(self.concurrentQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[7012:1113594] 1========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 2========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 3========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125;[7012:1113594] 4========&lt;NSThread: 0x60800007e340&gt;&#123;number = 1, name = main&#125; 未开启新的线程执行任务，并且Block函数执行完成后dispatch函数才会返回，才能继续向下执行，所以我们看到的结果是顺序打印的。 (四)并行队列 + 异步执行12345678910111213141516171819 dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"1========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"2========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"3========%@\",[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@\"4========%@\",[NSThread currentThread]);打印结果:[7042:1117492] 1========&lt;NSThread: 0x600000071900&gt;&#123;number = 3, name = (null)&#125;[7042:1117491] 3========&lt;NSThread: 0x608000070240&gt;&#123;number = 5, name = (null)&#125;[7042:1117451] 4========&lt;NSThread: 0x600000067400&gt;&#123;number = 1, name = main&#125;[7042:1117494] 2========&lt;NSThread: 0x600000071880&gt;&#123;number = 4, name = (null)&#125; 开辟了多个线程，触发任务的时机是顺序的，但是我们看到完成任务的时间却是随机的，这取决于CPU对于不同线程的调度分配，但是，线程不是无条件无限开辟的，当任务量足够大时，线程是会重复利用的。 ⚠️重点⚠️: 想要开辟新线程必须让任务在异步执行，想要开辟多个线程，只有让任务在并行队列中异步执行才可以。执行方式和队列类型多层组合在一定程度上能够实现对于代码执行顺序的调度。同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 对于单核CPU来说，不存在真正意义上的并行，所以，多线程执行任务，其实也只是一个人在干活，CPU的调度决定了非等待任务的执行速率，同时对于非等待任务，多线程并没有真正意义提高效率。 线程可以简单的认为就是一段代码+运行时数据。 同步执行会在当前线程执行任务，不具备开辟线程的能力或者说没有必要开辟新的线程。并且，同步执行必须等到Block函数执行完毕，dispatch函数才会返回，从而阻塞同一串行队列中外部方法的执行。 异步执行dispatch函数会直接返回，Block函数我们可以认为它会在下一帧加入队列，并根据所在队列目前的任务情况无限下一帧执行，从而不会阻塞当前外部任务的执行。只有异步执行才有开辟新线程的必要，但是异步执行不一定会开辟新线程。 只要是队列，肯定是FIFO（先进先出），但是谁先执行完要看第1条。 只要是串行队列，肯定要等上一个任务执行完成，才能开始下一个任务。但是并行队列当上一个任务开始执行后，下一个任务就可以开始执行。 想要开辟新线程必须让任务在异步执行，想要开辟多个线程，只有让任务在并行队列中异步执行才可以。执行方式和队列类型多层组合在一定程度上能够实现对于代码执行顺序的调度。 同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 对于多核CPU来说，线程数量也不能无限开辟，线程的开辟同样会消耗资源，过多线程同时处理任务并不是你想像中的人多力量大。 GCD APIdispatch_after 该函数用于任务延时执行，其中参数dispatch_time_t代表延时时长，dispatch_queue_t代表使用哪个队列。如果队列未主队列，那么任务在主线程执行，如果队列为全局队列或者自己创建的队列，那么任务在子线程执行，代码如下: 1234567891011121314151617181920 //主队列延时 dispatch_time_t when_main = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)); dispatch_after(when_main, dispatch_get_main_queue(), ^&#123; NSLog(@\"main_%@\",[NSThread currentThread]); &#125;); //全局队列延时 dispatch_time_t when_global = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4.0 * NSEC_PER_SEC)); dispatch_after(when_global, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"global_%@\",[NSThread currentThread]); &#125;); //自定义队列延时 dispatch_time_t when_custom = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)); dispatch_after(when_custom, self.serialQueue, ^&#123; NSLog(@\"custom_%@\",[NSThread currentThread]); &#125;);打印结果:[1508:499647] main_&lt;NSThread: 0x60000007cf40&gt;&#123;number = 1, name = main&#125;[1508:499697] global_&lt;NSThread: 0x608000262d80&gt;&#123;number = 3, name = (null)&#125;[1508:499697] custom_&lt;NSThread: 0x608000262d80&gt;&#123;number = 3, name = (null)&#125; dispatch_once 保证函数在整个生命周期内只会执行一次，看代码: 123456789-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"无论如何点击只执行一次once:%@\",[NSThread currentThread]); &#125;);&#125;打印结果:[1524:509261]无论如何点击只执行一次once: &lt;NSThread: 0x600000262940&gt;&#123;number = 1, name = main&#125; dispatch_group_async &amp; dispatch_group_notify GCD有一个神器的东西叫做队列组，当加入到队列组中的所有任务执行完成之后，会调用dispatch_group_notify函数通知任务全部完成，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 dispatch_group_t group = dispatch_group_create(); __block NSString *A; __block NSString *B; __block NSString *C; dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"1========开始%@\",[NSThread currentThread]); sleep(1); A = @\"I\"; NSLog(@\"1========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"2========开始%@\",[NSThread currentThread]); sleep(1); B = @\"Love\"; NSLog(@\"2========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"3========开始%@\",[NSThread currentThread]); sleep(1); C = @\"You\"; NSLog(@\"3========结束%@\",[NSThread currentThread]); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; for (int i = 10; i &gt;= 1; i--) &#123; NSLog(@\"%d\",i); [NSThread sleepForTimeInterval:1.0]; &#125; NSString *love = [@\"牛超--\"stringByAppendingFormat:@\"%@-%@-%@ \",A,B,C]; NSLog(@\"%@\",love); &#125;);打印结果:GCD[31406:6418787] 2========开始&lt;NSThread: 0x60000007cdc0&gt;&#123;number = 4, name = (null)&#125;GCD[31406:6418785] 3========开始&lt;NSThread: 0x604000466200&gt;&#123;number = 5, name = (null)&#125;GCD[31406:6418803] 1========开始&lt;NSThread: 0x604000466140&gt;&#123;number = 3, name = (null)&#125;GCD[31406:6418787] 2========结束&lt;NSThread: 0x60000007cdc0&gt;&#123;number = 4, name = (null)&#125;GCD[31406:6418785] 3========结束&lt;NSThread: 0x604000466200&gt;&#123;number = 5, name = (null)&#125;GCD[31406:6418803] 1========结束&lt;NSThread: 0x604000466140&gt;&#123;number = 3, name = (null)&#125;GCD[31406:6418643] 10 ....GCD[31406:6418643] 1GCD[31406:6418643] 牛超--I-Love-You 打印结果这里再次验证:异步执行+并行队列(global_queue就是一个全局的并行队列) 会开辟多个线程. 那我们用串行队列试一试呢?1234567891011GCD[31509:6433454] 1========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 1========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 2========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 2========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 3========开始&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433454] 3========结束&lt;NSThread: 0x60400027cbc0&gt;&#123;number = 3, name = (null)&#125;GCD[31509:6433023] 10 ....GCD[31509:6433023] 1GCD[31509:6433023] 牛超--I-Love-You 打印结果: 再次验证了异步执行+串行队列 会新开辟一条新线程，串行执行任务 dispatch_barrier_async 栅栏函数 栅栏函数，此方法创建的任务，会查找当前队列中有没有其他任务要执行，如果有，则等待已有任务执行完毕后再执行，同时，在此任务之后进入队列的任务，需要等待此任务执行完成后，才能执行。看代码 这里异步执行并行队列 123456789101112131415161718192021222324252627282930313233343536 dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"1========%@\",[NSThread currentThread]);&#125;);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"2========%@\",[NSThread currentThread]);&#125;);dispatch_barrier_sync(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"barrier========%@\",[NSThread currentThread]);&#125;);NSLog(@\"代码位置在barrier任务之后========%@\",[NSThread currentThread]);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"3========%@\",[NSThread currentThread]);&#125;);NSLog(@\"任务3之后========%@\",[NSThread currentThread]);dispatch_async(self.concurrentQueue, ^&#123; sleep(1); NSLog(@\"4========%@\",[NSThread currentThread]);&#125;);打印结果:GCD[32294:6533209] 代码位置在barrier任务之后========&lt;NSThread: 0x600000069880&gt;&#123;number = 1, name = main&#125;GCD[32294:6533209] 任务3之后========&lt;NSThread: 0x600000069880&gt;&#123;number = 1, name = main&#125;GCD[32294:6533334] 1========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125;GCD[32294:6533337] 2========&lt;NSThread: 0x600000274a80&gt;&#123;number = 4, name = (null)&#125;GCD[32294:6533334] barrier========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125;GCD[32294:6533337] 4========&lt;NSThread: 0x600000274a80&gt;&#123;number = 4, name = (null)&#125;GCD[32294:6533334] 3========&lt;NSThread: 0x60400007ed00&gt;&#123;number = 3, name = (null)&#125; 因为在任务中加入了耗时操作,所以主线程先执行完.而且1,2,barrier,3,4任务,都同为异步执行+同步队列,是不是也和咱们之前说的规则吻合:会开辟多个线程,并且并行执行任务(任务结束前后顺序随机); 那么我们将dispatch_barrier_async异步换成dispatch_barrier_sync同步,会有什么样的效果呢????? 12345678打印结果:GCD[32439:6550892] 2========&lt;NSThread: 0x604000277bc0&gt;&#123;number = 4, name = (null)&#125;GCD[32439:6550894] 1========&lt;NSThread: 0x600000263580&gt;&#123;number = 3, name = (null)&#125;GCD[32439:6550537] barrier========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550537] 代码位置在barrier任务之后========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550537] 任务3之后========&lt;NSThread: 0x6040000674c0&gt;&#123;number = 1, name = main&#125;GCD[32439:6550892] 3========&lt;NSThread: 0x604000277bc0&gt;&#123;number = 4, name = (null)&#125;GCD[32439:6550902] 4========&lt;NSThread: 0x604000272680&gt;&#123;number = 5, name = (null)&#125; barrier变成了主线程,想一想和咱们之前的规则是不是吻合,同步执行一个并行队列:不会开辟新线程,在主线程上串行执行任务;但依然是先执行完并行队列中再barrier之前加入的任务;再去执行再barrier之后加入的任务而且1,2,3,4任务,为异步执行+同步队列,是不是也和咱们之前说的规则吻合:会开辟多个线程,并且并行执行任务(任务结束前后顺序随机); dispatch_apply该函数用于重复执行某个任务，如果任务队列是并行队列，重复执行的任务会并发执行，如果任务队列为串行队列，则任务会顺序执行，需要注意的是，该函数为同步函数，要防止线程阻塞和死锁! 12345678910111213141516171819 //重复执行 dispatch_apply(5, self.serialQueue, ^(size_t i) &#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]); &#125;);打印结果: GCD[33023:6656397] 第0次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第1次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第2次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第3次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; GCD[33023:6656397] 第4次_&lt;NSThread: 0x60000006a740&gt;&#123;number = 1, name = main&#125; 如果将其换成并行队列呢??打印结果: GCD[33123:6672667] 第3次_&lt;NSThread: 0x60400027cf00&gt;&#123;number = 4, name = (null)&#125; GCD[33123:6672668] 第2次_&lt;NSThread: 0x600000270040&gt;&#123;number = 5, name = (null)&#125; GCD[33123:6672669] 第1次_&lt;NSThread: 0x60000026ff00&gt;&#123;number = 3, name = (null)&#125; GCD[33123:6672525] 第0次_&lt;NSThread: 0x60000006fd80&gt;&#123;number = 1, name = main&#125; GCD[33123:6672668] 第4次_&lt;NSThread: 0x600000270040&gt;&#123;number = 5, name = (null)&#125; 12345该方法会造成死锁dispatch_apply(5, dispatch_get_main_queue(), ^(size_t i) &#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]);&#125;); 该函数用于重复执行某个任务，如果任务队列是并行队列，重复执行的任务会并发执行，如果任务队列为串行队列，则任务会顺序执行，需要注意的是，该函数为同步函数，要防止线程阻塞和死锁!!!!dispatch_apply 如果是一个同步执行的话,那就与之前的规律不吻合,暂时还不知道为什么?? 官方文档的解释:该函数将一个应用程序定义的函数提交给调度队列以进行多个调用，并在返回之前等待该函数的所有迭代完成。如果目标队列是返回的并发队列dispatch_get_global_queue，则该功能可以同时调用，因此它必须是可重入安全的。在并发队列中使用此函数可以作为有效的并行for循环很有用。迭代的当前索引被传递给函数的每个调用。 dispatch_semaphore GCD信号量 看这几个函数的时候你需要抛开队列，丢掉同步异步，不要把它们想到一起，混为一谈，信号量只是控制任务执行的一个条件而已，相对于上面通过队列以及执行方式来控制线程的开辟和任务的执行，它更贴近对于任务直接的控制。类似于单个队列的最大并发数的控制机制，提高并行效率的同时，也防止太多线程的开辟对CPU早层负面的效率负担。dispatch_semaphore_create创建信号量，初始值不能小于0；dispatch_semaphore_wait等待降低信号量，也就是信号量-1；dispatch_semaphore_signal提高信号量，也就是信号量+1；dispatch_semaphore_wait和dispatch_semaphore_signal通常配对使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i=0; i&lt;5; i++) &#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_async(self.concurrentQueue, ^&#123; NSLog(@\"第%@次_%@\",@(i),[NSThread currentThread]); dispatch_semaphore_signal(semaphore); &#125;); &#125;将dispatch_semaphore_t代码注释掉看看出现什么效果 GCD[33996:6868522] 第2次_&lt;NSThread: 0x60400046ac00&gt;&#123;number = 5, name = (null)&#125; GCD[33996:6868525] 第1次_&lt;NSThread: 0x600000069a40&gt;&#123;number = 4, name = (null)&#125; GCD[33996:6868521] 第0次_&lt;NSThread: 0x600000069a00&gt;&#123;number = 3, name = (null)&#125; GCD[33996:6868524] 第3次_&lt;NSThread: 0x600000069b00&gt;&#123;number = 6, name = (null)&#125; GCD[33996:6868571] 第4次_&lt;NSThread: 0x60400046ad40&gt;&#123;number = 7, name = (null)&#125;将dispatch_semaphore_t代码打开看看出现什么效果 GCD[34054:6874836] 第0次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第1次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第2次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第3次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; GCD[34054:6874836] 第4次_&lt;NSThread: 0x60400027a5c0&gt;&#123;number = 3, name = (null)&#125; - (void)dispatch_semaphore_tDemo&#123; //###通过dispatch_semaphore_t控制最大并发线程数量 dispatch_queue_t conturrent = dispatch_queue_create(\"concurrent\", DISPATCH_QUEUE_CONCURRENT); dispatch_queue_t serial = dispatch_queue_create(\"serial\", DISPATCH_QUEUE_SERIAL); dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); for (int i= 0; i&lt; 10 ; i++) &#123; dispatch_async(serial, ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); //信号量-1 dispatch_async(conturrent, ^&#123; NSLog(@\"thread-info:%@开始执行任务%d\",[NSThread currentThread],(int)i); sleep(1); NSLog(@\"thread-info:%@结束执行任务%d\",[NSThread currentThread],(int)i); dispatch_semaphore_signal(semaphore); //信号量+1 &#125;); &#125;); &#125;&#125; 信号量是控制任务执行的重要条件，当信号量为0时，所有任务等待，信号量越大，允许可并行执行的任务数量越多。 NSOperation &amp;&amp; NSOperationQueueNSOperation 它提供了关于任务的执行，取消，以及随时获取任务的状态，添加任务依赖以及优先级等方法和属性，相对于GCD提供的方法来说，更直观，更方便，并且提供了更多的控制接口。（很多时候，苹果设计的架构是很棒的，不要只是在乎他实现了什么，可能你学到的东西会更多），有几个方法和属性我们了解一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface NSOperation : NSObject &#123;@private id _private; int32_t _private1;#if __LP64__ int32_t _private1b;#endif&#125;- (void)start;//启动任务 默认在当前线程执行- (void)main;//自定义NSOperation，写一个子类，重写这个方法，在这个方法里面添加需要执行的操作。@property (readonly, getter=isCancelled) BOOL cancelled;//是否已经取消，只读- (void)cancel;//取消任务@property (readonly, getter=isExecuting) BOOL executing;//正在执行，只读@property (readonly, getter=isFinished) BOOL finished;//执行结束，只读@property (readonly, getter=isConcurrent) BOOL concurrent; // To be deprecated; use and override 'asynchronous' below@property (readonly, getter=isAsynchronous) BOOL asynchronous NS_AVAILABLE(10_8, 7_0);//是否并发，只读@property (readonly, getter=isReady) BOOL ready;//准备执行- (void)addDependency:(NSOperation *)op;//添加依赖- (void)removeDependency:(NSOperation *)op;//移除依赖@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;//所有依赖关系，只读typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;;//系统提供的优先级关系枚举@property NSOperationQueuePriority queuePriority;//执行优先级@property (nullable, copy) void (^completionBlock)(void) NS_AVAILABLE(10_6, 4_0);//任务执行完成之后的回调- (void)waitUntilFinished NS_AVAILABLE(10_6, 4_0);//阻塞当前线程，等到某个operation执行完毕。@property double threadPriority NS_DEPRECATED(10_6, 10_10, 4_0, 8_0);//已废弃，用qualityOfService替代。@property NSQualityOfService qualityOfService NS_AVAILABLE(10_10, 8_0);//服务质量，一个高质量的服务就意味着更多的资源得以提供来更快的完成操作。@property (nullable, copy) NSString *name NS_AVAILABLE(10_10, 8_0);//任务名称@end NSOperation本身是个抽象类，不能直接使用，我们有三种方式赋予它新的生命，就是下面这三个东西: 1.NSOperation自定义子类这是我要说的第一个任务类型，我们可以自定义继承于NSOperation的子类，并重写父类提供的方法;2.NSBlockOperation第二个就是系统提供的NSOperation的子类NSBlockOperation，我们看一下他提供的API： 123456789101112@interface NSBlockOperation : NSOperation &#123;@private id _private2; void *_reserved2;&#125;+ (instancetype)blockOperationWithBlock:(void (^)(void))block;- (void)addExecutionBlock:(void (^)(void))block;@property (readonly, copy) NSArray&lt;void (^)(void)&gt; *executionBlocks;@end 123456789-(void)NSBlockOperationRun&#123; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_%@_%@\",[NSOperationQueue currentQueue],[NSThread currentThread]); &#125;]; [blockOper start];&#125;打印结果:[4313:1121900] NSBlockOperationRun_&lt;NSOperationQueue: 0x608000037420&gt;&#123;name = 'NSOperationQueue Main Queue'&#125;_&lt;NSThread: 0x60000006dd80&gt;&#123;number = 1, name = main&#125; 我们发现这个任务是在当前线程顺序执行的，我们发现还有一个方法addExecutionBlock:试一下：1234567891011121314151617181920-(void)NSBlockOperationRun&#123; NSBlockOperation *blockOper = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_1_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_2_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_3_%@\",[NSThread currentThread]); &#125;]; [blockOper addExecutionBlock:^&#123; NSLog(@\"NSBlockOperationRun_4_%@\",[NSThread currentThread]); &#125;]; [blockOper start];打印结果:[4516:1169835] NSBlockOperationRun_1_&lt;NSThread: 0x60000006d880&gt;&#123;number = 1, name = main&#125;[4516:1169875] NSBlockOperationRun_3_&lt;NSThread: 0x600000070800&gt;&#123;number = 4, name = (null)&#125;[4516:1169877] NSBlockOperationRun_4_&lt;NSThread: 0x6080000762c0&gt;&#123;number = 5, name = (null)&#125;[4516:1169893] NSBlockOperationRun_2_&lt;NSThread: 0x608000076100&gt;&#123;number = 3, name = (null)&#125; 从打印结果来看，这个4个任务是异步并发执行的，开辟了多条线程。 3.NSInvocationOperation第三个同样也是系统提供给我们的一个任务类，基于一个target对象以及一个selector来创建任务，具体代码：12345678910-(void)NSInvocationOperationRun&#123; NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; [invocationOper start];&#125;-(void)invocationOperSel&#123; NSLog(@\"NSInvocationOperationRun_%@\",[NSThread currentThread]);&#125;运行结果：[4538:1173118] NSInvocationOperationRun_&lt;NSThread: 0x60800006e900&gt;&#123;number = 1, name = main&#125; 运行结果与NSBlockOperation单个block函数的执行方式相同，同步顺序执行。的确系统的封装给予我们关于任务更直观的东西，但是对于多个任务的控制机制并不完善，所以我们有请下一位，也许你会眼前一亮。 NSOperationQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; queue.maxConcurrentOperationCount = 1;// NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil];// [queue addOperation:invocationOper];// invocationOper.queuePriority = NSOperationQueuePriorityVeryLow; NSBlockOperation *blockOper1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun____1%@\",[NSThread currentThread]); &#125;]; blockOper1.queuePriority = NSOperationQueuePriorityVeryLow;// [queue addOperation:blockOper1]; NSBlockOperation *blockOper2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____2%@\",[NSThread currentThread]); &#125;]; blockOper2.queuePriority = NSOperationQueuePriorityLow;// [queue addOperation:blockOper2]; NSBlockOperation *blockOper3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____3%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper3]; NSBlockOperation *blockOper4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____4%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper4]; NSBlockOperation *blockOper5 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____5%@\",[NSThread currentThread]); &#125;];// [queue addOperation:blockOper5]; blockOper1.queuePriority=NSOperationQueuePriorityVeryLow; blockOper2.queuePriority=NSOperationQueuePriorityLow; blockOper3.queuePriority=NSOperationQueuePriorityNormal; blockOper4.queuePriority=NSOperationQueuePriorityHigh; blockOper5.queuePriority=NSOperationQueuePriorityVeryHigh; NSArray *aray = @[blockOper1,blockOper2,blockOper3,blockOper4,blockOper5]; [queue addOperations:aray waitUntilFinished:NO];// 加入队列之后不用调用任务的start方法，队列会帮你管理任务的执行情况。// 上诉执行结果开辟多条线程,说明这些任务在队列中为并发执行的。****下面我们改变一下任务的优先级*** 打印结果:未添加queue.maxConcurrentOperationCount = 1时,优先级添加无效果,随机执行!!!! GCD[43375:9146881] NSBlockOperationRun_____5&lt;NSThread: 0x600000273a80&gt;&#123;number = 5, name = (null)&#125; GCD[43375:9146878] NSBlockOperationRun____1&lt;NSThread: 0x604000469b00&gt;&#123;number = 7, name = (null)&#125; GCD[43375:9147158] NSBlockOperationRun_____3&lt;NSThread: 0x604000469600&gt;&#123;number = 3, name = (null)&#125; GCD[43375:9146880] NSBlockOperationRun_____4&lt;NSThread: 0x604000469ac0&gt;&#123;number = 6, name = (null)&#125; GCD[43375:9146877] NSBlockOperationRun_____2&lt;NSThread: 0x600000273940&gt;&#123;number = 4, name = (null)&#125; 打印结果:添加queue.maxConcurrentOperationCount = 1时,优先级有效果!!! 开辟了三个小城 GCD[43441:9153871] NSBlockOperationRun_____5&lt;NSThread: 0x6000004769c0&gt;&#123;number = 3, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____4&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____3&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153873] NSBlockOperationRun_____2&lt;NSThread: 0x600000475d80&gt;&#123;number = 4, name = (null)&#125; GCD[43441:9153870] NSBlockOperationRun____1&lt;NSThread: 0x60400027a780&gt;&#123;number = 5, name = (null)&#125; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; queue.maxConcurrentOperationCount = 1; // NSInvocationOperation *invocationOper = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invocationOperSel) object:nil]; // [queue addOperation:invocationOper]; // invocationOper.queuePriority = NSOperationQueuePriorityVeryLow; NSBlockOperation *blockOper1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun____1%@\",[NSThread currentThread]); &#125;]; blockOper1.queuePriority = NSOperationQueuePriorityVeryLow; [queue addOperation:blockOper1]; NSBlockOperation *blockOper2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____2%@\",[NSThread currentThread]); &#125;]; blockOper2.queuePriority = NSOperationQueuePriorityLow; [queue addOperation:blockOper2]; NSBlockOperation *blockOper3 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____3%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper3]; NSBlockOperation *blockOper4 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____4%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper4]; NSBlockOperation *blockOper5 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@\"NSBlockOperationRun_____5%@\",[NSThread currentThread]); &#125;]; [queue addOperation:blockOper5]; blockOper1.queuePriority=NSOperationQueuePriorityVeryLow; blockOper2.queuePriority=NSOperationQueuePriorityLow; blockOper3.queuePriority=NSOperationQueuePriorityNormal; blockOper4.queuePriority=NSOperationQueuePriorityHigh; blockOper5.queuePriority=NSOperationQueuePriorityVeryHigh; // NSArray *aray = @[blockOper1,blockOper2,blockOper3,blockOper4,blockOper5]; [queue addOperations:aray waitUntilFinished:NO]; ** 而且如果测试的各个线程不是按数组直接添加话的,而是逐个添加的,优先级也是没有效果的!!! (逐个添加任务到队列 + 没有添加queue.maxConcurrentOperationCount = 1) 打印结果:-------结果完全随机,开辟多个线程 GCD[43634:9173255] NSBlockOperationRun____1&lt;NSThread: 0x604000269940&gt;&#123;number = 4, name = (null)&#125; GCD[43634:9173257] NSBlockOperationRun_____4&lt;NSThread: 0x6000002769c0&gt;&#123;number = 5, name = (null)&#125; GCD[43634:9173258] NSBlockOperationRun_____3&lt;NSThread: 0x604000269a00&gt;&#123;number = 3, name = (null)&#125; GCD[43634:9173261] NSBlockOperationRun_____5&lt;NSThread: 0x600000276a80&gt;&#123;number = 7, name = (null)&#125; GCD[43634:9173256] NSBlockOperationRun_____2&lt;NSThread: 0x600000276a00&gt;&#123;number = 6, name = (null)&#125; (逐个添加任务到队列 + 添加了queue.maxConcurrentOperationCount = 1) 打印结果:-------打印多次依然是这个结果,优先级未完全出现效果,开辟两个线程 GCD[43700:9180313] NSBlockOperationRun____1&lt;NSThread: 0x604000270d00&gt;&#123;number = 3, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____5&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____4&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180312] NSBlockOperationRun_____3&lt;NSThread: 0x604000271040&gt;&#123;number = 4, name = (null)&#125; GCD[43700:9180313] NSBlockOperationRun_____2&lt;NSThread: 0x604000270d00&gt;&#123;number = 3, name = (null)&#125;- (void)invocationOperSel&#123; NSLog(@\"NSInvocationOperationRun_%@\",[NSThread currentThread]);&#125; 总结:NSOperationQueue在没指定最大并发数的情况下默认是0，无限的，意思就是能开多少子线程就开多少子线程，所以MAX&gt;5的情况下，就是1-5随机排列，这种情况下优先级顺序不生效，因为能力太强不用考虑谁优先，大家都优先，都优先就随机.发现优先级低的任务会后执行，但是，这并不是绝对的，还有很多东西可以左右CPU分配，以及操作系统对于任务和线程的控制，只能说，优先级会在一定程度上让优先级高的任务开始执行。同时，优先级只对同一队列中的任务有效哦。 下面我们就再再再看一个会忽视优先级的情况。添加依赖之后，依赖任务必须等待被依赖任务执行完毕之后才会开始执行。就算依赖任务的优先级再高，也是被依赖任务先执行，同时，和优先级不同，依赖关系不受队列的局限，爱哪哪，只要是我依赖于你，那你必须先执行完，我才执行。 1234567891011121314151617NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *blockOper_1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 1000; i++) &#123; NSLog(@\"blockOper_1_%@_%@\",@(i),[NSThread currentThread]); &#125;&#125;];NSBlockOperation *blockOper_2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 1000; i++) &#123; NSLog(@\"blockOper_2_%@_%@\",@(i),[NSThread currentThread]); &#125;&#125;];[blockOper_1 addDependency:blockOper_2];[queue addOperation:blockOper_1];[queue addOperation:blockOper_2]; 队列的最大并发数 就是说，这个队列最多可以有多少任务同时执行，或者说最多开辟多少条线程，如果设置为1，那就一次只能执行一个任务，但是，不要以为这和GCD的串行队列一样，就算最大并发数为1，队列任务的执行顺序依然取决于很多因素。 关于NSOperationQueue还有取消啊，暂停啊等操作方式，大家可以试一下，应该注意的是，和学习GCD的方式不同，不要总是站在面向过程的角度看带这些面向对象的类，因为它的面相对象化的封装过程中，肯定有很多你看不到的面相过程的操作，所以你也没有必要用使用GCD的思想来套用它，否则你可能会迷糊的一塌糊涂。 取消线程：[operation cancel]; 取消队列中的所有线程:[operationQueue cancelAllOperations]; 挂起：[queue setSuspended:YES]; 恢复：[queue setSuspended:NO]; 等待某个操作:[operation waitUntilFinished];//注意：千万不要在主线程中执行这个 等待queue中的操作都完成:[queue waitUntilAllOperationsAreFinished];","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"利用Runtime解决NSArray越界等问题","slug":"利用Runtime解决NSArray越界等问题","date":"2016-10-08T08:23:48.000Z","updated":"2018-03-20T08:21:43.000Z","comments":true,"path":"2016/10/08/利用Runtime解决NSArray越界等问题/","link":"","permalink":"http://www.niu-chao.top/2016/10/08/利用Runtime解决NSArray越界等问题/","excerpt":"","text":"runtime 是 OC底层的一套C语言的API（引入 &lt;objc/runtime.h&gt; 或&lt;objc/message.h&gt;），编译器最终都会将OC代码转化为运行时代码，通过终端命令编译.m 文件： clang -rewrite-objc xxx.m 可以看到编译后的xxx.cpp（C++文件）。 比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象.cpp 文件 删除掉一些强制转换语句，可以看到调用方法本质就是发消息，[[NSObject alloc]init] 语句发了两次消息，第一次发了alloc 消息，第二次发送init 消息。利用这个功能我们可以探究底层，比如block的实现原理。 需要注意的是，使用 objc_msgSend() sel_registerName()方法需要导入头文件&lt;objc/message.h&gt; 利用Runtime解决NSArray和NSMutableArray数组越界的crash问题废话不多说，直接上代码，其实是很小的功能！！！首先给NSArray创建一个类别，Xcode -&gt; File -&gt; New -&gt; -&gt;File,然后在弹出的视图中选择 source目录下的 Objective-C file 选项，可以直接创建Empty FIle，Category，Protocol和Extension类型的文件，我们选择创建Category(类别文件)，class选择NSArray，名称填写为NSArray+Safe。 .h文件123456789101112#import &lt;Foundation/Foundation.h&gt;/** * 解决NSArray和NSMutableArray数组越界的crash问题，当debug模式下会crash报错方便调试，release模式下会返回nil */@interface NSArray (Safe)@end@interface NSMutableArray (Safe)@end .m文件在.m文件下import 运行文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#import \"NSArray+Safe.h\"#import &lt;objc/runtime.h&gt;@implementation NSArray (Safe)//这个方法无论如何都会执行，而且是最开始执行+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayI\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end@implementation NSMutableArray (SafetyArray)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayM\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end 解析以上代码逻辑主要是在最开始执行的load方法中，通过method_exchangeImplementations 函数去交换函数指针（OC中的方法实际上就是C的函数）IMP。 dispatch_once这里不是“单例”，是保证方法替换只执行一次. load 方法是可以当做类方法主动调用的,为的是避免这种情况.（在我的理解中load方法是被import了以后就会被调用）NSObject的load和initialize方法 方法替换”这种使用情况下,发现有两种写法. 其实也不是两种写法,准确的来说一种是比较严谨的,另一种则没有那么严谨. 发现这两种写法的差异后,我主要集中在下列: class_addMethodclass_replaceMethodmethod_exchangeImplementations 利用Runtime设置字体方法(方法替换的另一种写法—-严谨的写法).h文件12345@interface UIFont(Swizzle)+(void)load;@end .m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import \"UIfont+Swizzle.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation UIFont(Swizzle)+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [UIFont swizzleMethodOrginalMtd:@selector(systemFontOfSize:) newMtd:@selector(myFontOfSize:)]; [UIFont swizzleMethodOrginalMtd:@selector(boldSystemFontOfSize:) newMtd:@selector(myboldFontOfSize:)]; &#125;);&#125;+ (BOOL)swizzleMethodOrginalMtd:(SEL)origSelector newMtd:(SEL)altSelector&#123; Method origMethod = class_getClassMethod([self class], origSelector); if (nil == origMethod) &#123; return NO; &#125; Method altMethod = class_getClassMethod([self class], altSelector); if (nil == altMethod) &#123; return NO; &#125; BOOL didAddMethod = class_addMethod([self class], origSelector, method_getImplementation(altMethod), method_getTypeEncoding(altMethod)); if (didAddMethod) &#123; class_replaceMethod([self class], altSelector, method_getImplementation(origMethod), method_getTypeEncoding(origMethod)); &#125; else &#123; method_exchangeImplementations(origMethod, altMethod); &#125; return YES;&#125;+ (UIFont *)myFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName: @\"Avenir-Light\" size:fontSize];&#125;+ (UIFont *)myboldFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName:@\"Avenir-Medium\" size:fontSize];&#125; 说明:class_addMethod:如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现 1.如果返回成功:则说明被替换方法没有存在.也就是被替换的方法没有被实现,我们需要先把这个方法实现,然后再执行我们想要的效果,用我们自定义的方法去替换被替换的方法. 这里使用到的是class_replaceMethod 这个方法. class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了) 2.如果返回失败:则说明被替换方法已经存在.直接将两个方法的实现交换即可 另外: 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP我们可以利用 class_replaceMethod 来修改类我们可以利用 method_setImplementation 来直接设置某个方法的IMP 其实我们如果 研究过 AFN 代码的话,会发现, AFN 就是第二种写法.在AFURLSessionManager.m的第296行: 123456789static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; Runtime运行时添加属性，或者block属性知识点 key：要保证全局唯一，key与关联的对象是一一对应关系。必须全局唯一。通常用@selector(methodName)作为key。value：要关联的对象。policy：关联策略。有五种关联策略。OBJC_ASSOCIATION_ASSIGN 等价于 @property(assign)。OBJC_ASSOCIATION_RETAIN_NONATOMIC等价于 @property(strong, nonatomic)。OBJC_ASSOCIATION_COPY_NONATOMIC等价于@property(copy, nonatomic)。OBJC_ASSOCIATION_RETAIN等价于@property(strong,atomic)。OBJC_ASSOCIATION_COPY等价于@property(copy, atomic)。 .h123456789#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(id sender);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m1234567891011121314151617181920212223#import \"UIButton+Block.h\"#import &lt;objc/runtime.h&gt;@implementation UIButton (Block)- (void)handelWithBlock:(btnBlock)block &#123; if (block) &#123; objc_setAssociatedObject(self,@selector(btnAction:) , block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction:(id)sender&#123; btnBlock block = objc_getAssociatedObject(self,@selector(btnAction:)); if (block) &#123; block(sender); &#125;&#125;@end 注意：@selector(btnAction:) 部分是第二个参数 ;类型通常都是通常都是会采用静态变量static const char btnKey 来作为关键字 &amp;btnkey ,也可以使用”@selector(btnAction:) “。 第二个参数进一步优化，出现了_cmd 代替了 &amp;btnKey 或者 @selector(methodName). 因为： _cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例. 这里强调当前，_cmd的作用域只在当前方法里，直指当前方法名@selector。** Runtime 动态添加方法 OC的方法有哪几部分组成,在我的博客中反复强调的. SEL:方法编号 IMP:方法实现 (指向一个函数的指针) Class 源码可以查看objc_method_list方法定义的链表 本质是一个有 objc_method元素的可变长度的数组。一个 objc_method 结构体中有SEL，表示函数类型的字符串以及函数的实现IMP objc_method_list就好比一本书,SEL是标题,IMP是页码,真正的内容就是IMP指针指向的区域; struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !OBJC2 Class _Nullable super_class OBJC2_UNAVAILABLE; const char _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list _Nullable ivars OBJC2_UNAVAILABLE; //该类的成员变量链表 struct objc_method_list _Nullable _Nullable methodLists OBJC2_UNAVAILABLE; //方法定义的链表 struct objc_cache _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list _Nullable protocols OBJC2_UNAVAILABLE; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject- (void)eatWith:(NSString *)food;@end@implementation Person//记住:这个是动态添加一个类方法+ (BOOL)resolveClassMethod:(SEL)sel&#123;// 动态添加eat方法,IMP再有参数的情况下需要强转(IMP) class_addMethod(self, sel, (IMP)eat, \"v@:@\"); return [super resolveClassMethod:sel];&#125;//记住:这个是动态添加一个实例方法+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; // 动态添加eat方法,IMP再有参数的情况下需要强转(IMP) class_addMethod(self, sel, (IMP)eat, \"v@:@\"); return [super resolveInstanceMethod:sel];&#125;////OC中方法的调用里面有两个隐藏的参数！！！ 1、id self 2、SEL _cmd//***要想获得第三个参数的值必须在参数列表中补齐 id self,SEL _cmdvoid eat(id self,SEL _cmd, NSString *food)&#123; NSLog(@\"我今天吃了%@,倍儿开心!!!\",food);&#125;@end#import \"ViewController.h\"#import \"Person.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; [p eatWith:@\"火烧\"];&#125;","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://www.niu-chao.top/tags/Runtime/"}]},{"title":"Block与链式编程","slug":"Block与链式编程","date":"2016-09-21T06:12:57.000Z","updated":"2018-03-23T10:28:30.000Z","comments":true,"path":"2016/09/21/Block与链式编程/","link":"","permalink":"http://www.niu-chao.top/2016/09/21/Block与链式编程/","excerpt":"","text":"Block关于block代码块格式省略的小问题! 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; //block? 直接打块代码:inlinBlock,会在block实现中省略返回类型 id(^blockA)(void) = ^id(void) &#123; NSLog(@\"这一个BlockA\"); //return @\"......\"; return nil;//在block实现中因为省略了返回类型,所以返回一个nil会直接报错,要在实现中加上: ^id(void)&#123;&#125; 这段代码中的返回类型:id &#125;; NSLog(@\"%@\",blockA());&#125; Block应用场景123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 //1.对象的属性!示例 - (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc]init]; _p.eat = ^()&#123;//这个是实现 NSLog(@\"这是一个对象中的Block!!!\"); &#125;; //_p.eat();//block应用场景1:调用对象的属性block &#125; //2.方法的参数!示例 - (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc] init]; [_p eat:^&#123; NSLog(@\"吃火烧\"); &#125;]; //在这个思考一下使用block回调的与使用代理有什么区别呢?? //Block:1.解耦性强 2.如果封装的好,对于P对象是没有什么影响的; //代理:1.需要设置代理 2.遵守p对象的协议 3.在下面实现代理方法(需要脱离这个函数体) &#125;//编程思想: 响应式--函数式--链式//AFN网络回调 ---响应式 : 代理 通知 KVO//思考一下网络回调用代理怎么做呢?以下为思考过程//设置代理 AFNetworking.delegate = self;//遵守协议//需要的代理方法? ---请求数据成功!! 请求数据失败!! 监听数据下载进度!! //3.作为方法的返回值!- (void)viewDidLoad &#123; [super viewDidLoad]; _p = [[Niuchao alloc] init]; //我们写了一个普通的方法,直接调用; //[_p run:10]; //现在我们思考Masonry的链式编程,我们如何让方法这样调用呢:_p.run(10); //首先能够使用点语法的是不是setter和getter方法 //因为我这里是是要拿出来在执行block,那我们使用getter方法,特点:1.有返回值 2.没有参数 //_p.run 现在我们已经用getter点出方法了,那么怎么加上(10)一个参数呢,我们将get方法返回值设置为一个Block; //_p.run(100);这个方法分解后: 1.void(^blocka)(int m) = _p.run; // 2.blocka(100); //链式编程思想:直接将方法的block返回值变成Niuchao *类型 //_p.run(3).run(3).run(3);//这样就执行了三遍run方法 _p.run(1000).sleep(10);&#125;.h@interface Niuchao : NSObject//block ARC:可以使用Strong MRC:必须使用Copy//block的应用场景:1.对象的属性//@property(nonatomic, strong) void(^eat)();//block的应用场景:2.方法的参数//- (void)eat:(void(^)(void))block;////block的应用场景:3.方法的返回值//- (void)run:(int)m;//- (int)run;//- (void(^)(int))run;//链式编程思想:当我们上面的方法的block返回值变成Niuchao *类型- (Niuchao * (^)(int))run;- (void(^)(int))sleep;@end.m@implementation Niuchao//block的应用场景:2.方法的参数- (void)eat:(void (^)(void))block&#123; block(); //如果用Block做参数的话我们一般会怎么做? //1.保存这个block; //2.做一些特定的事情,比如网络请求数据并解析; //3.然后得到结果,将结果给block&#125;//block的应用场景:3.作为方法的返回值!- (void (^)(int))run&#123; return ^(int m)&#123; NSLog(@\"我跑了%d\",m); &#125;;&#125;//链式编程思想:当我们上面的方法的block返回值变成Niuchao *类型时直接在block的实现中返回self- (Niuchao * (^)(int))run&#123; return ^(int m)&#123; NSLog(@\"我跑了%d米\",m); return self; &#125;;&#125;- (void (^)(int))sleep&#123; return ^(int h)&#123; NSLog(@\"我又休息了%d小时\",h); &#125;;&#125;@end 链式编程示例Masonry编程思想分析 self.view.backgroundColor = [UIColor whiteColor]; UIView *red = [[UIView alloc] init]; red.backgroundColor = [UIColor redColor]; [self.view addSubview:red]; mas设置约束 [red mas_makeConstraints:^(MASConstraintMaker *make) { make.left.top.equalTo(@20); make.right.bottom.equalTo(@-20); }]; mas_makeConstraints 会重置约束 //将Autoresizing设置为NO,重置约束 self.translatesAutoresizingMaskIntoConstraints = NO; 1.创建了一个Maker 绑定了View; 2.在里面创建了一个空的可变数组. MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; 3.将Maker执行block传出来了,就是我们外面使用的make block(constraintMaker); 4.让Maker安装约束 return [constraintMaker install]; // 清空之前所有的约束 遍历约束数组,一个一个设置安装 5.通过Maker进行设置约束,并添加到约束数组里面 make.left.top. 创建一个NSObject的分类1234567891011121314151617181920212223242526272829.h#import &lt;Foundation/Foundation.h&gt;#import \"SumManager.h\"@interface NSObject (Sum)//我们学习Masonry的样子写一个方法,Masonry方法中有带maker类型参数的Block,我们再设置一个sumManager- (int)NC_MakeSum:(void(^)(SumManager *manager))block;@end.m#import \"NSObject+Sum.h\"@implementation NSObject (Sum)- (int)NC_MakeSum:(void (^)(SumManager *))block&#123; //我们想一想这里面是实现,首先方法参数是一个带有SumManager参数的block,所以我们在调用Block的时候需要传递一个SumManager,好,去创建; SumManager *sumManager = [[SumManager alloc] init]; //我们不管外面用sumManager怎么操作,我们只管把sumManager对象传出去, block(sumManager); //*****通过上面的block调用,用户就会去执行add等一系列方法,等待sumManager里面都操作完了我们直接通过方法返回结果; return sumManager.result;&#125;@end 在创建一个管理类:SumManager 1234567891011121314151617181920212223242526272829303132333435.h#import &lt;Foundation/Foundation.h&gt;@class SumManager;typedef SumManager *(^block)(int value);@interface SumManager : NSObject@property(nonatomic,assign) int result;- (SumManager *(^)(int value))add;- (block)reduce;@end.m@implementation SumManager- (SumManager *(^)(int))add&#123; return ^(int value)&#123; _result += value;//将值通过属性保存起来 return self; //返回block的返回值 &#125;;&#125;- (block)reduce&#123; return ^(int value)&#123; _result -= value; return self; &#125;;&#125;@end 执行测试1234567891011121314151617181920@interface MasonryViewController ()@end@implementation MasonryViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int a = 9999; int b = 1; int result = [self NC_MakeSum:^(SumManager *manager) &#123; //这里我们需要在SumManager设置他的add方法,如何想通masonry一样使用; //首先add是个getter方法,然后返回值是个block; //其次如果继续使用点语法,那block也得有返回值,而且这个返回值是SumManager本身类型的类 manager.add(a).reduce(b); &#125;]; NSLog(@\"+a -b =%d\",result);&#125; 代码中注释就是我个人理解","categories":[],"tags":[{"name":"RunLoop","slug":"RunLoop","permalink":"http://www.niu-chao.top/tags/RunLoop/"}]},{"title":"IOS-锁","slug":"IOS-锁","date":"2016-07-08T06:15:22.000Z","updated":"2018-03-13T12:25:47.000Z","comments":true,"path":"2016/07/08/IOS-锁/","link":"","permalink":"http://www.niu-chao.top/2016/07/08/IOS-锁/","excerpt":"","text":"在平时的开发中经常使用到多线程，在使用多线程的过程中，难免会遇到资源竞争的问题，那我们怎么来避免出现这种问题那？ 线程安全是什么？ 当一个线程访问数据的时候，其他的线程不能对其进行访问，直到该线程访问完毕。简单来讲就是在同一时刻，对同一个数据操作的线程只有一个。只有确保了这样，才能使数据不会被其他线程影响。而线程不安全，则是在同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果。 比如写文件和读文件，当一个线程在写文件的时候，理论上来说，如果这个时候另一个线程来直接读取的话，那么得到的结果可能是你无法预料的。 怎么来保证线程安全？ 通常我们使用锁的机制来保证线程安全，即确保同一时刻只有同一个线程来对同一个数据源进行访问。 @synchronized@synchronized是 iOS 中最常见的锁，用法很简单： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; [self synchronized];&#125; - (void)synchronized &#123; NSObject * cjobj = [NSObject new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(cjobj)&#123; NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); @synchronized(cjobj)&#123; NSLog(@\"线程2\"); &#125; &#125;);&#125; 控制台输出：12311:35:13.459194+0800 Thread-Lock[24855:431100] 线程1开始11:35:16.460210+0800 Thread-Lock[24855:431100] 线程1结束11:35:16.460434+0800 Thread-Lock[24855:431101] 线程2 解析从上面的控制台输出时间可以看出来，在线程 1 内容全部输出之后，才输出了线程 2 的内容，“线程1结束”与“线程2”都是在“线程1开始”3 秒后输出的。 @synchronized(cjobj) 指令使用的 cjobj 为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程 2 中的 @synchronized(cjobj) 改为 @synchronized(self) ，那么线程 2就不会被阻塞，@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 @sychronized(cjobj){} 内部 cjobj 被释放或被设为 nil 不会影响锁的功能，但如果 cjobj 一开始就是 nil，那就会丢失了锁的功能了。 这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 NSLock先看看iOS中NSLock类的.h文件，从代码中可以看出，该类分成了几个子类：NSLock、NSConditionLock、NSRecursiveLock、NSCondition，然后有一个 NSLocking&gt;协议： 1234@protocol NSLocking- (void)lock;- (void)unlock;@end 虽然 NSLock、NSConditionLock、NSRecursiveLock、NSCondition 都遵循的了 NSLocking 协议，但是它们并不相同。 NSLock 实现了最基本的互斥锁，遵循了 NSLocking 协议，通过 lock 和 unlock 来进行锁定和解锁。 源码1234567891011@interface NSLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; [self nslock];&#125; - (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lock]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;);&#125;控制台输出： 15:03:58.868708+0800 Thread-Lock[39059:846493] 线程1加锁成功 15:04:00.872714+0800 Thread-Lock[39059:846493] 线程1解锁成功 15:04:00.872722+0800 Thread-Lock[39059:846492] 线程2加锁成功 15:04:00.873000+0800 Thread-Lock[39059:846492] 线程2解锁成功 1234567891011121314151617181920212223242526- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock tryLock]) &#123; NSLog(@\"线程3加锁成功\"); [cjlock unlock]; NSLog(@\"线程3解锁成功\"); &#125;else &#123; NSLog(@\"线程3加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:05:38.627767+0800 Thread-Lock[39118:849171] 线程1加锁成功 15:05:38.627767+0800 Thread-Lock[39118:849169] 线程3加锁失败 15:05:40.629969+0800 Thread-Lock[39118:849171] 线程1解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(3); if ([cjlock tryLock]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlock]; NSLog(@\"线程4解锁成功\"); &#125;else &#123; NSLog(@\"线程4加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:07:14.872279+0800 Thread-Lock[39166:851060] 线程1加锁成功 15:07:16.876108+0800 Thread-Lock[39166:851060] 线程1解锁成功 15:07:17.876208+0800 Thread-Lock[39166:851052] 线程4加锁成功 15:07:17.876527+0800 Thread-Lock[39166:851052] 线程4解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程5加锁成功\"); [cjlock unlock]; NSLog(@\"线程5解锁成功\"); &#125;else &#123; NSLog(@\"线程5加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:08:39.705131+0800 Thread-Lock[39204:852782] 线程1加锁成功 15:08:41.708717+0800 Thread-Lock[39204:852782] 线程1解锁成功 15:08:41.708717+0800 Thread-Lock[39204:852784] 线程5加锁成功 15:08:41.708935+0800 Thread-Lock[39204:852784] 线程5解锁成功注意：lock与unlock操作必须在同一线程，否则结果不确定甚至会引起死锁 解析： 除 lock 和 unlock 方法外，NSLock 还提供了 tryLock 和 lockBeforeDate:两个方法。 由上面的结果可以看到 tryLock 并不会阻塞线程，[cjlock tryLock] 能加锁返回 YES，不能加锁返回 NO，然后都会执行后续代码。 这里顺便提一下 trylock 和 lock 使用场景：当前线程锁失败，也可以继续其它任务，用 trylock 合适；当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock。以下的锁都是这样。 lockBeforeDate: 方法会在所指定 Date 之前尝试加锁，会阻塞线程，如果在指定时间之前都不能加锁，则返回 NO，指定时间之前能加锁，则返回 YES。 由于是互斥锁，当一个线程进行访问的时候，该线程获得锁，其他线程进行访问的时候，将被操作系统挂起，直到该线程释放锁，其他线程才能对其进行访问，从而却确保了线程安全。但是如果连续锁定两次，则会造成死锁问题。 NSRecursiveLockNSRecursiveLock 是递归锁，顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 源码：1234567891011@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsrecursivelock];&#125; - (void)nsrecursivelock&#123; NSRecursiveLock * cjlock = [[NSRecursiveLock alloc] init]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; [cjlock lock]; NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value:%d\", value); RecursiveBlock(value - 1); &#125; [cjlock unlock]; NSLog(@\"%d解锁成功\",value); &#125;; RecursiveBlock(3); &#125;);&#125;控制台输出： 16:15:40.584213+0800 Thread-Lock[39579:894111] 3加锁成功 16:15:40.584387+0800 Thread-Lock[39579:894111] value:3 16:15:40.584552+0800 Thread-Lock[39579:894111] 2加锁成功 16:15:40.584635+0800 Thread-Lock[39579:894111] value:2 16:15:40.584810+0800 Thread-Lock[39579:894111] 1加锁成功 16:15:40.585267+0800 Thread-Lock[39579:894111] value:1 16:15:40.585714+0800 Thread-Lock[39579:894111] 0加锁成功 16:15:40.585906+0800 Thread-Lock[39579:894111] 0解锁成功 16:15:40.586138+0800 Thread-Lock[39579:894111] 1解锁成功 16:15:40.586217+0800 Thread-Lock[39579:894111] 2解锁成功 16:15:40.586314+0800 Thread-Lock[39579:894111] 3解锁成功 解析 如果用 NSLock 的话，cjlock 先锁上了，但未执行解锁的时候，就会进入递归的下一层，而再次请求上锁，阻塞了该线程，线程被阻塞了，自然后面的解锁代码不会执行，而形成了死锁。而 NSRecursiveLock 递归锁就是为了解决这个问题。 NSConditionLock NSConditionLock 对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁，它和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock、tryLockWhenCondition:，所以 NSConditionLock 可以称为条件锁。 只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。 unlockWithCondition: 并不是当 condition 符合条件时才解锁，而是解锁之后，修改 condition 的值。 源码123456789101112131415161718@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER; @property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsconditionlock];&#125; - (void)nsconditionlock &#123; NSConditionLock * cjlock = [[NSConditionLock alloc] initWithCondition:0]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(1); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lockWhenCondition:1]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(2); if ([cjlock tryLockWhenCondition:0]) &#123; NSLog(@\"线程3加锁成功\"); sleep(2); [cjlock unlockWithCondition:2]; NSLog(@\"线程3解锁成功\"); &#125; else &#123; NSLog(@\"线程3尝试加锁失败\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockWhenCondition:2 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlockWithCondition:1]; NSLog(@\"线程4解锁成功\"); &#125; else &#123; NSLog(@\"线程4尝试加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:09:44.010992+0800 Thread-Lock[39230:853946] 线程1加锁成功 15:09:45.012045+0800 Thread-Lock[39230:853946] 线程1解锁成功 15:09:46.012692+0800 Thread-Lock[39230:853947] 线程3加锁成功 15:09:48.016536+0800 Thread-Lock[39230:853947] 线程3解锁成功 15:09:48.016564+0800 Thread-Lock[39230:853944] 线程4加锁成功 15:09:48.017039+0800 Thread-Lock[39230:853944] 线程4解锁成功 15:09:48.017040+0800 Thread-Lock[39230:853945] 线程2加锁成功 15:09:48.017215+0800 Thread-Lock[39230:853945] 线程2解锁成功 解析 在线程 1 解锁成功之后，线程 2 并没有加锁成功，而是继续等了 1 秒之后线程 3 加锁成功，这是因为线程 2 的加锁条件不满足，初始化时候的 condition 参数为 0，而线程 2加锁条件是 condition 为 1，所以线程 2 加锁失败。 lockWhenCondition 与 lock 方法类似，加锁失败会阻塞线程，所以线程 2 会被阻塞着。 tryLockWhenCondition: 方法就算条件不满足，也会返回 NO，不会阻塞当前线程。 lockWhenCondition:beforeDate:方法会在约定的时间内一直等待 condition 变为 2，并阻塞当前线程，直到超时后返回 NO。 锁定和解锁的调用可以随意组合，也就是说 lock、lockWhenCondition:与unlock、unlockWithCondition: 是可以按照自己的需求随意组合的。 NSCondition NSCondition 是一种特殊类型的锁，通过它可以实现不同线程的调度。一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。比如说，你可以开启一个线程下载图片，一个线程处理图片。这样的话，需要处理图片的线程由于没有图片会阻塞，当下载线程下载完成之后，则满足了需要处理图片的线程的需求，这样可以给定一个信号，让处理图片的线程恢复运行。 NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，如果进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 NSCondition 可以手动控制线程的挂起与唤醒，可以利用这个特性设置依赖。 源码12345678910111213@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (void)wait; //挂起线程- (BOOL)waitUntilDate:(NSDate *)limit; //什么时候挂起线程- (void)signal; // 唤醒一条挂起线程- (void)broadcast; //唤醒所有挂起线程 @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)viewDidLoad &#123; [super viewDidLoad]; [self nscondition];&#125; - (void)nscondition &#123; NSCondition * cjcondition = [NSCondition new]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程1线程加锁\"); [cjcondition wait]; NSLog(@\"线程1线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程1线程解锁\"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程2线程加锁\"); if ([cjcondition waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程2线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程2线程解锁\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition signal]; &#125;);&#125;控制台输出： 17:15:48.410316+0800 Thread-Lock[40011:943638] 线程1线程加锁 17:15:48.410757+0800 Thread-Lock[40011:943640] 线程2线程加锁 17:15:50.414288+0800 Thread-Lock[40011:943638] 线程1线程唤醒 17:15:50.414454+0800 Thread-Lock[40011:943638] 线程1线程解锁//如果 [cjcondition signal]; 改成 [cjcondition broadcast]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition broadcast]; &#125;);控制台输出： 17:18:08.054109+0800 Thread-Lock[40056:946099] 线程1线程加锁 17:18:08.054304+0800 Thread-Lock[40056:946096] 线程2线程加锁 17:18:10.056071+0800 Thread-Lock[40056:946099] 线程1线程唤醒 17:18:10.056231+0800 Thread-Lock[40056:946099] 线程1线程解锁 17:18:10.056244+0800 Thread-Lock[40056:946096] 线程2线程唤醒 17:18:10.056445+0800 Thread-Lock[40056:946096] 线程2线程解锁 解析 在加上锁之后，调用条件对象的 wait 或 waitUntilDate: 方法来阻塞线程，直到条件对象发出唤醒信号或者超时之后，再进行之后的操作。signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。 dispatch_semaphoredispatch_semaphore 使用信号量机制实现锁，等待信号和发送信号。 dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的只有三个函数，一个是创建信号量，一个是等待信号，一个是发送信号。dispatch_semaphore 的机制就是当有多个线程进行访问的时候，只要有一个获得了信号，其他线程的就必须等待该信号释放。 常用相关API：123dispatch_semaphore_create(long value);dispatch_semaphore_wait(dispatch_semaphore_t _Nonnull dsema, dispatch_time_t timeout);dispatch_semaphore_signal(dispatch_semaphore_t _Nonnull dsema); 用法：12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; [self dispatch_semaphore];&#125; - (void)dispatch_semaphore &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 6 * NSEC_PER_SEC); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程1开始\"); sleep(5); NSLog(@\"线程1结束\"); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程2开始\"); dispatch_semaphore_signal(semaphore); &#125;);&#125;控制台输出： 18:30:37.672490+0800 Thread-Lock[40569:993613] 线程1开始 18:30:42.673845+0800 Thread-Lock[40569:993613] 线程1结束 18:30:42.674165+0800 Thread-Lock[40569:993612] 线程2开始//如果 overTime 改成 3 秒控制台输出： 18:32:32.078186+0800 Thread-Lock[40634:995921] 线程1开始 18:32:35.082943+0800 Thread-Lock[40634:995920] 线程2开始 18:32:37.083115+0800 Thread-Lock[40634:995921] 线程1结束 解析 dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。 dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。 dispatch_semaphore_wait(semaphore, overTime); 方法会判断 semaphore 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime 时限到了，也会执行后续任务。 dispatch_semaphore_signal(semaphore); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。 一个 dispatch_semaphore_wait(semaphore, overTime); 方法会去对应一个 dispatch_semaphore_signal(semaphore); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区。 pthread_mutex 与 pthread_mutex(recursive) pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，POSIX 互斥锁是一种超级易用的互斥锁，使用的时候： 只需要使用 pthread_mutex_init 初始化一个 pthread_mutex_t，pthread_mutex_lock 或者 pthread_mutex_trylock 来锁定 ，pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。 常用相关API：12345pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable);pthread_mutex_lock(pthread_mutex_t * _Nonnull);pthread_mutex_trylock(pthread_mutex_t * _Nonnull);pthread_mutex_unlock(pthread_mutex_t * _Nonnull);pthread_mutex_destroy(pthread_mutex_t * _Nonnull); 用法：pthread_mutex123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex];&#125; - (void)pthread_mutex &#123; __block pthread_mutex_t cjlock; pthread_mutex_init(&amp;cjlock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); pthread_mutex_unlock(&amp;cjlock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程2\"); pthread_mutex_unlock(&amp;cjlock); &#125;);&#125;控制台输出： 14:50:29.842180+0800 Thread-Lock[74478:1647362] 线程1开始 14:50:32.846786+0800 Thread-Lock[74478:1647362] 线程1结束 14:50:32.847001+0800 Thread-Lock[74478:1647359] 线程2 pthread_mutex(recursive) 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex_recursive];&#125; - (void)pthread_mutex_recursive &#123; __block pthread_mutex_t cjlock; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;cjlock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value = %d\", value); sleep(1); RecursiveBlock(value - 1); &#125; NSLog(@\"%d解锁成功\",value); pthread_mutex_unlock(&amp;cjlock); &#125;; RecursiveBlock(3); &#125;);&#125;//控制台输出： 15:31:51.599693+0800 Thread-Lock[74723:1668089] 3加锁成功 15:31:51.599912+0800 Thread-Lock[74723:1668089] value = 3 15:31:52.602002+0800 Thread-Lock[74723:1668089] 2加锁成功 15:31:52.602317+0800 Thread-Lock[74723:1668089] value = 2 15:31:53.604669+0800 Thread-Lock[74723:1668089] 1加锁成功 15:31:53.604957+0800 Thread-Lock[74723:1668089] value = 1 15:31:54.607778+0800 Thread-Lock[74723:1668089] 0加锁成功 15:31:54.608109+0800 Thread-Lock[74723:1668089] 0解锁成功 15:31:54.608391+0800 Thread-Lock[74723:1668089] 1解锁成功 15:31:54.608622+0800 Thread-Lock[74723:1668089] 2解锁成功 15:31:54.608945+0800 Thread-Lock[74723:1668089] 3解锁成功 解析 它的用法和 NSLock 的 lock unlock 用法一致，而它也有一个 pthread_mutex_trylock 方法，pthread_mutex_trylock 和 tryLock 的区别在于，tryLock 返回的是 YES 和 NO，pthread_mutex_trylock 加锁成功返回的是 0，失败返回的是错误提示码。 pthread_mutex(recursive) 作用和 NSRecursiveLock 递归锁类似。如果使用 pthread_mutex_init(&amp;theLock, NULL); 初始化锁的话，上面的代码的第二部分会出现死锁现象，使用递归锁就可以避免这种现象。 OSSpinLock OSSpinLock 是一种自旋锁，和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。 只有加锁，解锁，尝试加锁三个方法。 常用相关API：12345678typedef int32_t OSSpinLock; // 加锁void OSSpinLockLock( volatile OSSpinLock *__lock );// 尝试加锁bool OSSpinLockTry( volatile OSSpinLock *__lock );// 解锁void OSSpinLockUnlock( volatile OSSpinLock *__lock ); 用法：12345678910111213141516171819202122232425262728293031#import &lt;libkern/OSAtomic.h&gt; - (void)viewDidLoad &#123; [super viewDidLoad]; [self osspinlock];&#125; - (void)osspinlock &#123; __block OSSpinLock theLock = OS_SPINLOCK_INIT; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); OSSpinLockUnlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); sleep(1); NSLog(@\"线程2\"); OSSpinLockUnlock(&amp;theLock); &#125;);&#125;控制台输出： 16:02:48.865501+0800 Thread-Lock[75025:1684487] 线程1开始 16:02:51.868736+0800 Thread-Lock[75025:1684487] 线程1结束 16:02:52.922911+0800 Thread-Lock[75025:1684486] 线程2 YY大神 @ibireme 的文章也有说这个自旋锁存在优先级反转问题，具体文章可以戳 不再安全的 OSSpinLock，而 OSSpinLock 在iOS 10.0中被 中的 os_unfair_lock 取代。&gt; 介绍了 OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 os_unfair_lock 自旋锁已经不再安全，然后苹果又整出来个 os_unfair_lock，这个锁解决了优先级反转问题。 常用相关API：123456789// 初始化os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);// 加锁os_unfair_lock_lock(unfairLock);// 尝试加锁BOOL b = os_unfair_lock_trylock(unfairLock);// 解锁os_unfair_lock_unlock(unfairLock);os_unfair_lock 用法和 OSSpinLock 基本一直，就不一一列出了。 总结应当针对不同的操作使用不同的锁，而不能一概而论哪种锁的加锁解锁速度快。 其实每一种锁基本上都是加锁、等待、解锁的步骤，理解了这三个步骤就可以帮你快速的学会各种锁的用法。 @synchronized 的效率最低，不过它的确用起来最方便，所以如果没什么性能瓶颈的话，可以选择使用 @synchronized。 当性能要求较高时候，可以使用 pthread_mutex 或者 dispath_semaphore，由于 OSSpinLock 不能很好的保证线程安全，而在只有在 iOS10 中才有 os_unfair_lock ，所以，前两个是比较好的选择。既可以保证速度，又可以保证线程安全。 对于 NSLock 及其子类，速度来说 NSLock &lt; NSCondition &lt; NSRecursiveLock &lt; NSConditionLock 。&gt;","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"IOS关于内存的一些分析","slug":"IOS关于内存分析","date":"2016-04-09T10:44:32.000Z","updated":"2018-03-20T08:43:27.000Z","comments":true,"path":"2016/04/09/IOS关于内存分析/","link":"","permalink":"http://www.niu-chao.top/2016/04/09/IOS关于内存分析/","excerpt":"","text":"堆栈内存条,我们去操作可读可写的部分,怎么划分堆和栈呢?如果说直接规定一块内存地址为堆,一块内存地址是栈,这样行不行?首先是可以,其次是不好,到底谁应该分配的多一些呢?所以我们不知道谁应该分配的多一些,那么就给它一个弹性划分 创建的对象是放在堆还是栈??对象(结构体数据)放在堆区,假如它的起始地址在堆里面是0xff6543占用四个字节的话,那么它的结束地址是多少,是从高到低还是从低到高?结论：它是从低地址往高地址走的那么就是0xfff6547; 相反在栈区上存储的是对象的起始地址也就是指针,它的地址存储是从高到底的!!!!! 对象 (结构体)通过malloc开辟一段堆空间,返回一个指针地址,就是栈区存放的指针地址; malloc(开辟大小) =相对应= free(放个指针) free(指针):单纯的使用free(传入一个栈空间的地址指针) ,它就会把指针所指向的堆空间释放,但是存在于栈空间中的地址指针不会被释放,所以就会造成野指针 ARC环境:一个存在于栈区的对象指针object,假如是个局部变量,那么在一个方法(即函数)结束后就会被自动释放; 内存泄漏:MRC环境下,如果存在于栈空间的指针地址被销毁了,但是堆空间的数据还没被释放,那么就会造成内存浪费,因为没有地址指向它了,不会被调用了,但系统认为它一直有用不会被释放,所以它就浪费了一段堆空间,造成内存泄漏;野指针:单纯的使用free(传入一个栈空间的地址指针) ,它就会把指针所指向的堆空间释放,但是存在于栈空间中的地址指针不会被释放,当再次访问这个指针时,所以就会造成野指针. C语言的结构体指针与结构体数据的释放CFRunLoopObserverRef observer = CFRunLoopObserverCreate(省略) 怎么释放一个指针?把它指向一个空地址就行了,但是单纯的释放指针而不处理堆空间就会造成内存泄漏,就会引出下面的问题(结构体的释放?)observer = nil; 结构体的释放？C语言中但凡是看到 Create, new , copy ,都会默认开辟对空间就是(malloc),这里返回一个结构体指针,指向这个在堆区中的结构体,那么这个&gt;&gt;&gt;&gt;&gt;&gt;结构体如何释放呢???CFRunLoopObserverRef observer = CFRunLoopObserverCreate 苹果为什么会提供一个CFReleasefree(observer);//这个可不可以释放???CFRelease(observer);//这个又可以不可以呢???? 针对这个问题分析一下,这个结构体里面有哪些数据呢??????? 我们不知道,既然不知道,是不是结构体里面会有可能再次开辟一块堆空间,就是说结构体里面的数据是不是可以再次存一个开辟堆空间的指针,答案是的; 既然我们知道结构体里面可能会存有一个开辟了堆空间的指针的话,那么我们回到上面的问题直接用free(observer)去释放observer所指向的堆空间(结构体)就是不可以的,因为会直接将observer所指向的结构体释放掉’包含’里面的二次指针,而不会去处理’二次’指针开辟的堆空间….,就会造成结构体里面二次开辟的堆空间的内存泄漏(内存浪费),因为它的指针已经被free(observer)释放了…..哈哈哈哈对不对!!!!!! 所以结论就是只能用CFRelease(observer),因为CFRelease拿到这个结构体指针后知道它又开辟了那些堆空间,就会去处理干净,先把结构体里面的二次指针所指向的二次堆空间释放掉,然后再释放结构体. 这个例子类似于dealloc{}这个方法,就在再Viewcontroller要被释放之前,先去清空开辟了的二次堆区域…. 123- (void)dealloc&#123;&#125; Autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。 函数调用栈OC方法的本质 == C函数,其中有个概念叫函数调用栈 栈平衡(占内存的释放),一个函数调用完毕,栈内存就会被释放 object本质 === 指针 —-&gt; 它指向一个对象,对象 === 结构体数据那么一个指针在栈区域占用多少字节,和操作系统32位和64位有关系—&gt;32占4个—&gt;64占8个 NSObject * object = [[NSObject alloc] init];object是个局部变量,它存在于ViewDidLoad大括号中的函数体里面,一个函数调用完毕,栈内存就会被释放NSLog(@”%@”,object); 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)viewDidLoad &#123; [super viewDidLoad];// 死循环 这个不会崩溃 while (true) &#123; 测试随便调用一个方法 [self didReceiveMemoryWarning]; &#125;// 这个会崩溃会造成内存不够,堆栈溢出 [self viewDidLoad];// 栈平衡(占内存的释放),一个函数调用完毕,栈内存就会被释放// sp :指向栈顶! 类似栈顶指针,有些函数有 ,而有些函数没有,// 当这个方法(函数)调用时,就会将sp指针往下减,下面是打断点查看汇编代码(如果看不到可以在菜单DEbug-&gt;Debug Workflow-&gt;Show Disassembly 设置).// 内存`-[ViewController viewDidLoad]:// 0x10e344690 &lt;+0&gt;: pushq %rbp //push入栈空间// 0x10e344691 &lt;+1&gt;: movq %rsp, %rbp// 0x10e344694 &lt;+4&gt;: subq $0x20, %rsp //sub代表减, 0x20十六进制32,表示让sp减32个字节,开辟一段栈空间// 0x10e344698 &lt;+8&gt;: leaq -0x20(%rbp), %rax// 0x10e34469c &lt;+12&gt;: movq %rdi, -0x8(%rbp)// 0x10e3446a0 &lt;+16&gt;: movq %rsi, -0x10(%rbp)// -&gt; 0x10e3446a4 &lt;+20&gt;: movq -0x8(%rbp), %rsi// 0x10e3446a8 &lt;+24&gt;: movq %rsi, -0x20(%rbp)// 0x10e3446ac &lt;+28&gt;: movq 0x260d(%rip), %rsi ; (void *)0x000000010e346cd0: ViewController// 0x10e3446b3 &lt;+35&gt;: movq %rsi, -0x18(%rbp)// 0x10e3446b7 &lt;+39&gt;: movq 0x25da(%rip), %rsi ; \"viewDidLoad\"// 0x10e3446be &lt;+46&gt;: movq %rax, %rdi// 0x10e3446c1 &lt;+49&gt;: callq 0x10e344a52 ; symbol stub for: objc_msgSendSuper2// 0x10e3446c6 &lt;+54&gt;: addq $0x20, %rsp //add代表加, 0x20十六进制32,表示让sp加32个字节,回复一段栈空间// 0x10e3446ca &lt;+58&gt;: popq %rbp// 0x10e3446cb &lt;+59&gt;: retq //ret出栈之前又加回来了// 但是什么函数不会有栈空间呢------叶子函数:最后一个函数,不会再去调用其他函数,下面举个栗子!!! printf(\"niuchao\");//**************以上的例子就解释了 为什么递归会造成内存不够溢出的原因了....因为会一直去调用栈空间,无法完成栈平衡******************&#125;","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"Markdown","slug":"MarkDown","date":"2015-10-08T05:24:22.000Z","updated":"2018-03-07T06:58:46.000Z","comments":true,"path":"2015/10/08/MarkDown/","link":"","permalink":"http://www.niu-chao.top/2015/10/08/MarkDown/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0):'''A docstring'''if param1 &gt; param2: # interestingprint 'Greater'return (param2 - param1 + 1) or Noneclass SomeClass:pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.niu-chao.top/tags/Markdown/"}]},{"title":"一头驮砖的牛博客","slug":"一头驮砖的牛博客","date":"2014-10-08T03:53:46.000Z","updated":"2018-03-13T12:27:49.000Z","comments":true,"path":"2014/10/08/一头驮砖的牛博客/","link":"","permalink":"http://www.niu-chao.top/2014/10/08/一头驮砖的牛博客/","excerpt":"","text":"","categories":[],"tags":[]}]}