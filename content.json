{"meta":{"title":"一头驮砖的牛","subtitle":null,"description":"关注 Ios | Python 开发","author":null,"url":"http://www.niu-chao.top"},"pages":[{"title":"分类","date":"2017-03-02T04:33:16.000Z","updated":"2018-03-13T10:17:12.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.niu-chao.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-14T03:54:25.000Z","updated":"2018-03-13T10:17:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.niu-chao.top/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-13T09:55:52.000Z","updated":"2018-03-13T10:17:04.000Z","comments":true,"path":"about/index.html","permalink":"http://www.niu-chao.top/about/index.html","excerpt":"","text":""}],"posts":[{"title":"浅析KVO原理以及自己完成简单的KVO代码实现","slug":"浅析KVO原理以及自己完成简单的KVO分类","date":"2017-03-18T09:44:48.000Z","updated":"2018-03-13T12:13:00.000Z","comments":true,"path":"2017/03/18/浅析KVO原理以及自己完成简单的KVO分类/","link":"","permalink":"http://www.niu-chao.top/2017/03/18/浅析KVO原理以及自己完成简单的KVO分类/","excerpt":"","text":"KVO KVO 是 Objective-C 对观察者设计模式的一种实现。【另外一种是：通知机制（notification）】；KVO 提供一种机制，指定一个被观察对象(例如 A 类)，当对象某个属性(例如 A 中的字符串 name)发生更改时，对象会获得通知，并作出相应处理；【且不需要给被观察的对象添加任何额外代码，就能使用 KVO 机制】 在 MVC 设计架构下的项目，KVO 机制很适合实现 mode 模型和 view 视图之间的通讯。例如：代码中，在模型类A创建属性数据，在控制器中创建观察者，一旦属性数据发生改变就收到观察者收到通知，通过 KVO 再在控制器使用回调方法处理实现视图 B 的更新； 实现原理KVO 在 Apple 中的 API 文档如下： 1234 Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … KVO 的实现依赖于 Objective-C 强大的 Runtime，从以上 Apple 的文档可以看出苹果对于 KVO 机制的实现是一笔带过，而具体的细节没有过多的描述，关于KVO 机制的底层实现原理，从网上的一些关于 KVO 的资料总结了有关的内容： 基本原理 1、KVO是基于runtime机制实现的 2、当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制 3、如果原类为Person，那么生成的派生类名为NSKVONotifying_Person 4、每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法 5、键值观察通知依赖于NSObject 的两个方法:willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。 深度剖析 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；） 1、NSKVONotifying_A 类剖析：在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被 KVO 机制修改为指向系统新创建的子类 NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。（备注：isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。这也是 KVO 回调机制，为什么都俗称KVO技术为黑魔法的原因之一吧：内部神秘、外观简洁。 2、子类setter方法剖析：KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用 2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后，observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 相关特点 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @&quot;newName&quot;，这时是不会触发 KVO 机制，更加不会调用回调方法的。所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。 代码实现代码由ViewController（观察者）、NSObject+NCKVO（KVO实现）、NCperson（被观察者）、Dog（扩展类），几个类组成，分为五项代码线流程进行演示； ViewController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899.h#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@end.m#import \"ViewController.h\"#import \"NCperson.h\"#import \"NSObject+NCKVO.h\"#import &lt;objc/message.h&gt;/**拓展 NSKeyValueObservingOptionNew 返回新值 NSKeyValueObservingOptionOld 返回旧值 NSKeyValueObservingOptionInitial 注册的时候就会发一次通知，改变后也会发通知 NSKeyValueObservingOptionPrior 改变之前发一次，改变之后发一次 *//** 打印出的kind = 1 表示的为set方法 */@interface ViewController ()@property (nonatomic, strong) NCperson *p;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NCperson *person = [[NCperson alloc] init];// 一.系统方法添加观察者// [person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// [person addObserver:self forKeyPath:@\"dog.age\" options:NSKeyValueObservingOptionNew context:nil];// 三.观察内部属性(容器)dog类中的多个属性// [person addObserver:self forKeyPath:@\"dog\" options:NSKeyValueObservingOptionNew context:nil];// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// [person addObserver:self forKeyPath:@\"code\" options:NSKeyValueObservingOptionNew context:nil];// ********* 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加 [person NC_addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; _p = person;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; //五.传过来的object为子类（派生类），不知道正确不正确 NSLog(@\"成功通知到了新值：%@\",change);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static int a = 0;// 一.手动添加KVO (观察者类中关闭自动模式)，实现手动观察方法 will did ；// [_p willChangeValueForKey:@\"name\"];// _p.name = [NSString stringWithFormat:@\"%d\", a++];// [_p didChangeValueForKey:@\"name\"];// 二.循环观察，观察子类中的属性 利用属性依赖直接实现// _p.dog.age = a++;// 三.观察内部属性(容器)dog类中的多个属性 ，KVO的本质是观察set方法，需结合KVC去实现// _p.dog.age = a++;// _p.dog.height = a++;// 四.KVO实际上是对属性（成员变量、set、get）的Set方法观察，单纯的观察成员变量是不能实现KVO的；// _p-&gt;code = [NSString stringWithFormat:@\"%d\",a++]; // -&gt; 访问成员变量// 五.手动实现KVO 原理：1、利用运行时动态的创建了一个NSKVONotifying_NCperson 的一个派生类；// 2、动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类。// _p.name = [NSString stringWithFormat:@\"%d\",a++]; objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]); NSLog(@\"修改了%@\",_p.name);&#125;@end NSObject+NCKVO (头部拓展可忽略)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137NSObject+NCKVO.h#import &lt;Foundation/Foundation.h&gt;@interface NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;@endNSObject+NCKVO.m#import \"NSObject+NCKVO.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;/*拓展 方法、成员变量、类、对象 Class typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif &#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： // 成员变量列表 struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif variable length structurestruct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif variable length structure struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125;由此可见，我们可以动态修改 *methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。这里可以参考下美团技术团队的文章：深入理解 Objective-C: Category。*//*拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） 添加子类的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； */#define force_inline __inline__ __attribute__((always_inline))// 未用@implementation NSObject (NCKVO)- (void)NC_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; //1.动态的创建一个派生类：NSKVONotifying_NCperson； NSString *oldClassName = NSStringFromClass(self.class); NSString *newClassName = [@\"NCKVO_\" stringByAppendingString:oldClassName]; //运行时创建类 Class myClass = objc_allocateClassPair(self.class, [newClassName UTF8String], 0); //注册类 objc_registerClassPair(myClass); //2.动态修改了person对象的的isa指针，让它指向了NSKVONotifying_NCperson这个子类 object_setClass(self, myClass);// 3.添加派生类（子类）的setName方法 == 重写父类的setName方法，重写本质就添加，因为子类虽然继承于父类，但是本质上子类是没有setName方法的，它可以去找到父类的方法，但不等同于它有setName方法； /***** 拓展：调用方法本质就是发送消息：objc_sendMsg() 类---&gt;SEL(方法编号) ---&gt; IMP（方法实现的函数指针） */ //oc方法 SEL IMP 第四个参数：添加这个方法它的方法类型 //当第三个参数IMP有参数的情况下需要强转 //第四个参数type\"v@:\" 变成\"v@:@\",其中v表示void，@表示对象参数，：表示sel，@还是表示对象参数，可在开发文档中查询 class_addMethod(myClass, @selector(setName:), (IMP)impSetName, \"v@:@\"); //4.将观察者保存到当前的对象当中,当前例子中观察者应该是ViewController objc_setAssociatedObject(self,\"observer\",observer,OBJC_ASSOCIATION_ASSIGN);&#125;//OC中方法的调用里面有两个隐藏的参数！！！ 1、id self 2、SEL _cmd//objc_msgSend(_p,@selector(setName:),[NSString stringWithFormat:@\"%d\",a++]);//***要想获得第三个参数的值必须在参数列表中补齐 id self,SEL _cmdvoid impSetName(id self,SEL _cmd,NSString *name)&#123; id class = [self class]; //修改子类与父类的isa object_setClass(self, class_getSuperclass([self class])); //给父类发送消息，让他拿到newName的值 objc_msgSend(self, @selector(setName:),name); //再修改回来子类与父类的isa object_setClass(self, class); NSLog(@\"父类拿到了新值：%@\",name); //取出观察者,当前例子中观察者应该是ViewController id observer = objc_getAssociatedObject(self, \"observer\"); //给观察者发送消息，并发送change值，当前传过去的self为子类（派生类） NSDictionary *change = [NSDictionary dictionaryWithObjectsAndKeys:@\"1\",@\"kind\",name,@\"new\", nil]; objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:),@\"name\",self,change,nil);&#125;@end NCperson1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 NCperson.h#import &lt;Foundation/Foundation.h&gt;#import \"Dog.h\"@interface NCperson : NSObject&#123; @public NSString *code; //类的属性实质是是成员变量、set、get方法的封装，而KVO实际上是对Set方法的观察&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) Dog *dog;@property (nonatomic, strong) NSMutableArray *mArray;@endNCperson.m#import \"NCperson.h\"@implementation NCperson- (instancetype)init&#123; if (self = [super init]) &#123; _dog = [[Dog alloc] init]; _mArray = NSMutableArray.array; &#125; return self;&#125;//三.返回一个容器，里面是字符串类型！ key：被观察的key字符串//+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key&#123;//// NSLog(@\"%@\",key);//// NSSet *set = [super keyPathsForValuesAffectingValueForKey:key];// if ([key isEqualToString:@\"dog\"]) &#123;// NSArray *array = @[@\"_dog.age\",@\"_dog.height\"];// set = [set setByAddingObjectsFromArray:array];// &#125;// return set;//&#125;//一.默认为自动通知模式的KVO；这将其关闭，实现手动KVO//+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&#123;//// return NO;//&#125;@end Dog1234567891011121314151617181920Dog.h#import &lt;Foundation/Foundation.h&gt;@interface Dog : NSObject@property (nonatomic ,assign) int age;@property (nonatomic ,assign) int height;@endDog.m#import \"Dog.h\"@implementation Dog@end 以上就是代码的实现，很简单，盼指点！！！","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"利用Runtime解决NSArray越界等问题","slug":"利用Runtime解决NSArray越界等问题","date":"2016-10-08T08:23:48.000Z","updated":"2018-03-13T12:17:30.000Z","comments":true,"path":"2016/10/08/利用Runtime解决NSArray越界等问题/","link":"","permalink":"http://www.niu-chao.top/2016/10/08/利用Runtime解决NSArray越界等问题/","excerpt":"","text":"runtime 是 OC底层的一套C语言的API（引入 &lt;objc/runtime.h&gt; 或&lt;objc/message.h&gt;），编译器最终都会将OC代码转化为运行时代码，通过终端命令编译.m 文件： clang -rewrite-objc xxx.m 可以看到编译后的xxx.cpp（C++文件）。 比如我们创建了一个对象 [[NSObject alloc]init]，最终被转换为几万行代码，截取最关键的一句可以看到底层是通过runtime创建的对象.cpp 文件 删除掉一些强制转换语句，可以看到调用方法本质就是发消息，[[NSObject alloc]init] 语句发了两次消息，第一次发了alloc 消息，第二次发送init 消息。利用这个功能我们可以探究底层，比如block的实现原理。 需要注意的是，使用 objc_msgSend() sel_registerName()方法需要导入头文件&lt;objc/message.h&gt; 利用Runtime解决NSArray和NSMutableArray数组越界的crash问题废话不多说，直接上代码，其实是很小的功能！！！首先给NSArray创建一个类别，Xcode -&gt; File -&gt; New -&gt; -&gt;File,然后在弹出的视图中选择 source目录下的 Objective-C file 选项，可以直接创建Empty FIle，Category，Protocol和Extension类型的文件，我们选择创建Category(类别文件)，class选择NSArray，名称填写为NSArray+Safe。 .h文件123456789101112#import &lt;Foundation/Foundation.h&gt;/** * 解决NSArray和NSMutableArray数组越界的crash问题，当debug模式下会crash报错方便调试，release模式下会返回nil */@interface NSArray (Safe)@end@interface NSMutableArray (Safe)@end .m文件在.m文件下import 运行文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#import \"NSArray+Safe.h\"#import &lt;objc/runtime.h&gt;@implementation NSArray (Safe)//这个方法无论如何都会执行，而且是最开始执行+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayI\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end@implementation NSMutableArray (SafetyArray)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; @autoreleasepool &#123; // 选择器 SEL safeSel = @selector(safeObjectAtIndex:); SEL unsafeSel = @selector(objectAtIndex:); Class class = NSClassFromString(@\"__NSArrayM\"); // 方法 Method safeMethod = class_getInstanceMethod(class, safeSel); Method unsafeMethod = class_getInstanceMethod(class, unsafeSel); // 交换方法 method_exchangeImplementations(unsafeMethod, safeMethod); &#125;; &#125;);&#125;- (id)safeObjectAtIndex:(NSUInteger)index &#123; // 数组越界也不会崩，但是开发的时候并不知道数组越界 if (index &gt; (self.count - 1)) &#123; // 数组越界 NSAssert(NO, @\"数组越界了\"); // 只有开发的时候才会造成程序崩了 return nil; &#125;else &#123; // 没有越界 return [self safeObjectAtIndex:index]; &#125;&#125;@end 解析以上代码逻辑主要是在最开始执行的load方法中，通过method_exchangeImplementations 函数去交换函数指针（OC中的方法实际上就是C的函数）IMP。 dispatch_once这里不是“单例”，是保证方法替换只执行一次. load 方法是可以当做类方法主动调用的,为的是避免这种情况.（在我的理解中load方法是被import了以后就会被调用）NSObject的load和initialize方法 方法替换”这种使用情况下,发现有两种写法. 其实也不是两种写法,准确的来说一种是比较严谨的,另一种则没有那么严谨. 发现这两种写法的差异后,我主要集中在下列: class_addMethodclass_replaceMethodmethod_exchangeImplementations 利用Runtime设置字体方法(方法替换的另一种写法—-严谨的写法).h文件12345@interface UIFont(Swizzle)+(void)load;@end .m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import \"UIfont+Swizzle.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation UIFont(Swizzle)+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [UIFont swizzleMethodOrginalMtd:@selector(systemFontOfSize:) newMtd:@selector(myFontOfSize:)]; [UIFont swizzleMethodOrginalMtd:@selector(boldSystemFontOfSize:) newMtd:@selector(myboldFontOfSize:)]; &#125;);&#125;+ (BOOL)swizzleMethodOrginalMtd:(SEL)origSelector newMtd:(SEL)altSelector&#123; Method origMethod = class_getClassMethod([self class], origSelector); if (nil == origMethod) &#123; return NO; &#125; Method altMethod = class_getClassMethod([self class], altSelector); if (nil == altMethod) &#123; return NO; &#125; BOOL didAddMethod = class_addMethod([self class], origSelector, method_getImplementation(altMethod), method_getTypeEncoding(altMethod)); if (didAddMethod) &#123; class_replaceMethod([self class], altSelector, method_getImplementation(origMethod), method_getTypeEncoding(origMethod)); &#125; else &#123; method_exchangeImplementations(origMethod, altMethod); &#125; return YES;&#125;+ (UIFont *)myFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName: @\"Avenir-Light\" size:fontSize];&#125;+ (UIFont *)myboldFontOfSize:(CGFloat)fontSize&#123; return [UIFont fontWithName:@\"Avenir-Medium\" size:fontSize];&#125; 说明:class_addMethod:如果发现方法已经存在，会失败返回，也可以用来做检查用,我们这里是为了避免源方法没有实现的情况;如果方法没有存在,我们则先尝试添加被替换的方法的实现 1.如果返回成功:则说明被替换方法没有存在.也就是被替换的方法没有被实现,我们需要先把这个方法实现,然后再执行我们想要的效果,用我们自定义的方法去替换被替换的方法. 这里使用到的是class_replaceMethod 这个方法. class_replaceMethod本身会尝试调用class_addMethod和method_setImplementation，所以直接调用class_replaceMethod就可以了) 2.如果返回失败:则说明被替换方法已经存在.直接将两个方法的实现交换即可 另外: 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP我们可以利用 class_replaceMethod 来修改类我们可以利用 method_setImplementation 来直接设置某个方法的IMP 其实我们如果 研究过 AFN 代码的话,会发现, AFN 就是第二种写法.在AFURLSessionManager.m的第296行: 123456789static inline void af_swizzleSelector(Class class, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; Runtime运行时添加属性，或者block属性知识点 key：要保证全局唯一，key与关联的对象是一一对应关系。必须全局唯一。通常用@selector(methodName)作为key。value：要关联的对象。policy：关联策略。有五种关联策略。OBJC_ASSOCIATION_ASSIGN 等价于 @property(assign)。OBJC_ASSOCIATION_RETAIN_NONATOMIC等价于 @property(strong, nonatomic)。OBJC_ASSOCIATION_COPY_NONATOMIC等价于@property(copy, nonatomic)。OBJC_ASSOCIATION_RETAIN等价于@property(strong,atomic)。OBJC_ASSOCIATION_COPY等价于@property(copy, atomic)。 .h123456789#import &lt;UIKit/UIKit.h&gt;typedef void (^btnBlock)(id sender);@interface UIButton (Block)- (void)handelWithBlock:(btnBlock)block;@end .m1234567891011121314151617181920212223#import \"UIButton+Block.h\"#import &lt;objc/runtime.h&gt;@implementation UIButton (Block)- (void)handelWithBlock:(btnBlock)block &#123; if (block) &#123; objc_setAssociatedObject(self,@selector(btnAction:) , block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; [self addTarget:self action:@selector(btnAction:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)btnAction:(id)sender&#123; btnBlock block = objc_getAssociatedObject(self,@selector(btnAction:)); if (block) &#123; block(sender); &#125;&#125;@end 注意：@selector(btnAction:) 部分是第二个参数 ;类型通常都是通常都是会采用静态变量static const char btnKey 来作为关键字 &amp;btnkey ,也可以使用”@selector(btnAction:) “。 第二个参数进一步优化，出现了_cmd 代替了 &amp;btnKey 或者 @selector(methodName). 因为： _cmd在Objective-C的方法中表示当前方法的selector，正如同self表示当前方法调用的对象实例. 这里强调当前，_cmd的作用域只在当前方法里，直指当前方法名@selector。**","categories":[],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"http://www.niu-chao.top/tags/Runtime/"}]},{"title":"IOS-锁","slug":"IOS-锁","date":"2016-07-08T06:15:22.000Z","updated":"2018-03-13T12:25:47.000Z","comments":true,"path":"2016/07/08/IOS-锁/","link":"","permalink":"http://www.niu-chao.top/2016/07/08/IOS-锁/","excerpt":"","text":"在平时的开发中经常使用到多线程，在使用多线程的过程中，难免会遇到资源竞争的问题，那我们怎么来避免出现这种问题那？ 线程安全是什么？ 当一个线程访问数据的时候，其他的线程不能对其进行访问，直到该线程访问完毕。简单来讲就是在同一时刻，对同一个数据操作的线程只有一个。只有确保了这样，才能使数据不会被其他线程影响。而线程不安全，则是在同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果。 比如写文件和读文件，当一个线程在写文件的时候，理论上来说，如果这个时候另一个线程来直接读取的话，那么得到的结果可能是你无法预料的。 怎么来保证线程安全？ 通常我们使用锁的机制来保证线程安全，即确保同一时刻只有同一个线程来对同一个数据源进行访问。 @synchronized@synchronized是 iOS 中最常见的锁，用法很简单： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; [self synchronized];&#125; - (void)synchronized &#123; NSObject * cjobj = [NSObject new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; @synchronized(cjobj)&#123; NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); @synchronized(cjobj)&#123; NSLog(@\"线程2\"); &#125; &#125;);&#125; 控制台输出：12311:35:13.459194+0800 Thread-Lock[24855:431100] 线程1开始11:35:16.460210+0800 Thread-Lock[24855:431100] 线程1结束11:35:16.460434+0800 Thread-Lock[24855:431101] 线程2 解析从上面的控制台输出时间可以看出来，在线程 1 内容全部输出之后，才输出了线程 2 的内容，“线程1结束”与“线程2”都是在“线程1开始”3 秒后输出的。 @synchronized(cjobj) 指令使用的 cjobj 为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程 2 中的 @synchronized(cjobj) 改为 @synchronized(self) ，那么线程 2就不会被阻塞，@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。 @sychronized(cjobj){} 内部 cjobj 被释放或被设为 nil 不会影响锁的功能，但如果 cjobj 一开始就是 nil，那就会丢失了锁的功能了。 这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 NSLock先看看iOS中NSLock类的.h文件，从代码中可以看出，该类分成了几个子类：NSLock、NSConditionLock、NSRecursiveLock、NSCondition，然后有一个 NSLocking&gt;协议： 1234@protocol NSLocking- (void)lock;- (void)unlock;@end 虽然 NSLock、NSConditionLock、NSRecursiveLock、NSCondition 都遵循的了 NSLocking 协议，但是它们并不相同。 NSLock 实现了最基本的互斥锁，遵循了 NSLocking 协议，通过 lock 和 unlock 来进行锁定和解锁。 源码1234567891011@interface NSLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; [self nslock];&#125; - (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lock]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;);&#125;控制台输出： 15:03:58.868708+0800 Thread-Lock[39059:846493] 线程1加锁成功 15:04:00.872714+0800 Thread-Lock[39059:846493] 线程1解锁成功 15:04:00.872722+0800 Thread-Lock[39059:846492] 线程2加锁成功 15:04:00.873000+0800 Thread-Lock[39059:846492] 线程2解锁成功 1234567891011121314151617181920212223242526- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock tryLock]) &#123; NSLog(@\"线程3加锁成功\"); [cjlock unlock]; NSLog(@\"线程3解锁成功\"); &#125;else &#123; NSLog(@\"线程3加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:05:38.627767+0800 Thread-Lock[39118:849171] 线程1加锁成功 15:05:38.627767+0800 Thread-Lock[39118:849169] 线程3加锁失败 15:05:40.629969+0800 Thread-Lock[39118:849171] 线程1解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(3); if ([cjlock tryLock]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlock]; NSLog(@\"线程4解锁成功\"); &#125;else &#123; NSLog(@\"线程4加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:07:14.872279+0800 Thread-Lock[39166:851060] 线程1加锁成功 15:07:16.876108+0800 Thread-Lock[39166:851060] 线程1解锁成功 15:07:17.876208+0800 Thread-Lock[39166:851052] 线程4加锁成功 15:07:17.876527+0800 Thread-Lock[39166:851052] 线程4解锁成功 123456789101112131415161718192021222324252627- (void)nslock &#123; NSLock * cjlock = [NSLock new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(2); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程5加锁成功\"); [cjlock unlock]; NSLog(@\"线程5解锁成功\"); &#125;else &#123; NSLog(@\"线程5加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:08:39.705131+0800 Thread-Lock[39204:852782] 线程1加锁成功 15:08:41.708717+0800 Thread-Lock[39204:852782] 线程1解锁成功 15:08:41.708717+0800 Thread-Lock[39204:852784] 线程5加锁成功 15:08:41.708935+0800 Thread-Lock[39204:852784] 线程5解锁成功注意：lock与unlock操作必须在同一线程，否则结果不确定甚至会引起死锁 解析： 除 lock 和 unlock 方法外，NSLock 还提供了 tryLock 和 lockBeforeDate:两个方法。 由上面的结果可以看到 tryLock 并不会阻塞线程，[cjlock tryLock] 能加锁返回 YES，不能加锁返回 NO，然后都会执行后续代码。 这里顺便提一下 trylock 和 lock 使用场景：当前线程锁失败，也可以继续其它任务，用 trylock 合适；当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock。以下的锁都是这样。 lockBeforeDate: 方法会在所指定 Date 之前尝试加锁，会阻塞线程，如果在指定时间之前都不能加锁，则返回 NO，指定时间之前能加锁，则返回 YES。 由于是互斥锁，当一个线程进行访问的时候，该线程获得锁，其他线程进行访问的时候，将被操作系统挂起，直到该线程释放锁，其他线程才能对其进行访问，从而却确保了线程安全。但是如果连续锁定两次，则会造成死锁问题。 NSRecursiveLockNSRecursiveLock 是递归锁，顾名思义，可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。 源码：1234567891011@interface NSRecursiveLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (BOOL)tryLock;- (BOOL)lockBeforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsrecursivelock];&#125; - (void)nsrecursivelock&#123; NSRecursiveLock * cjlock = [[NSRecursiveLock alloc] init]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; [cjlock lock]; NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value:%d\", value); RecursiveBlock(value - 1); &#125; [cjlock unlock]; NSLog(@\"%d解锁成功\",value); &#125;; RecursiveBlock(3); &#125;);&#125;控制台输出： 16:15:40.584213+0800 Thread-Lock[39579:894111] 3加锁成功 16:15:40.584387+0800 Thread-Lock[39579:894111] value:3 16:15:40.584552+0800 Thread-Lock[39579:894111] 2加锁成功 16:15:40.584635+0800 Thread-Lock[39579:894111] value:2 16:15:40.584810+0800 Thread-Lock[39579:894111] 1加锁成功 16:15:40.585267+0800 Thread-Lock[39579:894111] value:1 16:15:40.585714+0800 Thread-Lock[39579:894111] 0加锁成功 16:15:40.585906+0800 Thread-Lock[39579:894111] 0解锁成功 16:15:40.586138+0800 Thread-Lock[39579:894111] 1解锁成功 16:15:40.586217+0800 Thread-Lock[39579:894111] 2解锁成功 16:15:40.586314+0800 Thread-Lock[39579:894111] 3解锁成功 解析 如果用 NSLock 的话，cjlock 先锁上了，但未执行解锁的时候，就会进入递归的下一层，而再次请求上锁，阻塞了该线程，线程被阻塞了，自然后面的解锁代码不会执行，而形成了死锁。而 NSRecursiveLock 递归锁就是为了解决这个问题。 NSConditionLock NSConditionLock 对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁，它和 NSLock 类似，都遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法，例如 tryLock、tryLockWhenCondition:，所以 NSConditionLock 可以称为条件锁。 只有 condition 参数与初始化时候的 condition 相等，lock 才能正确进行加锁操作。 unlockWithCondition: 并不是当 condition 符合条件时才解锁，而是解锁之后，修改 condition 的值。 源码123456789101112131415161718@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER; @property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad &#123; [super viewDidLoad]; [self nsconditionlock];&#125; - (void)nsconditionlock &#123; NSConditionLock * cjlock = [[NSConditionLock alloc] initWithCondition:0]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [cjlock lock]; NSLog(@\"线程1加锁成功\"); sleep(1); [cjlock unlock]; NSLog(@\"线程1解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); [cjlock lockWhenCondition:1]; NSLog(@\"线程2加锁成功\"); [cjlock unlock]; NSLog(@\"线程2解锁成功\"); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(2); if ([cjlock tryLockWhenCondition:0]) &#123; NSLog(@\"线程3加锁成功\"); sleep(2); [cjlock unlockWithCondition:2]; NSLog(@\"线程3解锁成功\"); &#125; else &#123; NSLog(@\"线程3尝试加锁失败\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; if ([cjlock lockWhenCondition:2 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程4加锁成功\"); [cjlock unlockWithCondition:1]; NSLog(@\"线程4解锁成功\"); &#125; else &#123; NSLog(@\"线程4尝试加锁失败\"); &#125; &#125;);&#125;控制台输出： 15:09:44.010992+0800 Thread-Lock[39230:853946] 线程1加锁成功 15:09:45.012045+0800 Thread-Lock[39230:853946] 线程1解锁成功 15:09:46.012692+0800 Thread-Lock[39230:853947] 线程3加锁成功 15:09:48.016536+0800 Thread-Lock[39230:853947] 线程3解锁成功 15:09:48.016564+0800 Thread-Lock[39230:853944] 线程4加锁成功 15:09:48.017039+0800 Thread-Lock[39230:853944] 线程4解锁成功 15:09:48.017040+0800 Thread-Lock[39230:853945] 线程2加锁成功 15:09:48.017215+0800 Thread-Lock[39230:853945] 线程2解锁成功 解析 在线程 1 解锁成功之后，线程 2 并没有加锁成功，而是继续等了 1 秒之后线程 3 加锁成功，这是因为线程 2 的加锁条件不满足，初始化时候的 condition 参数为 0，而线程 2加锁条件是 condition 为 1，所以线程 2 加锁失败。 lockWhenCondition 与 lock 方法类似，加锁失败会阻塞线程，所以线程 2 会被阻塞着。 tryLockWhenCondition: 方法就算条件不满足，也会返回 NO，不会阻塞当前线程。 lockWhenCondition:beforeDate:方法会在约定的时间内一直等待 condition 变为 2，并阻塞当前线程，直到超时后返回 NO。 锁定和解锁的调用可以随意组合，也就是说 lock、lockWhenCondition:与unlock、unlockWithCondition: 是可以按照自己的需求随意组合的。 NSCondition NSCondition 是一种特殊类型的锁，通过它可以实现不同线程的调度。一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。比如说，你可以开启一个线程下载图片，一个线程处理图片。这样的话，需要处理图片的线程由于没有图片会阻塞，当下载线程下载完成之后，则满足了需要处理图片的线程的需求，这样可以给定一个信号，让处理图片的线程恢复运行。 NSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态，如果进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 NSCondition 可以手动控制线程的挂起与唤醒，可以利用这个特性设置依赖。 源码12345678910111213@interface NSCondition : NSObject &lt;NSLocking&gt; &#123;@private void *_priv;&#125; - (void)wait; //挂起线程- (BOOL)waitUntilDate:(NSDate *)limit; //什么时候挂起线程- (void)signal; // 唤醒一条挂起线程- (void)broadcast; //唤醒所有挂起线程 @property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); @end 用法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)viewDidLoad &#123; [super viewDidLoad]; [self nscondition];&#125; - (void)nscondition &#123; NSCondition * cjcondition = [NSCondition new]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程1线程加锁\"); [cjcondition wait]; NSLog(@\"线程1线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程1线程解锁\"); &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [cjcondition lock]; NSLog(@\"线程2线程加锁\"); if ([cjcondition waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:10]]) &#123; NSLog(@\"线程2线程唤醒\"); [cjcondition unlock]; NSLog(@\"线程2线程解锁\"); &#125; &#125;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition signal]; &#125;);&#125;控制台输出： 17:15:48.410316+0800 Thread-Lock[40011:943638] 线程1线程加锁 17:15:48.410757+0800 Thread-Lock[40011:943640] 线程2线程加锁 17:15:50.414288+0800 Thread-Lock[40011:943638] 线程1线程唤醒 17:15:50.414454+0800 Thread-Lock[40011:943638] 线程1线程解锁//如果 [cjcondition signal]; 改成 [cjcondition broadcast]; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); [cjcondition broadcast]; &#125;);控制台输出： 17:18:08.054109+0800 Thread-Lock[40056:946099] 线程1线程加锁 17:18:08.054304+0800 Thread-Lock[40056:946096] 线程2线程加锁 17:18:10.056071+0800 Thread-Lock[40056:946099] 线程1线程唤醒 17:18:10.056231+0800 Thread-Lock[40056:946099] 线程1线程解锁 17:18:10.056244+0800 Thread-Lock[40056:946096] 线程2线程唤醒 17:18:10.056445+0800 Thread-Lock[40056:946096] 线程2线程解锁 解析 在加上锁之后，调用条件对象的 wait 或 waitUntilDate: 方法来阻塞线程，直到条件对象发出唤醒信号或者超时之后，再进行之后的操作。signal 和 broadcast 方法的区别在于，signal 只是一个信号量，只能唤醒一个等待的线程，想唤醒多个就得多次调用，而 broadcast 可以唤醒所有在等待的线程。 dispatch_semaphoredispatch_semaphore 使用信号量机制实现锁，等待信号和发送信号。 dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的只有三个函数，一个是创建信号量，一个是等待信号，一个是发送信号。dispatch_semaphore 的机制就是当有多个线程进行访问的时候，只要有一个获得了信号，其他线程的就必须等待该信号释放。 常用相关API：123dispatch_semaphore_create(long value);dispatch_semaphore_wait(dispatch_semaphore_t _Nonnull dsema, dispatch_time_t timeout);dispatch_semaphore_signal(dispatch_semaphore_t _Nonnull dsema); 用法：12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; [self dispatch_semaphore];&#125; - (void)dispatch_semaphore &#123; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, 6 * NSEC_PER_SEC); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程1开始\"); sleep(5); NSLog(@\"线程1结束\"); dispatch_semaphore_signal(semaphore); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); dispatch_semaphore_wait(semaphore, overTime); NSLog(@\"线程2开始\"); dispatch_semaphore_signal(semaphore); &#125;);&#125;控制台输出： 18:30:37.672490+0800 Thread-Lock[40569:993613] 线程1开始 18:30:42.673845+0800 Thread-Lock[40569:993613] 线程1结束 18:30:42.674165+0800 Thread-Lock[40569:993612] 线程2开始//如果 overTime 改成 3 秒控制台输出： 18:32:32.078186+0800 Thread-Lock[40634:995921] 线程1开始 18:32:35.082943+0800 Thread-Lock[40634:995920] 线程2开始 18:32:37.083115+0800 Thread-Lock[40634:995921] 线程1结束 解析 dispatch_semaphore 和 NSCondition 类似，都是一种基于信号的同步方式，但 NSCondition 信号只能发送，不能保存（如果没有线程在等待，则发送的信号会失效）。而 dispatch_semaphore 能保存发送的信号。dispatch_semaphore 的核心是 dispatch_semaphore_t 类型的信号量。 dispatch_semaphore_create(1) 方法可以创建一个 dispatch_semaphore_t 类型的信号量，设定信号量的初始值为 1。注意，这里的传入的参数必须大于或等于 0，否则 dispatch_semaphore_create 会返回 NULL。 dispatch_semaphore_wait(semaphore, overTime); 方法会判断 semaphore 的信号值是否大于 0。大于 0 不会阻塞线程，消耗掉一个信号，执行后续任务。如果信号值为 0，该线程会和 NSCondition 一样直接进入 waiting 状态，等待其他线程发送信号唤醒线程去执行后续任务，或者当 overTime 时限到了，也会执行后续任务。 dispatch_semaphore_signal(semaphore); 发送信号，如果没有等待的线程接受信号，则使 signal 信号值加一（做到对信号的保存）。 一个 dispatch_semaphore_wait(semaphore, overTime); 方法会去对应一个 dispatch_semaphore_signal(semaphore); 看起来像 NSLock 的 lock 和 unlock，其实可以这样理解，区别只在于有信号量这个参数，lock unlock 只能同一时间，一个线程访问被保护的临界区，而如果 dispatch_semaphore 的信号量初始值为 x ，则可以有 x 个线程同时访问被保护的临界区。 pthread_mutex 与 pthread_mutex(recursive) pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，POSIX 互斥锁是一种超级易用的互斥锁，使用的时候： 只需要使用 pthread_mutex_init 初始化一个 pthread_mutex_t，pthread_mutex_lock 或者 pthread_mutex_trylock 来锁定 ，pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。 常用相关API：12345pthread_mutex_init(pthread_mutex_t *restrict _Nonnull, const pthread_mutexattr_t *restrict _Nullable);pthread_mutex_lock(pthread_mutex_t * _Nonnull);pthread_mutex_trylock(pthread_mutex_t * _Nonnull);pthread_mutex_unlock(pthread_mutex_t * _Nonnull);pthread_mutex_destroy(pthread_mutex_t * _Nonnull); 用法：pthread_mutex123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex];&#125; - (void)pthread_mutex &#123; __block pthread_mutex_t cjlock; pthread_mutex_init(&amp;cjlock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); pthread_mutex_unlock(&amp;cjlock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; sleep(1); pthread_mutex_lock(&amp;cjlock); NSLog(@\"线程2\"); pthread_mutex_unlock(&amp;cjlock); &#125;);&#125;控制台输出： 14:50:29.842180+0800 Thread-Lock[74478:1647362] 线程1开始 14:50:32.846786+0800 Thread-Lock[74478:1647362] 线程1结束 14:50:32.847001+0800 Thread-Lock[74478:1647359] 线程2 pthread_mutex(recursive) 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)viewDidLoad &#123; [super viewDidLoad]; [self pthread_mutex_recursive];&#125; - (void)pthread_mutex_recursive &#123; __block pthread_mutex_t cjlock; pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;cjlock, &amp;attr); pthread_mutexattr_destroy(&amp;attr); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) &#123; pthread_mutex_lock(&amp;cjlock); NSLog(@\"%d加锁成功\",value); if (value &gt; 0) &#123; NSLog(@\"value = %d\", value); sleep(1); RecursiveBlock(value - 1); &#125; NSLog(@\"%d解锁成功\",value); pthread_mutex_unlock(&amp;cjlock); &#125;; RecursiveBlock(3); &#125;);&#125;//控制台输出： 15:31:51.599693+0800 Thread-Lock[74723:1668089] 3加锁成功 15:31:51.599912+0800 Thread-Lock[74723:1668089] value = 3 15:31:52.602002+0800 Thread-Lock[74723:1668089] 2加锁成功 15:31:52.602317+0800 Thread-Lock[74723:1668089] value = 2 15:31:53.604669+0800 Thread-Lock[74723:1668089] 1加锁成功 15:31:53.604957+0800 Thread-Lock[74723:1668089] value = 1 15:31:54.607778+0800 Thread-Lock[74723:1668089] 0加锁成功 15:31:54.608109+0800 Thread-Lock[74723:1668089] 0解锁成功 15:31:54.608391+0800 Thread-Lock[74723:1668089] 1解锁成功 15:31:54.608622+0800 Thread-Lock[74723:1668089] 2解锁成功 15:31:54.608945+0800 Thread-Lock[74723:1668089] 3解锁成功 解析 它的用法和 NSLock 的 lock unlock 用法一致，而它也有一个 pthread_mutex_trylock 方法，pthread_mutex_trylock 和 tryLock 的区别在于，tryLock 返回的是 YES 和 NO，pthread_mutex_trylock 加锁成功返回的是 0，失败返回的是错误提示码。 pthread_mutex(recursive) 作用和 NSRecursiveLock 递归锁类似。如果使用 pthread_mutex_init(&amp;theLock, NULL); 初始化锁的话，上面的代码的第二部分会出现死锁现象，使用递归锁就可以避免这种现象。 OSSpinLock OSSpinLock 是一种自旋锁，和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。 只有加锁，解锁，尝试加锁三个方法。 常用相关API：12345678typedef int32_t OSSpinLock; // 加锁void OSSpinLockLock( volatile OSSpinLock *__lock );// 尝试加锁bool OSSpinLockTry( volatile OSSpinLock *__lock );// 解锁void OSSpinLockUnlock( volatile OSSpinLock *__lock ); 用法：12345678910111213141516171819202122232425262728293031#import &lt;libkern/OSAtomic.h&gt; - (void)viewDidLoad &#123; [super viewDidLoad]; [self osspinlock];&#125; - (void)osspinlock &#123; __block OSSpinLock theLock = OS_SPINLOCK_INIT; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); NSLog(@\"线程1开始\"); sleep(3); NSLog(@\"线程1结束\"); OSSpinLockUnlock(&amp;theLock); &#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;theLock); sleep(1); NSLog(@\"线程2\"); OSSpinLockUnlock(&amp;theLock); &#125;);&#125;控制台输出： 16:02:48.865501+0800 Thread-Lock[75025:1684487] 线程1开始 16:02:51.868736+0800 Thread-Lock[75025:1684487] 线程1结束 16:02:52.922911+0800 Thread-Lock[75025:1684486] 线程2 YY大神 @ibireme 的文章也有说这个自旋锁存在优先级反转问题，具体文章可以戳 不再安全的 OSSpinLock，而 OSSpinLock 在iOS 10.0中被 中的 os_unfair_lock 取代。&gt; 介绍了 OSSpinLock 不再安全，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 os_unfair_lock 自旋锁已经不再安全，然后苹果又整出来个 os_unfair_lock，这个锁解决了优先级反转问题。 常用相关API：123456789// 初始化os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);// 加锁os_unfair_lock_lock(unfairLock);// 尝试加锁BOOL b = os_unfair_lock_trylock(unfairLock);// 解锁os_unfair_lock_unlock(unfairLock);os_unfair_lock 用法和 OSSpinLock 基本一直，就不一一列出了。 总结应当针对不同的操作使用不同的锁，而不能一概而论哪种锁的加锁解锁速度快。 其实每一种锁基本上都是加锁、等待、解锁的步骤，理解了这三个步骤就可以帮你快速的学会各种锁的用法。 @synchronized 的效率最低，不过它的确用起来最方便，所以如果没什么性能瓶颈的话，可以选择使用 @synchronized。 当性能要求较高时候，可以使用 pthread_mutex 或者 dispath_semaphore，由于 OSSpinLock 不能很好的保证线程安全，而在只有在 iOS10 中才有 os_unfair_lock ，所以，前两个是比较好的选择。既可以保证速度，又可以保证线程安全。 对于 NSLock 及其子类，速度来说 NSLock &lt; NSCondition &lt; NSRecursiveLock &lt; NSConditionLock 。&gt;","categories":[],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://www.niu-chao.top/tags/IOS/"}]},{"title":"Markdown","slug":"MarkDown","date":"2015-10-08T05:24:22.000Z","updated":"2018-03-07T06:58:46.000Z","comments":true,"path":"2015/10/08/MarkDown/","link":"","permalink":"http://www.niu-chao.top/2015/10/08/MarkDown/","excerpt":"","text":"Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0):'''A docstring'''if param1 &gt; param2: # interestingprint 'Greater'return (param2 - param1 + 1) or Noneclass SomeClass:pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图[语法][3]以及时序图[语法][4]。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.niu-chao.top/tags/Markdown/"}]},{"title":"一头驮砖的牛博客","slug":"一头驮砖的牛博客","date":"2014-10-08T03:53:46.000Z","updated":"2018-03-13T12:27:49.000Z","comments":true,"path":"2014/10/08/一头驮砖的牛博客/","link":"","permalink":"http://www.niu-chao.top/2014/10/08/一头驮砖的牛博客/","excerpt":"","text":"","categories":[],"tags":[]}]}