<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="IOS," />










<meta name="description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法【前言】从iOS7升到iOS8后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  dispatch_async  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8">
<meta name="keywords" content="IOS">
<meta property="og:type" content="article">
<meta property="og:title" content="Parse的底层多线程处理思路">
<meta property="og:url" content="http://www.niu-chao.top/2016/05/14/Parse的底层多线程处理思路/index.html">
<meta property="og:site_name" content="一头驮砖的牛">
<meta property="og:description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法【前言】从iOS7升到iOS8后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  dispatch_async  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i65.tinypic.com/2vj1md2.jpg">
<meta property="og:image" content="http://i66.tinypic.com/34g8qd1.jpg">
<meta property="og:image" content="http://i61.tinypic.com/6thjmf.jpg">
<meta property="og:image" content="http://i59.tinypic.com/suyt0o.jpg">
<meta property="og:image" content="http://i61.tinypic.com/33m06er.jpg">
<meta property="og:image" content="http://i67.tinypic.com/29vxt9w.jpg">
<meta property="og:updated_time" content="2018-04-13T10:23:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Parse的底层多线程处理思路">
<meta name="twitter:description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法【前言】从iOS7升到iOS8后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  dispatch_async  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8">
<meta name="twitter:image" content="http://i65.tinypic.com/2vj1md2.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.niu-chao.top/2016/05/14/Parse的底层多线程处理思路/"/>






<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>Parse的底层多线程处理思路 | 一头驮砖的牛</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>


    <a href="https://github.com/githubNiuChao" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一头驮砖的牛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.niu-chao.top/2016/05/14/Parse的底层多线程处理思路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一头驮砖的牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Parse的底层多线程处理思路</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-14T17:15:22+08:00">
                2016-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy#转载" target="_blank" rel="noopener">转载：https://github.com/ChenYilong/ParseSourceCodeStudy</a> </p>
<h1 id="Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法"><a href="#Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法" class="headerlink" title="Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法"></a>Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</h1><p>【前言】从iOS7升到iOS8后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  <code>dispatch_async</code>  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8后，最大线程数一度可以达到40条、50条。然而在文档上并没有对这一做法的目的进行介绍。</p>
<p>笔者推测 Apple 的目的是想借此让开发者使用 <code>NSOperationQueue</code> ：GCD 中 Apple 并没有提供控制并发数量的接口，而  <code>NSOperationQueue</code>  有。GCD 没有提供暂停、恢复、取消队列任务的接口，而  <code>NSOperationQueue</code>  有，如果想让 GCD 支持 <code>NSOperationQueue</code> 原生就支持的功能，需要使用许多GCD 的高级功能，大大提高了使用的难度。</p>
<p> <code>Apple</code>  始终有一个观念：尽可能选用高层 API，只在确有必要时才求助于底层。然而开发者并不买账，在我进行的一次 <a href="http://weibo.com/1692391497/D1pKjqaiW?type=comment" target="_blank" rel="noopener">调查</a> 中发现了一个有趣的现象：</p>
<p>大概 80%的iOS 开发者会支持使用 GCD 来完成操作队列的实现，而且有 60% 的开发已经在项目中使用。</p>
<p><img src="http://i65.tinypic.com/2vj1md2.jpg" alt="enter image description here"></p>
<p>更是有人这样表态：</p>
<p>假如不让他用 GCD：</p>
<p><img src="http://i66.tinypic.com/34g8qd1.jpg" alt="enter image description here"></p>
<p>这种现象一直存在，包括 ARC 与 MRC、SB建 UI 与纯代码建 UI、SQL 与 CoreData的争论。</p>
<p>但是因为是源码解析的文章，而 Parse 的 SDK 没有用一句的 NSOperation 的代码，GCD 一路用到底，让我也十分震惊。只能说明，写  <code>Parse</code>  的这位开发者是艺高人胆大。而且既然  <code>GCD</code>  的支持者如此之多，那么就谈一谈如何让 GCD 能支持 <code>NSOperationQueue</code> 原生就支持的功能。</p>
<p>今天虽然谈了NSOperation原生功能的 GCD 版本实现，但并不代表我支持像 Parse 这样 GCD 一路用到底。 业内一般的看法是这样的：</p>
<blockquote>
<p> <code>GCD</code> 虽然能够实现暂停和终止，但开发还是灵活些好，那些 <code>NSOperation</code> 用起来方便的就直接用 <code>NSOperation</code> 的方式，不然苹果多包那一层不是蛋疼，包括文章里提到的 <code>iOS8</code> 后控制线程数的问题，不一定项目就一定要GCD一路到底。有时候需要支持一些高层级封装功能比如： <code>KVO</code> 时 <code>NSOperation</code> 还是有它的优势的。 <code>GCD</code> 反而是处理些比较简单的操作或者是较系统级的比如：监视进程或者监视文件夹内文件的变化之类的比较合适。</p>
</blockquote>
<p>（iOS开发学习交流群：541317935）</p>
<p>第一篇的目的是通过解读 Parse 源码来展示GCD两个高级用法： <code>Dispatch Source</code> （派发源）和 <code>Dispatch Semaphore</code>  （信号量）。首先通过Parse 的“离线存储对象”操作，来介绍 <code>Dispatch Source</code> （派发源）；然后通过Parse 的单元测试中使用的技巧“强制把异步任务转换为同步任务来方便进行单元测试”来介绍<code>Dispatch Semaphore</code>  （信号量）。我已将思路浓缩为可运行的7个 Demo 中，详见仓库里的 Demo1到 Demo7。</p>
<p>如果对 GCD 不太熟悉，请先读下<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/GCD扫盲篇.md" target="_blank" rel="noopener">《GCD 扫盲篇》</a>。</p>
<ol>
<li><p>Dispatch Source分派源</p>
<ol>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-ios-sdk介绍" target="_blank" rel="noopener">Parse-iOS-SDK介绍</a> </p>
</li>
<li><p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-的离线存储对象操作介绍" target="_blank" rel="noopener">Parse 的“离线存储对象”操作介绍</a> </p>
</li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-的离线存储对象实现介绍" target="_blank" rel="noopener">Parse 的“离线存储对象”实现介绍</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-source-的使用步骤" target="_blank" rel="noopener">Dispatch Source 的使用步骤</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第一步创建一个dispatch-source" target="_blank" rel="noopener">第一步：创建一个Dispatch Source</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第二步创建dispatch-source的事件处理方法" target="_blank" rel="noopener">第二步：创建Dispatch Source的事件处理方法</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第三步处理dispatch-source的暂停与恢复操作" target="_blank" rel="noopener">第三步：处理Dispatch Source的暂停与恢复操作</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#第四步向dispatch-source发送事件" target="_blank" rel="noopener">第四步：向Dispatch Source发送事件</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#gcd真的不能像operationqueue那样终止任务" target="_blank" rel="noopener">GCD真的不能像OperationQueue那样终止任务？</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#完整例子demo1让-dispatch-source-帮-dispatch-queue-实现暂停和恢复功能" target="_blank" rel="noopener">完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatchsource能通过合并事件的方式确保在高负载下正常工作" target="_blank" rel="noopener">DispatchSource能通过合并事件的方式确保在高负载下正常工作</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-source-与-dispatch-queue-两者在线程执行上的关系" target="_blank" rel="noopener">Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#让-dispatch-source-与-dispatch-queue-同时实现暂停和恢复" target="_blank" rel="noopener">让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#parse-离线存储对象操作的代码摘录" target="_blank" rel="noopener">Parse “离线存储对象”操作的代码摘录</a> </li>
</ol>
</li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#dispatch-semaphore-信号量" target="_blank" rel="noopener">Dispatch Semaphore 信号量</a> <ol>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#在项目中的应用强制把异步任务转换为同步任务来方便进行单元测试" target="_blank" rel="noopener">在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#使用dispatch-semaphore控制并发线程数量" target="_blank" rel="noopener">使用Dispatch Semaphore控制并发线程数量</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#为--nsurlsession-添加同步方法" target="_blank" rel="noopener">为 NSURLSession 添加同步方法</a></li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#导致watchdog超时" target="_blank" rel="noopener">风险：导致Watchdog超时</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/Parse的底层多线程处理思路.md#失去了-cancel-的机会" target="_blank" rel="noopener">风险：失去了 cancel 的机会</a> </li>
</ol>
</li>
</ol>
<h2 id="Parse-iOS-SDK介绍"><a href="#Parse-iOS-SDK介绍" class="headerlink" title="Parse-iOS-SDK介绍"></a>Parse-iOS-SDK介绍</h2><p> <a href="http://www.infoq.com/cn/news/2015/08/ios-weekly-ios841#rd" target="_blank" rel="noopener">《iOS开发周报：iOS 8.4.1 发布，iOS 8 时代谢幕》</a> 对 Facebook 旗下的 Parse有这样一段介绍：</p>
<blockquote>
<p>Parse-SDK-iOS-OSX：著名的 BaaS 公司 Parse 最近开源了它们的 iOS/OSX SDK。Parse 的服务虽然在国内可能访问速度不是很理想，但是它们在服务的稳定性和 SDK 质量上一直有非常优异的表现。此次开源的 SDK 对于日常工作是 SDK 开发的开发者来说，是一个难得的学习机会。Parse 的存取操作涉及到很多多线程的问题，从 Parse SDK 的源代码中可以看出，这个 SDK 的开发者对 iOS 开发多线程有着非常深厚的理解和功底，让人叹服。我个人推荐对此感兴趣的朋友可以尝试从阅读 internal 文件夹下的两个EventuallyQueue 文件开始着手，研究下 Parse 的底层多线程处理思路。</p>
</blockquote>
<p>类似的服务：<br> Apple 的 <a href="http://nshipster.cn/cloudkit/" target="_blank" rel="noopener">Cloud​Kit</a> 、 国内的 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> 。</p>
<h2 id="Parse-的“离线存储对象”操作介绍"><a href="#Parse-的“离线存储对象”操作介绍" class="headerlink" title="Parse 的“离线存储对象”操作介绍"></a>Parse 的“离线存储对象”操作介绍</h2><p>大多数保存功能可以立刻执行，并通知应用“保存完毕”。不过若不需要知道保存完成的时间，则可使用“离线存储对象”操作（saveEventually 或 deleteEventually） 来代替，也就是：</p>
<p>如果用户目前尚未接入网络，“离线存储对象”操作（saveEventually 或 deleteEventually） 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，SDK 会自动再次尝试保存操作。</p>
<p>所有 saveEventually（或 deleteEventually）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 saveEventually 是安全的。</p>
<p>国内的 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> 也提供了相同的功能，所以以上《Parse 的“离线存储对象”操作介绍》部分完全摘录自 LeanCloud 的文档。详见<a href="https://leancloud.cn/docs/ios_os_x_guide.html#离线存储对象" target="_blank" rel="noopener">《LeanCloud官方文档-iOS / OS X 数据存储开发指南–离线存储对象》</a> </p>
<p>（利益相关声明：本人目前就职于 <a href="https://leancloud.cn/?source=T6M35E4H" target="_blank" rel="noopener">LeanCloud（原名 <code>AVOS</code> ）</a> ）</p>
<h2 id="Parse-的“离线存储对象”实现介绍"><a href="#Parse-的“离线存储对象”实现介绍" class="headerlink" title="Parse 的“离线存储对象”实现介绍"></a>Parse 的“离线存储对象”实现介绍</h2><p>Parse 的“离线存储对象”操作（saveEventually 或 deleteEventually） 是通过 GCD 的 <code>Dispatch Source</code> （信号源）来实现的。下面对 <code>Dispatch Source</code> （信号源）进行一下介绍：</p>
<p>GCD中除了主要的 <code>Dispatch Queue</code> 外，还有不太引人注目的 <code>Dispatch Source</code> .它是BSD系内核惯有功能kqueue的包装。kqueue 是在 XNU 内核中发生各种事件时，在应用程序编程方执行处理的技术。其 CPU 负荷非常小，尽量不占用资源。kqueue 可以说是应用程序处理 XNU 内核中发生的各种事件的方法中最优秀的一种。</p>
<p> <code>Dispatch Source</code> 也使用在了 Core Foundation 框架的用于异步网络的API  <code>CFSocket</code> 中。因为Foundation 框架的异步网络 API 是通过CFSocket实现的，所以可享受到仅使用 Foundation 框架的 <code>Dispatch Source</code> 带来的好处。</p>
<p>那么优势何在？使用的 <code>Dispatch Source</code> 而不使用 <code>dispatch_async</code> 的唯一原因就是利用联结的优势。</p>
<p>联结的大致流程：在任一线程上调用它的的一个函数 <code>dispatch_source_merge_data</code>  后，会执行 <code>Dispatch Source</code> 事先定义好的句柄（可以把句柄简单理解为一个 block ）。</p>
<p>这个过程叫 <code>Custom event</code> ,用户事件。是 dispatch source 支持处理的一种事件。</p>
<blockquote>
<p>简单地说，这种事件是由你调用 <code>dispatch_source_merge_data</code> 函数来向自己发出的信号。</p>
</blockquote>
<p>下面介绍下使用步骤：</p>
<h2 id="Dispatch-Source-的使用步骤"><a href="#Dispatch-Source-的使用步骤" class="headerlink" title="Dispatch Source 的使用步骤"></a><code>Dispatch Source</code> 的使用步骤</h2><h3 id="第一步：创建一个Dispatch-Source"><a href="#第一步：创建一个Dispatch-Source" class="headerlink" title="第一步：创建一个Dispatch Source"></a>第一步：创建一个<code>Dispatch Source</code></h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 详见 Demo1、Demo2</span><br><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                dispatch_get_main_queue());</span><br></pre></td></tr></table></figure>
<p>下面对参数进行下解释：</p>
<p>其中自定义源累积事件中传递过来的值，累积的方式可以是相加的，正如上面代码中的 <code>DISPATCH_SOURCE_TYPE_DATA_ADD</code> ，也可以是逻辑或 <code>DISPATCH_SOURCE_TYPE_DATA_OR</code> 。这是最常见的两个 <code>Dispatch Source</code> 可以处理的事件。</p>
<p><code>Dispatch Source</code> 可处理的所有事件。如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_DATA_ADD</code></td>
<td>变量增加</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_DATA_OR</code></td>
<td>变量OR</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_MACH_SEND</code></td>
<td>MACH端口发送</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_MACH_RECV</code></td>
<td>MACH端口接收</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_PROC</code></td>
<td>监测到与进程相关的事件</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_READ</code></td>
<td>可读取文件映像</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_SIGNAL</code></td>
<td>接收信号</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_TIMER</code></td>
<td>定时器</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_VNODE</code></td>
<td>文件系统有变更</td>
</tr>
<tr>
<td> <code>DISPATCH_SOURCE_TYPE_WRITE</code></td>
<td>可写入文件映像</td>
</tr>
</tbody>
</table>
<p>自定义源也需要一个队列，用来处理所有的响应句柄（block）。那么岂不是有两个队列了？没错，至于 <code>Dispatch Queue</code> 这个队列的线程执行与  <code>Dispatch Source</code>这个队列的线程执行的关系，下文会结合 Demo1和 Demo2进行详细论述。</p>
<h3 id="第二步：创建Dispatch-Source的事件处理方法"><a href="#第二步：创建Dispatch-Source的事件处理方法" class="headerlink" title="第二步：创建Dispatch Source的事件处理方法"></a>第二步：创建<code>Dispatch Source</code>的事件处理方法</h3><p>分派源提供了高效的方式来处理事件。首先注册事件处理程序，事件发生时会收到通知。如果在系统还没有来得及通知你之前事件就发生了多次，那么这些事件会被合并为一个事件。这对于底层的高性能代码很有用，但是OS应用开发者很少会用到这样的功能。类似地，分派源可以响应UNIX信号、文件系统的变化、其他进程的变化以及Mach Port事件。它们中很多都在Mac系统上很有用，但是iOS开发者通常不会用到。</p>
<p>不过，自定义源在iOS中很有用，尤其是在性能至关重要的场合进行进度反馈。如下所示，首先创建一个源:自定义源累积事件中传递过来的值。累积方式可以是相加( DISPATCH_SOURCE_TYPE_DATA_ADD ),<br>也可以是逻辑或( DISPATCH_SOURCE_DATA_OR )。自定义源也需要一个队列，用来处理所有的响应处理块。</p>
<p>创建源后，需要提供相应的处理方法。当源生效时会分派注册处理方法;当事件发生时会分派事件处理方法;当源被取消时会分派取消处理方法。自定义源通常只需要一个事件处理方法，可以像这样创建:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *省略部分： </span><br><span class="line">   指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">   详见Demo1、Demo2</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">   __block NSUInteger totalComplete = 0;</span><br><span class="line">   dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">       //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">       NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">       totalComplete += value;</span><br><span class="line">       NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>在同一时间，只有一个处理方法块的实例被分派。如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式(ADD或者OR)进行累积。通过合并事件的方式，系统即使在高负<br>载情况下也能正常工作。当处理事件件被最终执行时，计算后的数据可以通过 <code>dispatch_source_get_data</code> 来获取。这个数据的值在每次响应事件执行后会被重置，所以上面例子中 <code>totalComplete</code> 的值是最终累积的值。</p>
<h3 id="第三步：处理Dispatch-Source的暂停与恢复操作"><a href="#第三步：处理Dispatch-Source的暂停与恢复操作" class="headerlink" title="第三步：处理Dispatch Source的暂停与恢复操作"></a>第三步：处理<code>Dispatch Source</code>的暂停与恢复操作</h3><p>当追加大量处理到Dispatch Queue时，在追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被Block截获时，一些处理会对这个演算结果造成影响。</p>
<p>在这种情况下，只要挂起Dispatch Queue即可。当可以执行时再恢复。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure>
<p> <code>dispatch_resume</code> 函数恢复指定的 <code>Dispatch Queue</code> .<br>这些函数对已经执行的处理没有影响。挂起后，追加到 <code>Dispatch Queue</code> 中但尚未执行的处理在此之后停止执行。而恢复则使得这些处理能够继续执行。</p>
<p>分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。因为忘记恢复分派源的状态而产生bug是常见的事儿。恢复的方法是调用 <code>dispatch_resume</code> :</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume (source);</span><br></pre></td></tr></table></figure>
<p>为了方便理解 <code>dispatch_suspend</code> 函数的作用，这里提供一个 Demo：Demo3， 看下运行效果：</p>
<p>思考下NSLog的打印顺序为什么会是这样？</p>
<p>详见 Demo3（Demo<em>03</em>对DispatchQueue实现取消恢复操作_简单版）：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.iOSChengXuYuan.queue1&quot;, 0);</span><br><span class="line">    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.iOSChengXuYuan.queue2&quot;, 0);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务 1 ： queue 1...&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;✅完成任务 1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务 1 ： queue 2...&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        NSLog(@&quot;✅完成任务 2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;🚫正在暂停 1&quot;);</span><br><span class="line">        dispatch_suspend(queue1);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, queue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;🚫正在暂停 2&quot;);</span><br><span class="line">        dispatch_suspend(queue2);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;＝＝＝＝＝＝＝等待两个queue完成, 再往下进行...&quot;);</span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务 2 ： queue 1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务 2 ： queue 2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_resume(queue1);</span><br><span class="line">    dispatch_resume(queue2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2015-09-06 02:44:59.614 CYLDispatchQueueSuspendTest[1610:116662] 任务 1 ： queue 2...</span><br><span class="line">2015-09-06 02:44:59.613 CYLDispatchQueueSuspendTest[1610:116665] 任务 1 ： queue 1...</span><br><span class="line">2015-09-06 02:45:00.614 CYLDispatchQueueSuspendTest[1610:116665] ✅完成任务 1</span><br><span class="line">2015-09-06 02:45:00.614 CYLDispatchQueueSuspendTest[1610:116662] ✅完成任务 2</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116662] 🚫正在暂停 2</span><br><span class="line">2015-09-06 02:45:00.615 CYLDispatchQueueSuspendTest[1610:116665] 🚫正在暂停 1</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116515] ＝＝＝＝＝＝＝等待两个queue完成, 再往下进行...</span><br><span class="line">2015-09-06 02:45:00.616 CYLDispatchQueueSuspendTest[1610:116515] 🔴为什么这个NSLog会在上面两个NSLog之前打印❓❓答：dispatch_suspend的作用‼️</span><br><span class="line">2015-09-06 02:45:00.617 CYLDispatchQueueSuspendTest[1610:116665] 任务 2 ： queue 1</span><br><span class="line">2015-09-06 02:45:00.619 CYLDispatchQueueSuspendTest[1610:116665] 任务 2 ： queue 2</span><br></pre></td></tr></table></figure>
<p>思考下NSLog的打印顺序为什么会是这样？答：dispatch_suspend的作用！</p>
<p>详见 Demo3（Demo<em>03</em>对DispatchQueue实现取消恢复操作_简单版）。</p>
<h3 id="第四步：向Dispatch-Source发送事件"><a href="#第四步：向Dispatch-Source发送事件" class="headerlink" title="第四步：向Dispatch Source发送事件"></a>第四步：向<code>Dispatch Source</code>发送事件</h3><p>恢复源后，就可以像下面的代码片段这样，通过 <code>dispatch_source_merge_data</code> 向分派源发送事件:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//2.</span><br><span class="line">//恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">//详见Demo1、Demo2</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">        dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">        usleep(20000);//0.02秒</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在每次循环中执行加1操作。也可以传递已处理记录的数目或已写入的字节数。在任何线程中都可以调用  <code>dispatch_source_merge_data</code> 。需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。</p>
<h1 id="GCD真的不能像OperationQueue那样终止任务？"><a href="#GCD真的不能像OperationQueue那样终止任务？" class="headerlink" title="GCD真的不能像OperationQueue那样终止任务？"></a>GCD真的不能像OperationQueue那样终止任务？</h1><h3 id="完整例子Demo1：让-Dispatch-Source-“帮”-Dispatch-Queue-实现暂停和恢复功能"><a href="#完整例子Demo1：让-Dispatch-Source-“帮”-Dispatch-Queue-实现暂停和恢复功能" class="headerlink" title="完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能"></a>完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能</h3><p>本节配套代码在 <code>Demo1</code> 中（Demo<em>01</em>对DispatchSource实现取消恢复操作_main队列版）。</p>
<p>先写一段代码演示下DispatchSource的基本用法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  .m</span><br><span class="line">//  CYLDispatchSourceTest</span><br><span class="line">//</span><br><span class="line">//  Created by 微博@iOS程序犭袁（ http://weibo.com/luohanchenyilong/） on 15/9/1.</span><br><span class="line">//  Copyright (c) 2015年 https://github.com/ChenYilong . All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //1.</span><br><span class="line">    // 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">    _processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                    dispatch_get_main_queue());</span><br><span class="line">    __block NSUInteger totalComplete = 0;</span><br><span class="line">    dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">        //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">        NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">        totalComplete += value;</span><br><span class="line">        NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">        NSLog(@&quot;🔵线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">    [self resume];</span><br><span class="line">    </span><br><span class="line">    //2.</span><br><span class="line">    //恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">            dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">            NSLog(@&quot;♻️线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">            usleep(20000);//0.02秒</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则输出日志：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2015-09-03 16:50:48.346 CYLDispatchSourceTest[8331:874681] ✅恢复Dispatch Source(分派源)</span><br><span class="line">2015-09-03 16:50:48.348 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.372 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.401 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.424 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.444 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.473 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.493 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.515 CYLDispatchSourceTest[8331:874681] 进度：0.07000000000000001</span><br><span class="line">2015-09-03 16:50:48.515 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:48.516 CYLDispatchSourceTest[8331:874681] 进度：0.08</span><br><span class="line">2015-09-03 16:50:48.516 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:48.535 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:48.556 CYLDispatchSourceTest[8331:874681] 进度：0.09</span><br><span class="line">/*================省略中间====================*/</span><br><span class="line">2015-09-03 16:50:50.630 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.630 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874681] 进度：0.97</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.654 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874681] 进度：0.98</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.676 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.699 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:50:50.708 CYLDispatchSourceTest[8331:874681] 进度：0.99</span><br><span class="line">2015-09-03 16:50:50.708 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874681] 进度：1</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874681] 🔵线程号：&lt;NSThread: 0x7ff373428140&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:50:50.722 CYLDispatchSourceTest[8331:874889] ♻️线程号：&lt;NSThread: 0x7ff3735abe40&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：2.376</p>
<p>这段代码还可以进行如下优化：</p>
<p>将创建异步的操作放在 for 循环内部：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //1.</span><br><span class="line">    // 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">    _processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                      dispatch_get_main_queue());</span><br><span class="line">    __block NSUInteger totalComplete = 0;</span><br><span class="line">    dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">        //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">        NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">        totalComplete += value;</span><br><span class="line">        NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class="line">        NSLog(@&quot;🔵线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">    [self resume];</span><br><span class="line">    </span><br><span class="line">    //2.</span><br><span class="line">    //恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">        for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class="line">            dispatch_async(queue, ^&#123;</span><br><span class="line">            dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">            NSLog(@&quot;♻️线程号：%@&quot;, [NSThread currentThread]);</span><br><span class="line">            usleep(20000);//0.02秒</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">2015-09-03 16:48:10.153 CYLDispatchSourceTest[8301:871133] ✅恢复Dispatch Source(分派源)</span><br><span class="line">2015-09-03 16:48:10.154 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.156 CYLDispatchSourceTest[8301:871177] ♻️线程号：&lt;NSThread: 0x7fb663417370&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.156 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.163 CYLDispatchSourceTest[8301:871184] ♻️线程号：&lt;NSThread: 0x7fb6635507b0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.164 CYLDispatchSourceTest[8301:871185] ♻️线程号：&lt;NSThread: 0x7fb663618c90&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.164 CYLDispatchSourceTest[8301:871186] ♻️线程号：&lt;NSThread: 0x7fb663596920&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871187] ♻️线程号：&lt;NSThread: 0x7fb663465d20&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871175] ♻️线程号：&lt;NSThread: 0x7fb6634404f0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.182 CYLDispatchSourceTest[8301:871133] 进度：0.09</span><br><span class="line">2015-09-03 16:48:10.174 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.187 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.184 CYLDispatchSourceTest[8301:871188] ♻️线程号：&lt;NSThread: 0x7fb66348e850&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.184 CYLDispatchSourceTest[8301:871177] ♻️线程号：&lt;NSThread: 0x7fb663417370&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871133] 进度：0.13</span><br><span class="line">2015-09-03 16:48:10.187 CYLDispatchSourceTest[8301:871192] ♻️线程号：&lt;NSThread: 0x7fb66348db80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871189] ♻️线程号：&lt;NSThread: 0x7fb6635121b0&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.191 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871184] ♻️线程号：&lt;NSThread: 0x7fb6635507b0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871185] ♻️线程号：&lt;NSThread: 0x7fb663618c90&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.192 CYLDispatchSourceTest[8301:871186] ♻️线程号：&lt;NSThread: 0x7fb663596920&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.194 CYLDispatchSourceTest[8301:871190] ♻️线程号：&lt;NSThread: 0x7fb6635138b0&gt;&#123;number = 13, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871187] ♻️线程号：&lt;NSThread: 0x7fb663465d20&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.196 CYLDispatchSourceTest[8301:871175] ♻️线程号：&lt;NSThread: 0x7fb6634404f0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.206 CYLDispatchSourceTest[8301:871133] 进度：0.21</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.210 CYLDispatchSourceTest[8301:871133] 进度：0.23</span><br><span class="line">2015-09-03 16:48:10.201 CYLDispatchSourceTest[8301:871193] ♻️线程号：&lt;NSThread: 0x7fb663487830&gt;&#123;number = 14, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871194] ♻️线程号：&lt;NSThread: 0x7fb6634662c0&gt;&#123;number = 15, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.207 CYLDispatchSourceTest[8301:871195] ♻️线程号：&lt;NSThread: 0x7fb663618160&gt;&#123;number = 16, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.211 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.210 CYLDispatchSourceTest[8301:871196] ♻️线程号：&lt;NSThread: 0x7fb663566720&gt;&#123;number = 17, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.211 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">/*＝＝＝＝＝＝＝＝＝＝省略20行带有的 ♻️的打印内容（没有重复的线程号）＝＝＝＝＝＝＝＝*/</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871196] ♻️线程号：&lt;NSThread: 0x7fb663566720&gt;&#123;number = 17, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871174] ♻️线程号：&lt;NSThread: 0x7fb663616c50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.239 CYLDispatchSourceTest[8301:871191] ♻️线程号：&lt;NSThread: 0x7fb663597ca0&gt;&#123;number = 18, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.245 CYLDispatchSourceTest[8301:871202] ♻️线程号：&lt;NSThread: 0x7fb663617c00&gt;&#123;number = 24, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.247 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 进度：0.5</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.248 CYLDispatchSourceTest[8301:871203] ♻️线程号：&lt;NSThread: 0x7fb663531ab0&gt;&#123;number = 25, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 进度：0.51</span><br><span class="line">2015-09-03 16:48:10.249 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871204] ♻️线程号：&lt;NSThread: 0x7fb66344bbf0&gt;&#123;number = 26, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871133] 进度：0.52</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871133] 进度：0.53</span><br><span class="line">2015-09-03 16:48:10.250 CYLDispatchSourceTest[8301:871205] ♻️线程号：&lt;NSThread: 0x7fb663461d90&gt;&#123;number = 27, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871206] ♻️线程号：&lt;NSThread: 0x7fb66341d370&gt;&#123;number = 28, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871133] 进度：0.54</span><br><span class="line">2015-09-03 16:48:10.251 CYLDispatchSourceTest[8301:871207] ♻️线程号：&lt;NSThread: 0x7fb6634196e0&gt;&#123;number = 29, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.254 CYLDispatchSourceTest[8301:871133] 进度：0.57</span><br><span class="line">2015-09-03 16:48:10.254 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871133] 进度：0.58</span><br><span class="line">2015-09-03 16:48:10.252 CYLDispatchSourceTest[8301:871208] ♻️线程号：&lt;NSThread: 0x7fb66341bd50&gt;&#123;number = 30, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871209] ♻️线程号：&lt;NSThread: 0x7fb66361a070&gt;&#123;number = 31, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.253 CYLDispatchSourceTest[8301:871210] ♻️线程号：&lt;NSThread: 0x7fb663618020&gt;&#123;number = 32, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.255 CYLDispatchSourceTest[8301:871211] ♻️线程号：&lt;NSThread: 0x7fb663612c90&gt;&#123;number = 33, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.256 CYLDispatchSourceTest[8301:871133] 进度：0.59</span><br><span class="line">2015-09-03 16:48:10.257 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.256 CYLDispatchSourceTest[8301:871212] ♻️线程号：&lt;NSThread: 0x7fb6635996d0&gt;&#123;number = 34, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871133] 进度：0.6</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.259 CYLDispatchSourceTest[8301:871213] ♻️线程号：&lt;NSThread: 0x7fb66340bd30&gt;&#123;number = 35, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.260 CYLDispatchSourceTest[8301:871133] 进度：0.61</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.262 CYLDispatchSourceTest[8301:871214] ♻️线程号：&lt;NSThread: 0x7fb66354f4b0&gt;&#123;number = 36, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 进度：0.62</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.264 CYLDispatchSourceTest[8301:871215] ♻️线程号：&lt;NSThread: 0x7fb663531010&gt;&#123;number = 37, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 进度：0.63</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871216] ♻️线程号：&lt;NSThread: 0x7fb66360c6e0&gt;&#123;number = 38, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871176] ♻️线程号：&lt;NSThread: 0x7fb66359ac80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.270 CYLDispatchSourceTest[8301:871133] 进度：0.64</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871198] ♻️线程号：&lt;NSThread: 0x7fb663576ab0&gt;&#123;number = 20, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871189] ♻️线程号：&lt;NSThread: 0x7fb6635121b0&gt;&#123;number = 12, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871188] ♻️线程号：&lt;NSThread: 0x7fb66348e850&gt;&#123;number = 10, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.271 CYLDispatchSourceTest[8301:871192] ♻️线程号：&lt;NSThread: 0x7fb66348db80&gt;&#123;number = 11, name = (null)&#125;</span><br><span class="line">/*＝＝＝＝＝＝＝＝＝＝省略30行带有的 ♻️的打印内容（没有重复的线程号）＝＝＝＝＝＝＝＝*/</span><br><span class="line">2015-09-03 16:48:10.277 CYLDispatchSourceTest[8301:871222] ♻️线程号：&lt;NSThread: 0x7fb66361ca00&gt;&#123;number = 43, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.278 CYLDispatchSourceTest[8301:871223] ♻️线程号：&lt;NSThread: 0x7fb66360c620&gt;&#123;number = 44, name = (null)&#125;</span><br><span class="line">2015-09-03 16:48:10.290 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2015-09-03 16:48:10.293 CYLDispatchSourceTest[8301:871133] 进度：1</span><br><span class="line">2015-09-03 16:48:10.293 CYLDispatchSourceTest[8301:871133] 🔵线程号：&lt;NSThread: 0x7fb6634077a0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>耗时：0.14秒，与之前的2.376秒相比，时间是后者的17倍 ，性能相差很大。</p>
<h3 id="DispatchSource能通过合并事件的方式确保在高负载下正常工作"><a href="#DispatchSource能通过合并事件的方式确保在高负载下正常工作" class="headerlink" title="DispatchSource能通过合并事件的方式确保在高负载下正常工作"></a>DispatchSource能通过合并事件的方式确保在高负载下正常工作</h3><p>然而上例中也因为并发执行，速度相当快，调用 <code>dispatch_source_merge_data</code> 后所触发的 <code>dispatch_source_set_event_handler</code> 的频率也大大减少，有时只会在结束时触发一次。</p>
<p>如果你细心观察下上例中的打印🔵（小蓝点）♻️（小绿点）个数是不一的，但 <code>totalComplete</code> 的值，或者进度条从0.0到1.0的执行是正常，但是🔵（小蓝点）为什么没有被打印？这是因为：</p>
<blockquote>
<p>DispatchSource能通过合并事件的方式确保在高负载下正常工作</p>
</blockquote>
<p>在同一时间，只有一个处理 block 的实例被分配，如果这个处理方法还没有执行完毕，另一个事件就发生了，事件会以指定方式（ADD或 OR）进行累积。DispatchSource能通过合并事件（block）的方式确保在高负载下正常工作。当处理事件被最终执行时，计算后的数据可以通过 <code>dispatch_source_get_data</code> 来获取。这个数据的值在每次响应时间执行后会被重置，所以上面的例子中进度条 <code>totalComplete</code> 的值是最终积累的值，而 block 不是每次都执行的，但打印🔵（小蓝点）♻️（小绿点）个数不一。但能确保进度条能从0.0到1.0的正常执行。</p>
<p>下面我们来演示下如何控制Dispatch Source(分派源)，让它随时暂停，随时恢复：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    [self changeStatus:self.running];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)changeStatus:(BOOL)shouldPause &#123;</span><br><span class="line">    if (shouldPause) &#123;</span><br><span class="line">        [self pause];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resume &#123;</span><br><span class="line">    if (self.running) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;✅恢复Dispatch Source(分派源)&quot;);</span><br><span class="line">    self.running = YES;</span><br><span class="line">    dispatch_resume(_processingQueueSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pause &#123;</span><br><span class="line">    if (!self.running) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;🚫暂停Dispatch Source(分派源)&quot;);</span><br><span class="line">    self.running = NO;</span><br><span class="line">    dispatch_suspend(_processingQueueSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并取消打印线程的 <code>NSLog</code> ，然后使用下图中的快捷键迅速触发 <code>didReceiveMemoryWarning</code>  以切换Dispatch Source(分派源)的状态:</p>
<p><img src="http://i61.tinypic.com/6thjmf.jpg" alt="enter image description here"></p>
<p><img src="http://i59.tinypic.com/suyt0o.jpg" alt="enter image description here"></p>
<p>详见 <code>Demo1</code> 实现（Demo<em>01</em>对DispatchSource实现取消恢复操作_main队列版）。</p>
<h3 id="Dispatch-Source-与-Dispatch-Queue-两者在线程执行上的关系"><a href="#Dispatch-Source-与-Dispatch-Queue-两者在线程执行上的关系" class="headerlink" title="Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系"></a>Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系</h3><p>本节配套代码在  <code>Demo2</code> 中（Demo<em>02</em>对DispatchSource实现取消恢复操作_global队列版）。</p>
<p>答案是：没有关系。两者会独立运行。 Dispatch Queue 像一个生产任务的生产者，而 Dispatch Source 像处理任务的消费者。可以一边异步生产，也可一边异步消费。你可以在任意线程上调用 <code>dispatch_source_merge_data</code> 以触发 <code>dispatch_source_set_event_handler</code> 。而句柄的执行线程，取决于你创建句柄时所指定的线程，如果你像下面这样创建，那么句柄会在主线程执行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的 Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                  dispatch_get_main_queue());</span><br></pre></td></tr></table></figure>
<p>如果你像下面这样创建，那么句柄会在异步线程执行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定 global Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">_processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                dispatch_get_global_queue(0, 0));</span><br></pre></td></tr></table></figure>
<p>详见 <code>Demo2</code> 实现（Demo<em>02</em>对DispatchSource实现取消恢复操作_global队列版）</p>
<h3 id="让-Dispatch-Source-与-Dispatch-Queue-同时实现暂停和恢复"><a href="#让-Dispatch-Source-与-Dispatch-Queue-同时实现暂停和恢复" class="headerlink" title="让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复"></a>让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复</h3><p>本节代码详见 Demo4（Demo<em>04</em>对DispatchQueue实现取消恢复操作_综合版）</p>
<p>你可能已经发现了：上面的代码是有问题的，它只是一种“假暂停”的状态。for 循环还是要执行100遍，循环的次数并没有因你暂停了派发源而暂停，这在实际开发中是不允许的，因为真正的性能瓶颈永远会是在这里，这样的暂停毫无意义。那么如何让 for 循环随时可以暂停？</p>
<p>实际上 <code>Dispatch Queue</code> 没有“取消”这一概念。一旦将处理追加到 <code>Dispatch Queue</code> 中，就没有方法可将该处理去除，也没有方法可在执行中取消该处理。编程人员要么在处理中导入取消这一概念。</p>
<p>要么放弃取消，或者使用 <code>NSOperationQueue</code> 等其他方法。</p>
<p> <code>Dispatch Source</code> 与 <code>Dispatch Queue</code> 不同，是可以取消的。而且取消时必须执行的处理可指定为回调用的Block形式。</p>
<p> <code>Dispatch Source</code>  是如何执行取消的？打个比方：</p>
<p> <code>Dispatch Queue</code> 就好像瓜农种瓜，只要种了瓜，就走上了一条不归路：不管有没有人买，你都必须要好好施肥，好好浇水。没有放弃的余地。</p>
<p> <code>Dispatch Source</code> 就好像买瓜的人，比如你在瓜农种瓜时，告诉瓜农，“你的瓜熟一个我买一个”，等瓜成熟了，你开始买，不断得买，陆续买了100个，突然你感觉吃够了，你不买了，但是瓜还是在不断得成熟着，然后只能烂在地里了。等你突然又想买的时候，地里已经有1000个瓜，你要买，必须全买。。。</p>
<p>回到代码里，也就是说 <code>Dispatch Source</code> 的暂停，只是暂停调用 <code>dispatch_source_set_event_handler</code> ， <code>Dispatch Queue</code> 中的for循环并没有因此暂停，它还是在一直运行着，等你恢复 <code>Dispatch Source</code> 的时候， <code>Dispatch Queue</code> 可能已经运行结束。然后你就会像上面的gif图中那样，从“进度：0.9”暂停，恢复时直接跳到“进度：1”，跳过了中间的“进度：0.91”、“进度：0.92”、“进度：0.93”等等。所以说这是一种“假暂停”。</p>
<p>那么如何在处理中导入取消这一概念？代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">__block BOOL isCanceled = NO;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    if (isCanceled) &#123;</span><br><span class="line">        return;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    NSData *thumbnailData = [NSURLConnection sendSynchronousRequest:request];</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>完整的代码则需要做如下修改：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //1.</span><br><span class="line">    // 指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class="line">    _processingQueueSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0,</span><br><span class="line">                                                    dispatch_get_main_queue());</span><br><span class="line">    __block NSUInteger totalComplete = 0;</span><br><span class="line">    dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">        //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class="line">        NSUInteger value = dispatch_source_get_data(_processingQueueSource);</span><br><span class="line">        totalComplete += value;</span><br><span class="line">        NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/CYLTotalNumber));</span><br><span class="line">    &#125;);</span><br><span class="line">    //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class="line">    [self resume];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //2.</span><br><span class="line">    //恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class="line">    //为了便于观察，将_queue做成“串行队列”</span><br><span class="line">    _queue = dispatch_queue_create(&quot;com.ioschengxuyuan.queue1&quot;, 0);</span><br><span class="line">    NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;启动队列&quot;);</span><br><span class="line">    for (NSUInteger index = 0; index &lt; CYLTotalNumber; index++) &#123;</span><br><span class="line">        dispatch_async(_queue, ^&#123;</span><br><span class="line">            if (!self.running) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">            usleep(200000);//0.2秒</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    [self changeStatus:self.running];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)changeStatus:(BOOL)shouldPause &#123;</span><br><span class="line">    if (shouldPause) &#123;</span><br><span class="line">        [self pause];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resume &#123;</span><br><span class="line">    if (self.running) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;✅恢复Dispatch Source(分派源)以及_queue&quot;);</span><br><span class="line">    self.running = YES;</span><br><span class="line">    dispatch_resume(_processingQueueSource);</span><br><span class="line">    if (_queue) &#123;</span><br><span class="line">        dispatch_resume(_queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pause &#123;</span><br><span class="line">    if (!self.running) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;🚫暂停Dispatch Source(分派源)以及_queue&quot;);</span><br><span class="line">    self.running = NO;</span><br><span class="line">    dispatch_suspend(_processingQueueSource);</span><br><span class="line">    dispatch_suspend(_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://i61.tinypic.com/33m06er.jpg" alt="enter image description here"></p>
<p>详见 Demo4（Demo<em>04</em>对DispatchQueue实现取消恢复操作_综合版）</p>
<h2 id="Parse-“离线存储对象”操作的代码摘录"><a href="#Parse-“离线存储对象”操作的代码摘录" class="headerlink" title="Parse “离线存储对象”操作的代码摘录"></a>Parse “离线存储对象”操作的代码摘录</h2><p>句柄如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">    [self _runCommands];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>何时会调用句柄？ 下面将 Parse 里涉及调用句柄的语句罗列一下， 因为摘录的代码不完整，可能并不能看出使用的完整过程。所以可以大致预览一下，详情可以查看Parse 源码，并且我已将这些逻辑浓缩为可运行的 Demo，也可搭配理解。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    dispatch_source_set_event_handler(_processingQueueSource, ^&#123;</span><br><span class="line">        [self _runCommands];</span><br><span class="line">    &#125;);</span><br><span class="line">    [self resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)resume &#123;</span><br><span class="line">    if (self.running) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.running = YES;</span><br><span class="line">    dispatch_resume(_processingQueueSource);</span><br><span class="line">    dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听网络状态，一旦网络重连上之后，设置 connected属性为 YES，并重写其 setter 方法，调用 <code>dispatch_source_merge_data</code> 进行发送消息的操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*! Manually sets the network connection status. */</span><br><span class="line">- (void)setConnected:(BOOL)connected &#123;</span><br><span class="line">    BFTaskCompletionSource *barrier = [BFTaskCompletionSource taskCompletionSource];</span><br><span class="line">    dispatch_async(_processingQueue, ^&#123;</span><br><span class="line">        dispatch_sync(_synchronizationQueue, ^&#123;</span><br><span class="line">            if (self.connected != connected) &#123;</span><br><span class="line">                _connected = connected;</span><br><span class="line">                if (connected) &#123;</span><br><span class="line">                    dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        barrier.result = nil;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (connected) &#123;</span><br><span class="line">        dispatch_async(_synchronizationQueue, ^&#123;</span><br><span class="line">            if (_retryingSemaphore) &#123;</span><br><span class="line">                dispatch_semaphore_signal(_retryingSemaphore);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    [barrier.task waitForResult:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)_didEnqueueCommand:(id&lt;PFNetworkCommand&gt;)command</span><br><span class="line">            withIdentifier:(NSString *)identifier</span><br><span class="line">      taskCompletionSource:(BFTaskCompletionSource *)taskCompletionSource &#123;</span><br><span class="line">    PFAssertIsOnDispatchQueue(_synchronizationQueue);</span><br><span class="line"></span><br><span class="line">    _taskCompletionSources[identifier] = taskCompletionSource;</span><br><span class="line">    dispatch_source_merge_data(_processingQueueSource, 1);</span><br><span class="line"></span><br><span class="line">    if (_retryingSemaphore) &#123;</span><br><span class="line">        dispatch_semaphore_signal(_retryingSemaphore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dispatch-Semaphore-信号量"><a href="#Dispatch-Semaphore-信号量" class="headerlink" title="Dispatch Semaphore 信号量"></a><code>Dispatch Semaphore</code> 信号量</h2><p>为了展示作用，举个反例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;%@&quot;,  @([array count]));</span><br></pre></td></tr></table></figure>
<p>运行结果绝对大跌眼镜：</p>
<p>我运行了三次，三次结果均不一致：</p>
<ol>
<li><p>第一次：崩溃。。。</p>
<p><img src="http://i67.tinypic.com/29vxt9w.jpg" alt="enter image description here"></p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CYLDispatchSemaphoreTest(10384,0x112d43000) malloc: *** error for object 0x7f898487ca00: pointer being freed was not allocated</span><br><span class="line">*** set a breakpoint in malloc_error_break to debug</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>第二次：不够。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-09-07 00:42:20.145 CYLDispatchSemaphoreTest[10417:779722] 99996</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三次：还是不够。。。</p>
</li>
</ol>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-09-07 00:42:52.734 CYLDispatchSemaphoreTest[10438:780505] 99949</span><br></pre></td></tr></table></figure>
<p>这种资源抢夺的情况，一般的做法是使用串行队列，或者像下面一样的同步队列，得以解决：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">   NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">   for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">       dispatch_sync(queue, ^&#123;</span><br><span class="line">           [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   NSLog(@&quot;%@&quot;, @([array count]));</span><br></pre></td></tr></table></figure>
<p>下面展示下展示使用 <code>dispatch_semaphore_t</code> 的解决方案：</p>
<p> <code>dispatch_semaphore_t</code> 的作用之一就是解决这种资源抢夺的情况，下面展示下使用 <code>dispatch_semaphore_t</code> 实现一个资源锁：</p>
<p>以下源码详见 Demo6（Demo<em>06</em>展示dispatch_semaphore_t基本用法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //因为用到了dispatch_barrier_async，该函数只能搭配自定义并行队列dispatch_queue_t使用。所以不能使用：dispatch_get_global_queue</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.ioschengxuyuan.gcd.ForBarrier&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    /*</span><br><span class="line">     *</span><br><span class="line">     *生成Dispatch Semaphore</span><br><span class="line">     Dispatch Semaphore 的计数初始值设定为“1”</span><br><span class="line">     (该初始值的1与下文中两个函数dispatch_semaphore_wait与dispatch_semaphore_signal进行的减1、加1里的1没有必然联系。</span><br><span class="line">     </span><br><span class="line">     就算初始值是100，两个函数dispatch_semaphore_wait与dispatch_semaphore_signal还是会减“1”、加“1”)。</span><br><span class="line">     保证可访问 NSMutableArray 类对象的线程</span><br><span class="line">     同时只能有1个</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1) ;</span><br><span class="line">    NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">    for(int i = 0; i&lt; 100000; ++i) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            /*</span><br><span class="line">             *</span><br><span class="line">             *等待Dispatch Semaphore</span><br><span class="line">             *一直等待，直到Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) ;</span><br><span class="line">            /*</span><br><span class="line">             *由于Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">             *所以将Dispatch Semaphore的计数值减去1</span><br><span class="line">             *dispatch_semaphore_wait 函数执行返回。</span><br><span class="line">             *即执行到此时的</span><br><span class="line">             *Dispatch Semaphore 的计数值恒为0</span><br><span class="line">             *</span><br><span class="line">             *由于可访问NSMutaleArray类对象的线程</span><br><span class="line">             *只有一个</span><br><span class="line">             *因此可安全地进行更新</span><br><span class="line">             *</span><br><span class="line">             */</span><br><span class="line">            NSLog(@&quot;🔴%@&quot;,[NSThread currentThread]);</span><br><span class="line">            [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">            /*</span><br><span class="line">             *</span><br><span class="line">             *排他控制处理结束，</span><br><span class="line">             *所以通过dispatch_semaphore_signal函数</span><br><span class="line">             *将Dispatch Semaphore的计数值加1</span><br><span class="line">             *如果有通过dispatch_semaphore_wait函数</span><br><span class="line">             *等待Dispatch Semaphore的计数值增加的线程，</span><br><span class="line">             ★就由最先等待的线程执行。</span><br><span class="line">             */</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     *</span><br><span class="line">     等为数组遍历添加元素后，检查下数组的成员个数是否正确</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @([array count]));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了加深对dispatch_semaphore_t基本用法的理解，再给一个示例 Demo：</p>
<p>思考下为何会如何打印：<br>然后再分别试一下第三行和第四行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br></pre></td></tr></table></figure>
<p>然后观察下打印。</p>
<p>详见 Demo5（Demo<em>05</em>展示dispatch_semaphore_t基本用法）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">//    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);//等待一秒</span><br><span class="line">    //dispatch_time_t time = DISPATCH_TIME_FOREVER;//永久等待</span><br><span class="line">    NSLog(@&quot;begin ==&gt;  车库开始营业了！&quot;);</span><br><span class="line">    /*</span><br><span class="line">     *</span><br><span class="line">     如果 semphore 的值等于0，就阻塞1秒钟，才会往下照常进行；</span><br><span class="line">     如果大于等于1则往下进行并将 semphore 进行减1处理。</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    long result = dispatch_semaphore_wait(semaphore, time);</span><br><span class="line">    if (result == 0) &#123;</span><br><span class="line">        /*</span><br><span class="line">         *</span><br><span class="line">         *由子Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">         *或者在待机中的指定时间内</span><br><span class="line">         *Dispatch Semaphore的计数值达到大于等于1</span><br><span class="line">         所以Dispatch Semaphore的计数值减去1</span><br><span class="line">         可执行需要进行排他控制的处理.</span><br><span class="line">         可以理解为：没有阻塞的线程了。</span><br><span class="line">         就好比：车库有一个或一个以上的车位，只来了一辆车，所以“无需等待”</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line">        NSLog(@&quot;result = 0 ==&gt; 有车位，无需等待！==&gt; 在这里可安全地执行【需要排他控制的处理（比如只允许一条线程为mutableArray进行addObj操作）】&quot;);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);//使用signal以确保编译器release掉dispatch_semaphore_t时的值与初始值一致， 否则会EXC_BAD_INSTRUCTION ,见http://is.gd/EaJgk5</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*</span><br><span class="line">         *</span><br><span class="line">         *由于Dispatch Semaphore的计数值为0</span><br><span class="line">         .因此在达到指定时间为止待机</span><br><span class="line">         这个else里发生的事情，就好比：车库没车位，来了一辆车，等待了半个小时后，做出的一些事情。</span><br><span class="line">         比如：忍受不了，走了。。</span><br><span class="line">         *</span><br><span class="line">         */</span><br><span class="line">        NSLog(@&quot;result != 0 ==&gt; timeout，deadline，忍受不了，走了。。&quot;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试"><a href="#在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试" class="headerlink" title="在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试"></a>在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试</h3><p>下面是 Parse 的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> @interface PFEventuallyQueueTestHelper : NSObject &#123;</span><br><span class="line">    dispatch_semaphore_t events[PFEventuallyQueueEventCount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clear;</span><br><span class="line">- (void)notify:(PFEventuallyQueueTestHelperEvent)event;</span><br><span class="line">- (BOOL)waitFor:(PFEventuallyQueueTestHelperEvent)event;</span><br></pre></td></tr></table></figure>
<p>注释是这样写的：</p>
<blockquote>
<p>PFEventuallyQueueTestHelper gets notifications of various events happening in the command cache,<br>// so that tests can be synchronized. See CommandTests.m for examples of how to use this.</p>
</blockquote>
<p>强制把异步任务转换为同步任务来方便进行单元测试。这个用途信号量是最合适的用途。但注意并不推荐应用到除此之外的其它场景！</p>
<p>这种异步转同步便于单元测试的用法类似于下面的写法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define WAIT_FOREVER [self waitForStatus:XCTAsyncTestCaseStatusSucceeded timeout:DBL_MAX];</span><br><span class="line">#define NOTIFY [self notify:XCTAsyncTestCaseStatusSucceeded];</span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)testInstallationMutated &#123;</span><br><span class="line">    NSDictionary *dict = [self jsonWithFileName:@&quot;TestInstallationSave&quot;];</span><br><span class="line">    AVInstallation *installation = [AVInstallation currentInstallation];</span><br><span class="line">    [installation objectFromDictionary:dict];</span><br><span class="line">    [installation setObject:@(YES) forKey:@&quot;enableNoDisturb&quot;];</span><br><span class="line">    [installation saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) &#123;</span><br><span class="line">        XCTAssertNil(error);</span><br><span class="line">        NOTIFY;</span><br><span class="line">    &#125;];</span><br><span class="line">    WAIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量属性底层工具，他虽然非常强大，但在多数需要使用它的场合，最好从设计角度重新考虑，看是否可以不用，应该优先考虑使用诸如操作队列这样的高级工具。通常可以通过增加一个分派队列配合  <code>dispatch_suspend</code> ，或者通过其它方式分解操作来避免使用信号量。信号量并非不好，只是它本身是锁，能不使用就不用。尽量用 cocoa 框架中的高级抽象，信号量非常接近底层。所以除了上面的例子是最佳应用场景外，不推荐应用到除此之外的其它场景！</p>
<p> <a href="http://www.cnblogs.com/snailHL/p/3906112.html" target="_blank" rel="noopener">《关于dispatch_semaphore的使用》</a> 中有这样的描述：</p>
<p>关于信号量，一般可以用停车来比喻。</p>
<blockquote>
<p>　　停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。</p>
<p>　　信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，</p>
<p>　　dispatch_semaphore_signal，就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value））</p>
<p>　　调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；</p>
<p>　　当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主</p>
<p>　　没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，</p>
<p>　　所以就一直等下去。</p>
</blockquote>
<p> <a href="http://m.blog.csdn.net/blog/choudang/38121827" target="_blank" rel="noopener">《GCD dispatch_semaphore 信号量 协调线程同步》</a> 也有类似的比喻：</p>
<blockquote>
<p>以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。<br></p> 在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。<br>更进一步，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。 当一个线程调用Wait（等待）操作时，它要么通过然后将信号量减一，要么一直等下去，直到信号量大于一或超时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为加操作实际上是释放了由信号量守护的资源。<p></p>
</blockquote>
<p>这个比喻里可以用一个表格来表示：</p>
<table>
<thead>
<tr>
<th>喻体</th>
<th>本体</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>车位</td>
<td>信号量</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td>剩余几个车位</td>
<td>最大并发线程</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td>看门人起的作用</td>
<td>信号量的作用</td>
<td><code>dispatch_semaphore_t</code>  </td>
</tr>
<tr>
<td>车</td>
<td>线程</td>
<td>代码 </td>
</tr>
<tr>
<td>耐心的极限时间</td>
<td>超时时间</td>
<td><code>dispatch_semaphore_wait</code>  </td>
</tr>
<tr>
<td>逛街结束走了，离开车位</td>
<td>signal+1</td>
<td><code>dispatch_semaphore_signal</code>  </td>
</tr>
</tbody>
</table>
<h3 id="使用Dispatch-Semaphore控制并发线程数量"><a href="#使用Dispatch-Semaphore控制并发线程数量" class="headerlink" title="使用Dispatch Semaphore控制并发线程数量"></a>使用<code>Dispatch Semaphore</code>控制并发线程数量</h3><p>正如文章开头所说：从 iOS7 升到 iOS8 后，GCD 出现了一个重大的变化：在 iOS7 时，使用 GCD 的并行队列，  <code>dispatch_async</code>  最大开启的线程一直能控制在6、7条，线程数都是个位数，然而 iOS8后，最大线程数一度可以达到40条、50条。然而在文档上并没有对这一做法的目的进行介绍。</p>
<p>笔者推测 Apple 的目的是想借此让开发者使用 <code>NSOperationQueue</code> ：GCD 中 Apple 并没有提供控制并发数量的接口，而  <code>NSOperationQueue</code>  有，如果需要使用 GCD 实现，需要使用 GCD 的一项高级功能：<code>Dispatch Semaphore</code>信号量。</p>
<p>详见 Demo7（Demo<em>07</em>展示dispatch_semaphore_t控制线程并发数量的用法）</p>
<p>Demo7中使用了 <a href="http://mp.weixin.qq.com/s?__biz=MzAxNDAzMzk0MQ==&amp;mid=203702345&amp;idx=1&amp;sn=226f6f784d37b89718f6949c9214e1e6&amp;scene=1&amp;srcid=kl2ZmcSfYHuB6bMvYPEq#rd" target="_blank" rel="noopener">这篇博文</a> 中的例子。</p>
<p><code>Dispatch Semaphore</code>信号量的使用在上文中已经介绍过，那么就直接上 Demo：</p>
<p>主要做的就是将上文中 <code>dispatch_semaphore_t</code> 的个数设置为一个可变参数：这样就达到了控制并行线程数量的目的：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *</span><br><span class="line"> 简单版本：无专门控制并发等待的线程，缺点阻塞主线程，可以跑一下 demo，你会发现主屏幕上的按钮是不可点击的</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">void dispatch_async_limit(dispatch_queue_t queue,NSUInteger limitSemaphoreCount, dispatch_block_t block) &#123;</span><br><span class="line">    //控制并发数的信号量</span><br><span class="line">    static dispatch_semaphore_t limitSemaphore;</span><br><span class="line">    //专门控制并发等待的线程</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //使用 dispatch_once而非 lazy 模式，防止可能的多线程抢占问题</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        limitSemaphore = dispatch_semaphore_create(limitSemaphoreCount);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        //可用信号量后才能继续，否则等待</span><br><span class="line">        dispatch_semaphore_wait(limitSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            !block ? : block();</span><br><span class="line">            //在该工作线程执行完成后释放信号量</span><br><span class="line">            dispatch_semaphore_signal(limitSemaphore);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能发现，这段代码有问题阻塞了当前线程，Demo7中也给出了改良版，可以看下。</p>
<h3 id="为-NSURLSession-添加同步方法"><a href="#为-NSURLSession-添加同步方法" class="headerlink" title="为  NSURLSession 添加同步方法"></a>为  NSURLSession 添加同步方法</h3><p>NSURLSession 取消了同步方法，但是可以借助信号量来实现：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse *__autoreleasing *)response error:(NSError *__autoreleasing *)error &#123;</span><br><span class="line">    __block NSData *data = nil;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *taskData, NSURLResponse *taskResponse, NSError *taskError) &#123;</span><br><span class="line">        data = taskData;</span><br><span class="line"></span><br><span class="line">        if (response)</span><br><span class="line">            *response = taskResponse;</span><br><span class="line"></span><br><span class="line">        if (error)</span><br><span class="line">            *error = taskError;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;] resume];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是也要思考下为什么 Apple 取消了同步方法：同步方法的风险远远超过受益。</p>
<p>要注意：</p>
<ul>
<li>除非万不得已，否则永远不要尝试在主线程上发送同步的网络请求</li>
<li>尽量只在后台线程中独占线程发送同步的网络请求</li>
</ul>
<p>风险如下所示：</p>
<h4 id="导致Watchdog超时"><a href="#导致Watchdog超时" class="headerlink" title="导致Watchdog超时"></a>导致Watchdog超时</h4><p>关于Watchdog超时：</p>
<p>在  <a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html" target="_blank" rel="noopener"> <strong><em>QA1693：Synchronous Networking On The Main Thread</em></strong> </a><br>文档中描述了Watchdog机制，包括生效场景和表现。如果我们的应用程序对一些特定的UI事件（比如启动、挂起、恢复、结束）响应不及时，Watchdog会把我们的应用程序干掉，并生成一份响应的crash报告。</p>
<p>这份crash报告的有趣之处在于异常代码：“0x8badf00d”，即“ate bad food”。<br>如果说特定的UI事件比较抽象，那么用代码来直接描述的话，对应的就是（创建一个工程时Xcode自动生成的）UIApplicationDelegate的几个方法：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</span><br><span class="line">    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.</span><br><span class="line">    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span><br><span class="line">    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</span><br><span class="line">    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</span><br><span class="line">    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</span><br><span class="line">    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当遇到Watchdog日志时，可以检查下上面几个方法是否有比较重的阻塞UI的动作。</p>
<p><a href="https://developer.apple.com/library/ios/qa/qa1693/_index.html" target="_blank" rel="noopener"> <strong><em>QA1693：Synchronous Networking On The Main Thread</em></strong> </a> 举的例子就是在主线程进行同步网络请求。如果我们是在公司的Wifi环境下使用则一切顺利，但当应用程序发布出去面向很大范围的用户，在各种网络环境下运行，则不可避免地会出现一片Watchdog超时报告。<br>另一种可能出现问题的场景就是数据量比较大的情况下进行的数据库版本迁移（同样是在主线程上）。</p>
<h4 id="失去了-cancel-的机会："><a href="#失去了-cancel-的机会：" class="headerlink" title="失去了 cancel 的机会："></a>失去了 cancel 的机会：</h4><p>不能像异步那样进行下面的操作：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(IBAction)cancelUpload:(id)sender &#123;</span><br><span class="line">    if (_uploadTask.state == NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [_uploadTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <a href="http://blog.csdn.net/jasonblog/article/details/19031517" target="_blank" rel="noopener">《iOS应用的crash日志的分析基础》</a> </p>
<p>参考链接： <a href="https://github.com/ParsePlatform/Parse-SDK-iOS-OSX" target="_blank" rel="noopener">GitHub:Parse-SDK-iOS-OSX源码</a> </p>
<hr>
<p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/IOS/" rel="tag"># IOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/13/GCD扫盲篇/" rel="next" title="GCD">
                <i class="fa fa-chevron-left"></i> GCD
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/16/iOS网络缓存扫盲篇/" rel="prev" title="网络缓存基础">
                网络缓存基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">------ IOS | Python ------</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法"><span class="nav-number">1.</span> <span class="nav-text">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Parse-iOS-SDK介绍"><span class="nav-number">1.1.</span> <span class="nav-text">Parse-iOS-SDK介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parse-的“离线存储对象”操作介绍"><span class="nav-number">1.2.</span> <span class="nav-text">Parse 的“离线存储对象”操作介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parse-的“离线存储对象”实现介绍"><span class="nav-number">1.3.</span> <span class="nav-text">Parse 的“离线存储对象”实现介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Source-的使用步骤"><span class="nav-number">1.4.</span> <span class="nav-text">Dispatch Source 的使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步：创建一个Dispatch-Source"><span class="nav-number">1.4.1.</span> <span class="nav-text">第一步：创建一个Dispatch Source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：创建Dispatch-Source的事件处理方法"><span class="nav-number">1.4.2.</span> <span class="nav-text">第二步：创建Dispatch Source的事件处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三步：处理Dispatch-Source的暂停与恢复操作"><span class="nav-number">1.4.3.</span> <span class="nav-text">第三步：处理Dispatch Source的暂停与恢复操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四步：向Dispatch-Source发送事件"><span class="nav-number">1.4.4.</span> <span class="nav-text">第四步：向Dispatch Source发送事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD真的不能像OperationQueue那样终止任务？"><span class="nav-number">2.</span> <span class="nav-text">GCD真的不能像OperationQueue那样终止任务？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#完整例子Demo1：让-Dispatch-Source-“帮”-Dispatch-Queue-实现暂停和恢复功能"><span class="nav-number">2.0.1.</span> <span class="nav-text">完整例子Demo1：让 Dispatch Source “帮” Dispatch Queue 实现暂停和恢复功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DispatchSource能通过合并事件的方式确保在高负载下正常工作"><span class="nav-number">2.0.2.</span> <span class="nav-text">DispatchSource能通过合并事件的方式确保在高负载下正常工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Source-与-Dispatch-Queue-两者在线程执行上的关系"><span class="nav-number">2.0.3.</span> <span class="nav-text">Dispatch Source 与 Dispatch Queue 两者在线程执行上的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让-Dispatch-Source-与-Dispatch-Queue-同时实现暂停和恢复"><span class="nav-number">2.0.4.</span> <span class="nav-text">让 Dispatch Source 与 Dispatch Queue 同时实现暂停和恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parse-“离线存储对象”操作的代码摘录"><span class="nav-number">2.1.</span> <span class="nav-text">Parse “离线存储对象”操作的代码摘录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Semaphore-信号量"><span class="nav-number">2.2.</span> <span class="nav-text">Dispatch Semaphore 信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试"><span class="nav-number">2.2.1.</span> <span class="nav-text">在项目中的应用：强制把异步任务转换为同步任务来方便进行单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Dispatch-Semaphore控制并发线程数量"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用Dispatch Semaphore控制并发线程数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为-NSURLSession-添加同步方法"><span class="nav-number">2.2.3.</span> <span class="nav-text">为  NSURLSession 添加同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导致Watchdog超时"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">导致Watchdog超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#失去了-cancel-的机会："><span class="nav-number">2.2.3.2.</span> <span class="nav-text">失去了 cancel 的机会：</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


 <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v</div>
-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v="></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v="></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
