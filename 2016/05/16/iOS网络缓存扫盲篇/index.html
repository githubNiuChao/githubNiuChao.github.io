<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">





  <meta name="keywords" content="IOS," />










<meta name="description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求目录  当我们在谈论缓存的时候，我们在谈论什么？  GET网络请求缓存  80%的缓存需求：两行代码就可满足  控制缓存的有效性    文件缓存：借助ETag或Last-Modified判断文件缓存是否有效  Last-Modif">
<meta name="keywords" content="IOS">
<meta property="og:type" content="article">
<meta property="og:title" content="网络缓存基础">
<meta property="og:url" content="http://www.niu-chao.top/2016/05/16/iOS网络缓存扫盲篇/index.html">
<meta property="og:site_name" content="一头驮砖的牛">
<meta property="og:description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求目录  当我们在谈论缓存的时候，我们在谈论什么？  GET网络请求缓存  80%的缓存需求：两行代码就可满足  控制缓存的有效性    文件缓存：借助ETag或Last-Modified判断文件缓存是否有效  Last-Modif">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i67.tinypic.com/3097yvc.jpg">
<meta property="og:image" content="http://i66.tinypic.com/r6wrgx.jpg">
<meta property="og:image" content="http://i68.tinypic.com/3yhhx.jpg">
<meta property="og:updated_time" content="2018-04-13T10:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络缓存基础">
<meta name="twitter:description" content="转载：https://github.com/ChenYilong/ParseSourceCodeStudy  iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求目录  当我们在谈论缓存的时候，我们在谈论什么？  GET网络请求缓存  80%的缓存需求：两行代码就可满足  控制缓存的有效性    文件缓存：借助ETag或Last-Modified判断文件缓存是否有效  Last-Modif">
<meta name="twitter:image" content="http://i67.tinypic.com/3097yvc.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.niu-chao.top/2016/05/16/iOS网络缓存扫盲篇/"/>






<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

  <title>网络缓存基础 | 一头驮砖的牛</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>


    <a href="https://github.com/githubNiuChao" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一头驮砖的牛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.niu-chao.top/2016/05/16/iOS网络缓存扫盲篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一头驮砖的牛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络缓存基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-16T12:31:45+08:00">
                2016-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p><a href="https://github.com/ChenYilong/ParseSourceCodeStudy#转载" target="_blank" rel="noopener">转载：https://github.com/ChenYilong/ParseSourceCodeStudy</a> </p>
<h1 id="iOS网络缓存扫盲篇–使用两行代码就能完成80-的缓存需求"><a href="#iOS网络缓存扫盲篇–使用两行代码就能完成80-的缓存需求" class="headerlink" title="iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求"></a>iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求</h1><p>目录</p>
<ol>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#当我们在谈论缓存的时候我们在谈论什么" target="_blank" rel="noopener">当我们在谈论缓存的时候，我们在谈论什么？</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#get网络请求缓存" target="_blank" rel="noopener">GET网络请求缓存</a> <ol>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#80的缓存需求两行代码就可满足" target="_blank" rel="noopener">80%的缓存需求：两行代码就可满足</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#控制缓存的有效性" target="_blank" rel="noopener">控制缓存的有效性</a>   </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#文件缓存借助etag或last-modified判断文件缓存是否有效" target="_blank" rel="noopener">文件缓存：借助ETag或Last-Modified判断文件缓存是否有效</a> <ol>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#last-modified" target="_blank" rel="noopener">Last-Modified</a> </li>
</ol>
</li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#etag" target="_blank" rel="noopener">ETag</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#总结" target="_blank" rel="noopener">总结</a> </li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#一般数据类型借助-last-modified-与--etag-进行缓存" target="_blank" rel="noopener">一般数据类型借助 Last-Modified 与 ETag 进行缓存</a> </li>
</ol>
</li>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse的网络缓存与离线存储/iOS网络缓存扫盲篇.md#剩下20的网络缓存需求" target="_blank" rel="noopener">剩下20%的网络缓存需求–真的有NSURLCache 不能满足的需求？</a> </li>
</ol>
<p>由于微信、QQ、微博、这类的应用使用缓存很“重”，使一般的用户也对缓存也非常习惯。缓存已然成为必备。</p>
<blockquote>
<p>缓存的目的的以空间换时间</p>
</blockquote>
<p>这句话在动辄就是 300M、600M 的大应用上，得到了很好的诠释。但能有缓存意识的公司，还在少数。</p>
<blockquote>
<p>只有你真正感受到痛的时候，你才会考虑使用缓存。</p>
</blockquote>
<p>这个痛可能是：</p>
<p>服务器压力、客户端网络优化、用户体验等等。</p>
<h3 id="当我们在谈论缓存的时候，我们在谈论什么？"><a href="#当我们在谈论缓存的时候，我们在谈论什么？" class="headerlink" title="当我们在谈论缓存的时候，我们在谈论什么？"></a>当我们在谈论缓存的时候，我们在谈论什么？</h3><p>我们今天将站在小白用户的角度，给缓存这个概念进行重新的定义。</p>
<p>缓存有不同的分类方法：</p>
<p><img src="http://i67.tinypic.com/3097yvc.jpg" alt="enter image description here"></p>
<p>这里所指的缓存，是一个宽泛的概念。</p>
<p>我们这里主要按照功能进行划分：</p>
<p><img src="http://i66.tinypic.com/r6wrgx.jpg" alt="enter image description here"></p>
<table>
<thead>
<tr>
<th>对比项目</th>
<th>第一种</th>
<th>第二种</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的</td>
<td>优化型缓存</td>
<td>功能型缓存</td>
</tr>
<tr>
<td>具体描述</td>
<td>出于优化考虑：服务器压力、用户体验、为用户剩流量等等。同时优化型缓存也有内存缓存和磁盘缓存之分。</td>
<td>App离线也能查看，出于功能考虑，属于存储范畴</td>
</tr>
<tr>
<td>常见概念</td>
<td>GET网络请求缓存、WEB缓存</td>
<td>离线存储</td>
</tr>
<tr>
<td>典型应用</td>
<td>微信首页的会话列表、微信头像、朋友圈、网易新闻新闻列表、</td>
<td>微信聊天记录、</td>
</tr>
<tr>
<td>Parse对应的类</td>
<td>PFCachedQueryController</td>
<td>PFOfflineStore</td>
</tr>
</tbody>
</table>
<p>重度使用缓存的App：  微信、微博、网易新闻、携程、去哪儿等等。</p>
<h2 id="GET网络请求缓存"><a href="#GET网络请求缓存" class="headerlink" title="GET网络请求缓存"></a>GET网络请求缓存</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>首先要知道，POST请求不能被缓存，只有 GET 请求能被缓存。因为从数学的角度来讲，GET 的结果是 <code>幂等</code> 的，就好像字典里的 key 与 value 就是<code>幂等</code>的，而 POST 不 <code>幂等</code> 。缓存的思路就是将查询的参数组成的值作为 key ，对应结果作为value。从这个意义上说，一个文件的资源链接，也叫 GET 请求，下文也会这样看待。</p>
<h3 id="80-的缓存需求：两行代码就可满足"><a href="#80-的缓存需求：两行代码就可满足" class="headerlink" title="80%的缓存需求：两行代码就可满足"></a>80%的缓存需求：两行代码就可满足</h3><p>设置缓存只需要三个步骤：</p>
<p>第一个步骤：请使用 GET 请求。</p>
<p>第二个步骤：</p>
<p>如果你已经使用 了 GET 请求，iOS 系统 SDK 已经帮你做好了缓存。你需要的仅仅是设置下内存缓存大小、磁盘缓存大小、以及缓存路径。甚至这两行代码不设置也是可以的，会有一个默认值。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLCache</span> *urlCache = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> diskCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span> diskPath:<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">NSURLCache</span> setSharedURLCache:urlCache];</span><br></pre></td></tr></table></figure>
<p>第三个步骤：没有第三步！</p>
<p>你只要设置了这两行代码，基本就可满足80%的缓存需求。AFNetworking 的作者 Mattt曾经说过：</p>
<blockquote>
<p>无数开发者尝试自己做一个简陋而脆弱的系统来实现网络缓存的功能，殊不知 <code>NSURLCache</code> 只要两行代码就能搞定且好上 100 倍。</p>
</blockquote>
<p>（AFN 是不是在暗讽 SDWebImage 复杂又蹩脚的缓存机制？？）</p>
<p>要注意</p>
<ul>
<li>iOS 5.0开始，支持磁盘缓存，但仅支持 HTTP</li>
<li><p>iOS 6.0开始，支持 HTTPS 缓存</p>
<p>如果不设置自定义路径，也就是设置 NSURLCache 时 <code>diskPath</code> 部分传参数时，传入nil坑比较少，但是如果传入自定义路径，那么坑比较多需要注意：</p>
</li>
</ul>
<p>设置自定义路径时需要注意：</p>
<ul>
<li>设置 NSURLCache 时 <code>diskPath</code> 部分传参数时，注意只需要写文件夹名字即可，不需要写全路径。比如传入 <code>@&quot;123&quot;</code> 就会自动创建 <code>Library/Caches/{bundleid}/123/</code>。</li>
<li>重复设置 NSURLCache 时需要注意：如果先设置的默认路径，之后再设置自定义路径的 NSURLCache 时，如果设置前已经发生网络请求，并且已经在默认路径中写入了数据，那么就会出现错乱：虽然在新自定义路径中保存了cache，但读 cache 还是会从默认路径读取，造成每次都找不到cache而重新请求。</li>
<li>设置自定义路径后，之前默认的 cache 并不会清除。需要手动删除 <code>[[NSURLCache sharedURLCache] removeAllCachedResponses];</code>，记得在设置新缓存之前删除，否则 <code>[NSURLCache sharedURLCache]</code> 返回的就是旧有的缓存。可以升级app时删除，也可以在设置自定义路径时删除，做法参考 MRC 的 setter 操作。</li>
</ul>
<h3 id="控制缓存的有效性"><a href="#控制缓存的有效性" class="headerlink" title="控制缓存的有效性"></a>控制缓存的有效性</h3><p>我们知道：</p>
<ul>
<li>只要是缓存，总会过期。</li>
</ul>
<p>那么缓存的过期时间如何控制？</p>
<p>上文中的两行代码，已经给出了一个方法，指定超时时间。但这并也许不能满足我们的需求，如果我们对数据的一致性，时效性要求很高，即使1秒钟后数据更改了，客户端也必须展示更改后的数据。这种情况如何处理？</p>
<p>下面我们将对这种需求，进行解决方案的介绍。顺序是这样的：先从文件类型的缓存入手，引入两个概念。然后再谈下，一般数据类型比如 JSON 返回值的缓存处理。</p>
<h3 id="文件缓存：借助ETag或Last-Modified判断文件缓存是否有效"><a href="#文件缓存：借助ETag或Last-Modified判断文件缓存是否有效" class="headerlink" title="文件缓存：借助ETag或Last-Modified判断文件缓存是否有效"></a>文件缓存：借助ETag或Last-Modified判断文件缓存是否有效</h3><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>服务器的文件存贮，大多采用资源变动后就重新生成一个链接的做法。而且如果你的文件存储采用的是第三方的服务，比如七牛、青云等服务，则一定是如此。</p>
<p>这种做法虽然是推荐做法，但同时也不排除不同文件使用同一个链接。那么如果服务端的file更改了，本地已经有了缓存。如何更新缓存？</p>
<p>这种情况下需要借助 <code>ETag</code> 或 <code>Last-Modified</code> 判断图片缓存是否有效。</p>
<p> <code>Last-Modified</code> 顾名思义，是资源最后修改的时间戳，往往与缓存时间进行对比来判断缓存是否过期。</p>
<p>   在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记此文件在服务期端最后被修改的时间，格式类似这样：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Fri, 12 May 2006 18:53:33 GMT</span><br></pre></td></tr></table></figure>
<p>  客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT</span><br></pre></td></tr></table></figure>
<p>总结下来它的结构如下：</p>
<table>
<thead>
<tr>
<th>请求 HeaderValue</th>
<th>响应 HeaderValue</th>
</tr>
</thead>
<tbody>
<tr>
<td> Last-Modified</td>
<td>If-Modified-Since </td>
</tr>
</tbody>
</table>
<p>如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</p>
<p>判断方法用伪代码表示：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ETagFromServer != ETagOnClient || LastModifiedFromServer != LastModifiedOnClient</span><br><span class="line">   GetFromServer</span><br><span class="line">else</span><br><span class="line">   GetFromCache</span><br></pre></td></tr></table></figure>
<p>之所以使用</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastModifiedFromServer != LastModifiedOnClient</span><br></pre></td></tr></table></figure>
<p>而非使用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastModifiedFromServer &gt; LastModifiedOnClient</span><br></pre></td></tr></table></figure>
<p>原因是考虑到可能出现类似下面的情况：服务端可能对资源文件，废除其新版，回滚启用旧版本，此时的情况是：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LastModifiedFromServer &lt;= LastModifiedOnClient</span><br></pre></td></tr></table></figure>
<p>但我们依然要更新本地缓存。</p>
<p> 参考链接：<a href="http://stackoverflow.com/a/824209/3395008" target="_blank" rel="noopener"> <strong><em>What takes precedence: the ETag or Last-Modified HTTP header?</em></strong> </a> </p>
<p> Demo10和 Demo11 给出了一个完整的校验步骤：</p>
<p>并给出了 <code>NSURLConnection</code> 和 <code>NSURLSession</code> 两个版本：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。</span><br><span class="line"> </span><br><span class="line"> @details</span><br><span class="line"> </span><br><span class="line"> 步骤：</span><br><span class="line"> 1. 请求是可变的，缓存策略要每次都从服务器加载</span><br><span class="line"> 2. 每次得到响应后，需要记录住 LastModified</span><br><span class="line"> 3. 下次发送请求的同时，将LastModified一起发送给服务器（由服务器比较内容是否发生变化）</span><br><span class="line"> </span><br><span class="line"> @return 图片资源</span><br><span class="line"> */</span><br><span class="line">- (void)getData:(GetDataCompletion)completion &#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:kLastModifiedImageURL];</span><br><span class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];</span><br><span class="line">    </span><br><span class="line">    //    // 发送 etag</span><br><span class="line">    //    if (self.etag.length &gt; 0) &#123;</span><br><span class="line">    //        [request setValue:self.etag forHTTPHeaderField:@&quot;If-None-Match&quot;];</span><br><span class="line">    //    &#125;</span><br><span class="line">    // 发送 LastModified</span><br><span class="line">    if (self.localLastModified.length &gt; 0) &#123;</span><br><span class="line">        [request setValue:self.localLastModified forHTTPHeaderField:@&quot;If-Modified-Since&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">        // NSLog(@&quot;%@ %tu&quot;, response, data.length);</span><br><span class="line">        // 类型转换（如果将父类设置给子类，需要强制转换）</span><br><span class="line">        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;</span><br><span class="line">        NSLog(@&quot;statusCode == %@&quot;, @(httpResponse.statusCode));</span><br><span class="line">        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）</span><br><span class="line">        if (httpResponse.statusCode == 304) &#123;</span><br><span class="line">            NSLog(@&quot;加载本地缓存图片&quot;);</span><br><span class="line">            // 如果是，使用本地缓存</span><br><span class="line">            // 根据请求获取到`被缓存的响应`！</span><br><span class="line">            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];</span><br><span class="line">            // 拿到缓存的数据</span><br><span class="line">            data = cacheResponse.data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取并且纪录 etag，区分大小写</span><br><span class="line">        //        self.etag = httpResponse.allHeaderFields[@&quot;Etag&quot;];</span><br><span class="line">        // 获取并且纪录 LastModified</span><br><span class="line">        self.localLastModified = httpResponse.allHeaderFields[@&quot;Last-Modified&quot;];</span><br><span class="line">        //        NSLog(@&quot;%@&quot;, self.etag);</span><br><span class="line">        NSLog(@&quot;%@&quot;, self.localLastModified);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            !completion ?: completion(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p> <code>ETag</code>  是什么？</p>
<p> HTTP 协议规格说明定义ETag为“被请求变量的实体值” （参见 —— 章节 14.19）。 另一种说法是，ETag是一个可以与Web资源关联的记号（token）。它是一个 hash 值，用作 Request 缓存请求头，每一个资源文件都对应一个唯一的  <code>ETag</code>  值，<br>服务器单独负责判断记号是什么及其含义，并在HTTP响应头中将其传送到客户端，以下是服务器端返回的格式：</p>
<pre><code>ETag: &quot;50b1c1d4f775c61:df3&quot;


客户端的查询更新格式是这样的：

If-None-Match: W/&quot;50b1c1d4f775c61:df3&quot;
</code></pre><p>其中：</p>
<ul>
<li><code>If-None-Match</code> - 与响应头的 Etag 相对应，可以判断本地缓存数据是否发生变化</li>
</ul>
<pre><code>如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。
</code></pre><p>总结下来它的结构如下：</p>
<table>
<thead>
<tr>
<th>请求 HeaderValue</th>
<th>响应 HeaderValue</th>
</tr>
</thead>
<tbody>
<tr>
<td> ETag</td>
<td>If-None-Match</td>
</tr>
</tbody>
</table>
<p><code>ETag</code> 是的功能与 <code>Last-Modified</code> 类似：服务端不会每次都会返回文件资源。客户端每次向服务端发送上次服务器返回的 <code>ETag</code> 值，服务器会根据客户端与服务端的  <code>ETag</code> 值是否相等，来决定是否返回 data，同时总是返回对应的 <code>HTTP</code> 状态码。客户端通过 <code>HTTP</code> 状态码来决定是否使用缓存。比如：服务端与客户端的 <code>ETag</code> 值相等，则 <code>HTTP</code> 状态码为 304，不返回 data。服务端文件一旦修改，服务端与客户端的 <code>ETag</code> 值不等，并且状态值会变为200，同时返回 data。</p>
<p>因为修改资源文件后该值会立即变更。这也决定了 <code>ETag</code>  在断点下载时非常有用。<br>比如 AFNetworking  在进行断点下载时，就是借助它来检验数据的。详见在  <code>AFHTTPRequestOperation</code>  类中的用法:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    //下载暂停时提供断点续传功能，修改请求的HTTP头，记录当前下载的文件位置，下次可以从这个位置开始下载。</span><br><span class="line">- (void)pause &#123;</span><br><span class="line">    unsigned long long offset = 0;</span><br><span class="line">    if ([self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey]) &#123;</span><br><span class="line">        offset = [[self.outputStream propertyForKey:NSStreamFileCurrentOffsetKey] unsignedLongLongValue];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offset = [[self.outputStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey] length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];</span><br><span class="line">    if ([self.response respondsToSelector:@selector(allHeaderFields)] &amp;&amp; [[self.response allHeaderFields] valueForKey:@&quot;ETag&quot;]) &#123;</span><br><span class="line">    //若请求返回的头部有ETag，则续传时要带上这个ETag，</span><br><span class="line">    //ETag用于放置文件的唯一标识，比如文件MD5值</span><br><span class="line">    //续传时带上ETag服务端可以校验相对上次请求，文件有没有变化，</span><br><span class="line">    //若有变化则返回200，回应新文件的全数据，若无变化则返回206续传。</span><br><span class="line">        [mutableURLRequest setValue:[[self.response allHeaderFields] valueForKey:@&quot;ETag&quot;] forHTTPHeaderField:@&quot;If-Range&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    //给当前request加Range头部，下次请求带上头部，可以从offset位置继续下载</span><br><span class="line">    [mutableURLRequest setValue:[NSString stringWithFormat:@&quot;bytes=%llu-&quot;, offset] forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line">    self.request = mutableURLRequest;</span><br><span class="line"></span><br><span class="line">    [super pause];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>七牛等第三方文件存储商现在都已经支持<code>ETag</code>，Demo8和9 中给出的演示图片就是使用的七牛的服务，见：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const kETagImageURL = @&quot;http://ac-g3rossf7.clouddn.com/xc8hxXBbXexA8LpZEHbPQVB.jpg&quot;;</span><br></pre></td></tr></table></figure>
<p>下面使用一个 Demo 来进行演示用法，</p>
<p>以 <code>NSURLConnection</code> 搭配  <code>ETag</code> 为例，步骤如下：</p>
<ul>
<li>请求的缓存策略使用 <code>NSURLRequestReloadIgnoringCacheData</code>，忽略本地缓存</li>
<li>服务器响应结束后，要记录 <code>Etag</code>，服务器内容和本地缓存对比是否变化的重要依据</li>
<li>在发送请求时，设置 <code>If-None-Match</code>，并且传入 <code>Etag</code></li>
<li>连接结束后，要判断响应头的状态码，如果是 <code>304</code>，说明本地缓存内容没有发生变化</li>
</ul>
<p>以下代码详见 Demo08 ：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。</span><br><span class="line"> </span><br><span class="line"> @details</span><br><span class="line"> </span><br><span class="line"> 步骤：</span><br><span class="line"> 1. 请求是可变的，缓存策略要每次都从服务器加载</span><br><span class="line"> 2. 每次得到响应后，需要记录住 etag</span><br><span class="line"> 3. 下次发送请求的同时，将etag一起发送给服务器（由服务器比较内容是否发生变化）</span><br><span class="line"> </span><br><span class="line"> @return 图片资源</span><br><span class="line"> */</span><br><span class="line">- (void)getData:(GetDataCompletion)completion &#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:kETagImageURL];</span><br><span class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];</span><br><span class="line">    </span><br><span class="line">    // 发送 etag</span><br><span class="line">    if (self.etag.length &gt; 0) &#123;</span><br><span class="line">        [request setValue:self.etag forHTTPHeaderField:@&quot;If-None-Match&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;</span><br><span class="line">        </span><br><span class="line">        // NSLog(@&quot;%@ %tu&quot;, response, data.length);dd</span><br><span class="line">        // 类型转换（如果将父类设置给子类，需要强制转换）</span><br><span class="line">        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;</span><br><span class="line">        NSLog(@&quot;statusCode == %@&quot;, @(httpResponse.statusCode));</span><br><span class="line">        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）</span><br><span class="line">        if (httpResponse.statusCode == 304) &#123;</span><br><span class="line">            NSLog(@&quot;加载本地缓存图片&quot;);</span><br><span class="line">            // 如果是，使用本地缓存</span><br><span class="line">            // 根据请求获取到`被缓存的响应`！</span><br><span class="line">            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];</span><br><span class="line">            // 拿到缓存的数据</span><br><span class="line">            data = cacheResponse.data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取并且纪录 etag，区分大小写</span><br><span class="line">        self.etag = httpResponse.allHeaderFields[@&quot;Etag&quot;];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;etag值%@&quot;, self.etag);</span><br><span class="line">        !completion ?: completion(data);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的  <code>NSURLSession</code>  搭配 ETag 的版本见 Demo09：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> @brief 如果本地缓存资源为最新，则使用使用本地缓存。如果服务器已经更新或本地无缓存则从服务器请求资源。</span><br><span class="line"> </span><br><span class="line"> @details</span><br><span class="line"> </span><br><span class="line"> 步骤：</span><br><span class="line"> 1. 请求是可变的，缓存策略要每次都从服务器加载</span><br><span class="line"> 2. 每次得到响应后，需要记录住 etag</span><br><span class="line"> 3. 下次发送请求的同时，将etag一起发送给服务器（由服务器比较内容是否发生变化）</span><br><span class="line"> </span><br><span class="line"> @return 图片资源</span><br><span class="line"> */</span><br><span class="line">- (void)getData:(GetDataCompletion)completion &#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:kETagImageURL];</span><br><span class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:15.0];</span><br><span class="line">    </span><br><span class="line">    // 发送 etag</span><br><span class="line">    if (self.etag.length &gt; 0) &#123;</span><br><span class="line">        [request setValue:self.etag forHTTPHeaderField:@&quot;If-None-Match&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[[NSURLSession sharedSession] dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">        // NSLog(@&quot;%@ %tu&quot;, response, data.length);</span><br><span class="line">        // 类型转换（如果将父类设置给子类，需要强制转换）</span><br><span class="line">        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;</span><br><span class="line">        NSLog(@&quot;statusCode == %@&quot;, @(httpResponse.statusCode));</span><br><span class="line">        // 判断响应的状态码是否是 304 Not Modified （更多状态码含义解释： https://github.com/ChenYilong/iOSDevelopmentTips）</span><br><span class="line">        if (httpResponse.statusCode == 304) &#123;</span><br><span class="line">            NSLog(@&quot;加载本地缓存图片&quot;);</span><br><span class="line">            // 如果是，使用本地缓存</span><br><span class="line">            // 根据请求获取到`被缓存的响应`！</span><br><span class="line">            NSCachedURLResponse *cacheResponse =  [[NSURLCache sharedURLCache] cachedResponseForRequest:request];</span><br><span class="line">            // 拿到缓存的数据</span><br><span class="line">            data = cacheResponse.data;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 获取并且纪录 etag，区分大小写</span><br><span class="line">        self.etag = httpResponse.allHeaderFields[@&quot;Etag&quot;];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@&quot;, self.etag);</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            !completion ?: completion(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="http://i68.tinypic.com/3yhhx.jpg" alt="enter image description here"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在官方给出的文档中提出 <code>ETag</code>  是首选的方式，优于 <code>Last-Modified</code> 方式。因为 <code>ETag</code> 是基于 hash ，hash 的规则可以自己设置，而且是基于一致性，是“强校验”。 <code>Last-Modified</code> 是基于时间，是弱校验，弱在哪里？比如说：如果服务端的资源回滚客户端的 <code>Last-Modified</code> 反而会比服务端还要新。</p>
<p>虽然 <code>ETag</code>  优于 <code>Last-Modified</code> ，但并非所有服务端都会支持，而 <code>Last-Modified</code> 则一般都会有该字段。 大多数情况下需要与服务端进行协调支持 <code>ETag</code>  ，如果协商无果就只能退而求其次。</p>
<p>Demo 也给出了一个不支持 <code>ETag</code> 的链接，基本随便找一张图片都行：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const kLastModifiedImageURL = @&quot;http://image17-c.poco.cn/mypoco/myphoto/20151211/16/17338872420151211164742047.png&quot;;</span><br></pre></td></tr></table></figure>
<p>作为通用型的网络请求工具 AFNetworking 对该现状的处理方式是，判断服务端是否包含 <code>ETag</code> ，然后再进行相应处理。可见  <code>AFHTTPRequestOperation</code>  类中的用法，也就是上文中已经给出的断点下载的代码。</p>
<p>在回顾下思路：</p>
<ul>
<li>为资源分派 hash 值，然后对比服务端与本地缓存是否一致来决定是否需要更新缓存。</li>
</ul>
<p>这种思路，在开发中经常使用，比如：处于安全考虑，登陆操作一般不会传输账号密码，而是传输对应的 hash 值– token ，这里的 token 就可以看做一个 file 资源，如果想让一个用户登陆超时时间是三天，只需要在服务端每隔三天更改下 token 值，客户端与服务端值不一致，然后服务端返回 token 过期的提示。</p>
<p>值得注意的一点是：</p>
<ul>
<li>如果借助了 <code>Last-Modified</code>  和  <code>ETag</code>，那么缓存策略则必须使用  <code>NSURLRequestReloadIgnoringCacheData</code> 策略，忽略缓存，每次都要向服务端进行校验。</li>
</ul>
<p>如果 GET 中包含有版本号信息</p>
<p> 众多的应用都会在 GET 请求后加上版本号：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://abc.com?my_current_version=v1.0.0</span><br></pre></td></tr></table></figure>
<p> 这种情况下，<br> <code>?v1.0</code>  和 <code>?v2.0</code> 两个不同版本，请求到的 <code>Last-Modified</code>  和  <code>ETag</code> 会如预期吗？</p>
<p> 这完全取决于公司服务端同事的实现， <code>Last-Modified</code>  和   <code>ETag</code> 仅仅是一个协议，并没有统一的实现方法，而服务端的处理逻辑完全取决于需求。</p>
<p>你完全可以要求服务端同事，仅仅判断资源的异同，而忽略掉 <code>?v1.0</code>  和 <code>?v2.0</code> 两个版本的区别。</p>
<p>参考链接：<a href="http://stackoverflow.com/a/1005505" target="_blank" rel="noopener"><strong><em>if-modified-since vs if-none-match</em></strong></a></p>
<h2 id="一般数据类型借助-Last-Modified-与-ETag-进行缓存"><a href="#一般数据类型借助-Last-Modified-与-ETag-进行缓存" class="headerlink" title="一般数据类型借助 Last-Modified 与  ETag 进行缓存"></a>一般数据类型借助 <code>Last-Modified</code> 与  <code>ETag</code> 进行缓存</h2><p>以上的讨论是基于文件资源，那么对一般的网络请求是否也能应用？</p>
<p>控制缓存过期时间，无非两种：设置一个过期时间；校验缓存与服务端一致性，只在不一致时才更新。</p>
<p>一般情况下是不会对 api 层面做这种校验，只在有业务需求时才会考虑做，比如：</p>
<ol>
<li>数据更新频率较低，“万不得已不会更新”—只在服务器有更新时才更新，以此来保证2G 等恶略网络环境下，有较好的体验。比如网易新闻栏目，但相反微博列表、新闻列表就不适合。</li>
<li>业务数据一致性要求高，数据更新后需要服务端立刻展示给用户。客户端显示的数据必须是服务端最新的数据</li>
<li>有离线展示需求，必须实现缓存策略，保证弱网情况下的数据展示的速度。但不考虑使用缓存过期时间来控制缓存的有效性。</li>
<li>尽量减少数据传输，节省用户流量</li>
</ol>
<p>一些建议：</p>
<ol>
<li>如果是 file 文件类型，用 <code>Last-Modified</code> 就够了。即使 <code>ETag</code> 是首选，但此时两者效果一致。九成以上的需求，效果都一致。</li>
<li><p>如果是一般的数据类型–基于查询的 get 请求，比如返回值是 data 或 string 类型的 json 返回值。那么 <code>Last-Modified</code> 服务端支持起来就会困难一点。因为比如<br>你做了一个博客浏览 app ，查询最近的10条博客， 基于此时的业务考虑 <code>Last-Modified</code> 指的是10条中任意一个博客的更改。那么服务端需要在你发出请求后，遍历下10条数据，得到“10条中是否至少一个被修改了”。而且要保证每一条博客表数据都有一个类似于记录 <code>Last-Modified</code> 的字段，这显然不太现实。</p>
<p>如果更新频率较高，比如最近微博列表、最近新闻列表，这些请求就不适合，更多的处理方式是添加一个接口，客户端将本地缓存的最后一条数据的的时间戳或 id 传给服务端，然后服务端会将新增的数据条数返回，没有新增则返回 nil 或 304。</p>
</li>
</ol>
<p>参考链接： <a href="http://www.jianshu.com/p/8a4dc775c051" target="_blank" rel="noopener">《(慕课网)imooc iPhone3.3 接口数据缓存》</a> </p>
<h3 id="剩下20-的网络缓存需求"><a href="#剩下20-的网络缓存需求" class="headerlink" title="剩下20%的网络缓存需求"></a>剩下20%的网络缓存需求</h3><h4 id="真的有NSURLCache-不能满足的需求？"><a href="#真的有NSURLCache-不能满足的需求？" class="headerlink" title="真的有NSURLCache 不能满足的需求？"></a>真的有<code>NSURLCache</code> 不能满足的需求？</h4><p>有人可能要问：</p>
<blockquote>
<p><code>NSURLCache</code> 不是帮我们做了硬盘缓存么？那我们为什么要自己用数据库做本地缓存啊。为啥不直接用<code>NSURLCache</code> 不是更方便？</p>
</blockquote>
<p>系统帮我们做的缓存，好处是自动，无需我们进行复杂的设置。坏处也恰恰是这个：不够灵活，不能自定义。只能指定一个缓存的总文件夹，不能分别指定每一个文件缓存的位置，更不能为每个文件创建一个文件夹，也不能指定文件夹的名称。缓存的对象也是固定的：只能是 GET请求的返回值。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/IOS/" rel="tag"># IOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/14/Parse的底层多线程处理思路/" rel="next" title="Parse的底层多线程处理思路">
                <i class="fa fa-chevron-left"></i> Parse的底层多线程处理思路
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/08/IOS-锁/" rel="prev" title="IOS-锁">
                IOS-锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">------ IOS | Python ------</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#iOS网络缓存扫盲篇–使用两行代码就能完成80-的缓存需求"><span class="nav-number">1.</span> <span class="nav-text">iOS网络缓存扫盲篇–使用两行代码就能完成80%的缓存需求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#当我们在谈论缓存的时候，我们在谈论什么？"><span class="nav-number">1.0.1.</span> <span class="nav-text">当我们在谈论缓存的时候，我们在谈论什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET网络请求缓存"><span class="nav-number">1.1.</span> <span class="nav-text">GET网络请求缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-的缓存需求：两行代码就可满足"><span class="nav-number">1.1.2.</span> <span class="nav-text">80%的缓存需求：两行代码就可满足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制缓存的有效性"><span class="nav-number">1.1.3.</span> <span class="nav-text">控制缓存的有效性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件缓存：借助ETag或Last-Modified判断文件缓存是否有效"><span class="nav-number">1.1.4.</span> <span class="nav-text">文件缓存：借助ETag或Last-Modified判断文件缓存是否有效</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Last-Modified"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">Last-Modified</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ETag"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">ETag</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一般数据类型借助-Last-Modified-与-ETag-进行缓存"><span class="nav-number">1.2.</span> <span class="nav-text">一般数据类型借助 Last-Modified 与  ETag 进行缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#剩下20-的网络缓存需求"><span class="nav-number">1.2.1.</span> <span class="nav-text">剩下20%的网络缓存需求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#真的有NSURLCache-不能满足的需求？"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">真的有NSURLCache 不能满足的需求？</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


 <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v</div>
-->




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v="></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v="></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v="></script>
<script type="text/javascript" src="/js/src/post-details.js?v="></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
